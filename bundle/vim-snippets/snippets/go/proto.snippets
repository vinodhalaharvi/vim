snippet printFeature
	func printFeature(client pb.RouteGuideClient, point *pb.Point) {
		log.Printf("Getting feature for point (%d, %d)", point.Latitude, point.Longitude)
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		feature, err := client.GetFeature(ctx, point)
		if err != nil {
			log.Fatalf("%v.GetFeatures(_) = _, %v: ", client, err)
		}
		log.Println(feature)
	}

snippet printFeatures
	func printFeatures(client pb.RouteGuideClient, rect *pb.Rectangle) {
		log.Printf("Looking for features within %v", rect)
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		stream, err := client.ListFeatures(ctx, rect)
		if err != nil {
			log.Fatalf("%v.ListFeatures(_) = _, %v", client, err)
		}
		for {
			feature, err := stream.Recv()
			if err == io.EOF {
				break
			}
			if err != nil {
				log.Fatalf("%v.ListFeatures(_) = _, %v", client, err)
			}
			log.Println(feature)
		}
	}

snippet runClientUploadStream
	func runClientUploadStream(client pb.RouteGuideClient) {
		r := rand.New(rand.NewSource(time.Now().UnixNano()))
		pointCount := int(r.Int31n(100)) + 2 // Traverse at least two points
		var points []*pb.Point
		for i := 0; i < pointCount; i++ {
			points = append(points, randomPoint(r))
		}
		log.Printf("Traversing %d points.", len(points))
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		stream, err := client.ClientUploadStream(ctx)
		if err != nil {
			log.Fatalf("%v.ClientUploadStream(_) = _, %v", client, err)
		}
		for _, point := range points {
			if err := stream.Send(point); err != nil {
				log.Fatalf("%v.Send(%v) = %v", stream, point, err)
			}
		}
		reply, err := stream.CloseAndRecv()
		if err != nil {
			log.Fatalf("%v.CloseAndRecv() got error %v, want %v", stream, err, nil)
		}
		log.Printf("Route summary: %v", reply)
	}

snippet runBidiStream
	func runBidiStream(client pb.RouteGuideClient) {
		notes := []*pb.RouteNote{
		}
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		stream, err := client.BidiStream(ctx)
		if err != nil {
			log.Fatalf("%v.BidiStream(_) = _, %v", client, err)
		}
		waitc := make(chan struct{})
		go func() {
			for {
				in, err := stream.Recv()
				if err == io.EOF {
					close(waitc)
					return
				}
				if err != nil {
					log.Fatalf("Failed to receive a note : %v", err)
				}
				log.Printf("Got message %s at point(%d, %d)", in.Message, in.Location.Latitude, in.Location.Longitude)
			}
		}()
		for _, note := range notes {
			if err := stream.Send(note); err != nil {
				log.Fatalf("Failed to send a note: %v", err)
			}
		}
		stream.CloseSend()
		<-waitc
	}


snippet grpc_client_tls
	func main() {
		flag.Parse()
		var opts []grpc.DialOption
		if *tls {
			if *caFile == "" {
				*caFile = testdata.Path("ca.pem")
			}
			creds, err := credentials.NewClientTLSFromFile(*caFile, *serverHostOverride)
			if err != nil {
				log.Fatalf("Failed to create TLS credentials %v", err)
			}
			opts = append(opts, grpc.WithTransportCredentials(creds))
		} else {
			opts = append(opts, grpc.WithInsecure())
		}
		conn, err := grpc.Dial(*serverAddr, opts...)
		if err != nil {
			log.Fatalf("fail to dial: %v", err)
		}
		defer conn.Close()
		client := pb.NewRouteGuideClient(conn)

		printFeature(client, &pb.Point{Latitude: 409146138, Longitude: -746188906})

		printFeature(client, &pb.Point{Latitude: 0, Longitude: 0})

		printFeatures(client, &pb.Rectangle{
			Lo: &pb.Point{Latitude: 400000000, Longitude: -750000000},
			Hi: &pb.Point{Latitude: 420000000, Longitude: -730000000},
		})

		runClientUploadStream(client)
	}

snippet GetFeature
	func (s *routeGuideServer) GetFeature(ctx context.Context, point *pb.Point) (*pb.Feature, error) {
		for _, feature := range s.savedFeatures {
			if proto.Equal(feature.Location, point) {
				return feature, nil
			}
		}
		return &pb.Feature{Location: point}, nil
	}

snippet ListFeatures
	func (s *routeGuideServer) ListFeatures(rect *pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer) error {
		for _, feature := range s.savedFeatures {
			if inRange(feature.Location, rect) {
				if err := stream.Send(feature); err != nil {
					return err
				}
			}
		}
		return nil
	}

snippet ClientUploadStream
	func (s *routeGuideServer) ClientUploadStream(stream pb.RouteGuide_ClientUploadStreamServer) error {
		var pointCount, featureCount, distance int32
		var lastPoint *pb.Point
		startTime := time.Now()
		for {
			point, err := stream.Recv()
			if err == io.EOF {
				endTime := time.Now()
				return stream.SendAndClose(&pb.RouteSummary{
					PointCount:   pointCount,
					FeatureCount: featureCount,
					Distance:     distance,
					ElapsedTime:  int32(endTime.Sub(startTime).Seconds()),
				})
			}
			if err != nil {
				return err
			}
			pointCount++
			for _, feature := range s.savedFeatures {
				if proto.Equal(feature.Location, point) {
					featureCount++
				}
			}
			if lastPoint != nil {
				distance += calcDistance(lastPoint, point)
			}
			lastPoint = point
		}
	}

snippet BidiStream
	func (s *routeGuideServer) BidiStream(stream pb.RouteGuide_BidiStreamServer) error {
		for {
			in, err := stream.Recv()
			if err == io.EOF {
				return nil
			}
			if err != nil {
				return err
			}
			key := serialize(in.Location)

			s.mu.Lock()
			items := make()
			s.mu.Unlock()

			for _, it := range items {
				if err := stream.Send(it); err != nil {
					return err
				}
			}
		}
	}

snippet serialize
	func serialize(point *pb.Point) string {
		return fmt.Sprintf("%d %d", point.Latitude, point.Longitude)
	}

snippet newServer
	func newServer() *routeGuideServer {
		s := &routeGuideServer{routeNotes: make(map[string][]*pb.RouteNote)}
		s.loadFeatures(*jsonDBFile)
		return s
	}

snippet grpc_server_tls
	func main() {
		flag.Parse()
		lis, err := net.Listen("tcp", fmt.Sprintf("localhost:%d", *port))
		if err != nil {
			log.Fatalf("failed to listen: %v", err)
		}
		var opts []grpc.ServerOption
		if *tls {
			if *certFile == "" {
				*certFile = testdata.Path("server1.pem")
			}
			if *keyFile == "" {
				*keyFile = testdata.Path("server1.key")
			}
			creds, err := credentials.NewServerTLSFromFile(*certFile, *keyFile)
			if err != nil {
				log.Fatalf("Failed to generate credentials %v", err)
			}
			opts = []grpc.ServerOption{grpc.Creds(creds)}
		}
		grpcServer := grpc.NewServer(opts...)
		pb.RegisterRouteGuideServer(grpcServer, newServer())
		grpcServer.Serve(lis)
	}

snippet sample_proto_buf_file
	syntax = "proto3";
	package routeguide;

	service RouteGuide {
	  rpc GetFeature(Foo) returns (Bar) {}
	  rpc ListFeatures(Foo) returns (stream Bar) {}
	  rpc ClientUploadStream(stream Foo) returns (Foo) {}
	  rpc BidiStream(stream Foo) returns (stream Bar) {}
	}

	message Foo {
		string foo01; 
	}

	message Bar {
		string bar01; 
	}

