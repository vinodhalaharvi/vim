snippet example_grpc_client_func
	// sample func ${1:FunctionName}  grpc client
	func $1(client pb.GrpcClientType, in *pb.inType) {
		ctx, cancel := context.WithTimeout(context.Background(), 10 * time.Second)
		defer cancel()
		it, err := client.GetFeature(ctx, in)
		if err != nil {
			log.Fatalf("%v.$1(_) = _, %v: ", client, err)
		}
		log.Println(it)
	}

snippet example_grpc_client_recv_stream
	// sample func ${1:FunctionName}  grpc client
	func $1(client pb.GrpcClientType, in *pb.InType) {
		log.Printf("Looking for features within %v", in)
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		stream, err := client.Grpc$1(ctx, in)
		if err != nil {
			log.Fatalf("%v.$1(_) = _, %v", client, err)
		}
		for {
			feature, err := stream.Recv()
			if err == io.EOF {
				break
			}
			if err != nil {
				log.Fatalf("%v.ListFeatures(_) = _, %v", client, err)
			}
			log.Println(it)
		}
	}

snippet example_grpc_client_send_stream
	func runRecordRoute(client pb.RouteGuideClient) {
		// Create a random number of random points
		r := rand.New(rand.NewSource(time.Now().UnixNano()))
		pointCount := int(r.Int31n(100)) + 2 // Traverse at least two points
		var points []*pb.Point
		for i := 0; i < pointCount; i++ {
			points = append(points, randomPoint(r))
		}
		log.Printf("Traversing %d points.", len(points))
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		stream, err := client.RecordRoute(ctx)
		if err != nil {
			log.Fatalf("%v.RecordRoute(_) = _, %v", client, err)
		}
		for _, point := range points {
			if err := stream.Send(point); err != nil {
				log.Fatalf("%v.Send(%v) = %v", stream, point, err)
			}
		}
		reply, err := stream.CloseAndRecv()
		if err != nil {
			log.Fatalf("%v.CloseAndRecv() got error %v, want %v", stream, err, nil)
		}
		log.Printf("Route summary: %v", reply)
	}


snippet example_grpc_client_bidi_stream
	func runRouteChat(client pb.RouteGuideClient) {
		notes := []*pb.RouteNote{
			{Location: &pb.Point{Latitude: 0, Longitude: 1}, Message: "First message"},
		}
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		stream, err := client.RouteChat(ctx)
		if err != nil {
			log.Fatalf("%v.RouteChat(_) = _, %v", client, err)
		}
		waitc := make(chan struct{})
		go func() {
			for {
				in, err := stream.Recv()
				if err == io.EOF {
					// read done.
					close(waitc)
					return
				}
				if err != nil {
					log.Fatalf("Failed to receive a note : %v", err)
				}
				log.Printf("Got message %s at point(%d, %d)", in.Message, in.Location.Latitude, in.Location.Longitude)
			}
		}()
		for _, note := range notes {
			if err := stream.Send(note); err != nil {
				log.Fatalf("Failed to send a note: %v", err)
			}
		}
		stream.CloseSend()
		<-waitc
	}


snippet example_functional
	func main() {
		// Here we try out our various collection functions.
		var strs = []string{"peach", "apple", "pear", "plum"}
		fmt.Println(Index(strs, "pear"))
		fmt.Println(Include(strs, "grape"))
		fmt.Println(Any(strs, func(v string) bool {
			return strings.HasPrefix(v, "p")
		}))
		fmt.Println(All(strs, func(v string) bool {
			return strings.HasPrefix(v, "p")
		}))
		fmt.Println(Filter(strs, func(v string) bool {
			return strings.Contains(v, "e")
		}))
		// The above examples all used anonymous functions,
		// but you can also use named functions of the correct
		// type.
		fmt.Println(Map(strs, strings.ToUpper))
	}


snippet example_json_marshal
	type Message struct {
		Name string
		Body string
		Time int64
	}
	m := Message{"Alice", "Hello", 1294706395881547000}
	b, err := json.Marshal(m)
	if err != nil {
		log.Printf("err = %+v\n", err)
	}



snippet example_json_unmarshal
	var m Message
	if err := json.Unmarshal(b, &m); err != nil {
		log.Printf("err = %+v\n", err)
	}




snippet example_code_web_socket_client
	<!DOCTYPE html>
	<html lang="en">
	<head>
	<title>Chat Example</title>
	<script type="text/javascript">
	window.onload = function () {
		var conn;
		var msg = document.getElementById("msg");
		var log = document.getElementById("log");

		function appendLog(item) {
			var doScroll = log.scrollTop > log.scrollHeight - log.clientHeight - 1;
			log.appendChild(item);
			if (doScroll) {
				log.scrollTop = log.scrollHeight - log.clientHeight;
			}
		}

		document.getElementById("form").onsubmit = function () {
			if (!conn) {
				return false;
			}
			if (!msg.value) {
				return false;
			}
			conn.send(msg.value);
			msg.value = "";
			return false;
		};

		if (window["WebSocket"]) {
			conn = new WebSocket("ws://" + document.location.host + "/ws");
			conn.onclose = function (evt) {
				var item = document.createElement("div");
				item.innerHTML = "<b>Connection closed.</b>";
				appendLog(item);
			};
			conn.onmessage = function (evt) {
				var messages = evt.data.split('\n');
				for (var i = 0; i < messages.length; i++) {
					var item = document.createElement("div");
					item.innerText = messages[i];
					appendLog(item);
				}
			};
		} else {
			var item = document.createElement("div");
			item.innerHTML = "<b>Your browser does not support WebSockets.</b>";
			appendLog(item);
		}
	};
	</script>
	<style type="text/css">
	html {
		overflow: hidden;
	}

	body {
		overflow: hidden;
		padding: 0;
		margin: 0;
		width: 100%;
		height: 100%;
		background: gray;
	}

	#log {
		background: white;
		margin: 0;
		padding: 0.5em 0.5em 0.5em 0.5em;
		position: absolute;
		top: 0.5em;
		left: 0.5em;
		right: 0.5em;
		bottom: 3em;
		overflow: auto;
	}

	#form {
		padding: 0 0.5em 0 0.5em;
		margin: 0;
		position: absolute;
		bottom: 1em;
		left: 0px;
		width: 100%;
		overflow: hidden;
	}

	</style>
	</head>
	<body>
	<div id="log"></div>
	<form id="form">
		<input type="submit" value="Send" />
		<input type="text" id="msg" size="64"/>
	</form>
	</body>
	</html>


snippet example_grpc_client
	package main

	import (
		"context"
		"log"
		"os"
		"time"

		"google.golang.org/grpc"
		pb "google.golang.org/grpc/examples/helloworld/helloworld"
	)

	const (
		address     = "localhost:50051"
		defaultName = "world"
	)

	func main() {
		// Set up a connection to the server.
		conn, err := grpc.Dial(address, grpc.WithInsecure())
		if err != nil {
			log.Fatalf("did not connect: %v", err)
		}
		defer conn.Close()
		c := pb.NewGreeterClient(conn)

		// Contact the server and print out its response.
		name := defaultName
		if len(os.Args) > 1 {
			name = os.Args[1]
		}
		ctx, cancel := context.WithTimeout(context.Background(), time.Second)
		defer cancel()
		r, err := c.SayHello(ctx, &pb.HelloRequest{Name: name})
		if err != nil {
			log.Fatalf("could not greet: %v", err)
		}
		log.Printf("Greeting: %s", r.Message)
	}

snippet example_grpc_server
	package main

	import (
		"context"
		"log"
		"net"

		"google.golang.org/grpc"
		pb "google.golang.org/grpc/examples/helloworld/helloworld"
	)

	const (
		port = ":50051"
	)

	// server is used to implement helloworld.GreeterServer.
	type server struct{}

	// SayHello implements helloworld.GreeterServer
	func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {
		log.Printf("Received: %v", in.Name)
		return &pb.HelloReply{Message: "Hello " + in.Name}, nil
	}

	func main() {
		lis, err := net.Listen("tcp", port)
		if err != nil {
			log.Fatalf("failed to listen: %v", err)
		}
		s := grpc.NewServer()
		pb.RegisterGreeterServer(s, &server{})
		if err := s.Serve(lis); err != nil {
			log.Fatalf("failed to serve: %v", err)
		}
	}


