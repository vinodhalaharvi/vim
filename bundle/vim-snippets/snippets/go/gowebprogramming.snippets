snippet Deploying_Go_mosaic_docker_main
	package main

	import (
		"bytes"
		"encoding/base64"
		"fmt"
		"html/template"
		"image"
		"image/draw"
		"image/jpeg"
		"net/http"
		"os"
		"runtime"
		"strconv"
		"sync"
		"time"
	)

	func main() {
		fmt.Println("Number of CPUs:", runtime.NumCPU())
		runtime.GOMAXPROCS(runtime.NumCPU())
		fmt.Println("Starting mosaic server ...")
		mux := http.NewServeMux()
		files := http.FileServer(http.Dir("public"))
		mux.Handle("/static/", http.StripPrefix("/static/", files))

		mux.HandleFunc("/", upload)
		mux.HandleFunc("/mosaic", mosaic)

		server := &http.Server{
			Addr:    ":" + os.Getenv("PORT"),
			Handler: mux,
		}
		TILESDB = make(map[string][3]float64)
		go tilesDB()
		fmt.Println("Mosaic server started.")
		server.ListenAndServe()

	}

	func upload(w http.ResponseWriter, r *http.Request) {
		t, _ := template.ParseFiles("upload.html")
		t.Execute(w, nil)
	}

	// cut out the image and return individual channels with image.Image
	// no encoding of JPEG
	func cut(original image.Image, db *map[string][3]float64, tileSize, x1, y1, x2, y2 int) <-chan image.Image {
		c := make(chan image.Image)
		sp := image.Point{0, 0}
		go func() {
			newimage := image.NewNRGBA(image.Rect(x1, y1, x2, y2))
			for y := y1; y < y2; y = y + tileSize {
				for x := x1; x < x2; x = x + tileSize {
					r, g, b, _ := original.At(x, y).RGBA()
					color := [3]float64{float64(r), float64(g), float64(b)}
					nearest := nearest(color, db)
					file, err := os.Open(nearest)
					if err == nil {
						img, _, err := image.Decode(file)
						if err == nil {
							t := resize(img, tileSize)
							tile := t.SubImage(t.Bounds())
							tileBounds := image.Rect(x, y, x+tileSize, y+tileSize)
							draw.Draw(newimage, tileBounds, tile, sp, draw.Src)
						} else {
							fmt.Println("error in decoding nearest", err, nearest)
						}
					} else {
						fmt.Println("error opening file when creating mosaic:", nearest)
					}
					file.Close()
				}
			}
			c <- newimage.SubImage(newimage.Rect)
		}()

		return c
	}

	// combine the images and return the encoding string
	func combine(r image.Rectangle, c1, c2, c3, c4 <-chan image.Image) <-chan string {
		c := make(chan string)
		// start a goroutine
		go func() {
			var wg sync.WaitGroup
			newimage := image.NewNRGBA(r)
			copy := func(dst draw.Image, r image.Rectangle, src image.Image, sp image.Point) {
				draw.Draw(dst, r, src, sp, draw.Src)
				wg.Done()
			}
			wg.Add(4)
			var s1, s2, s3, s4 image.Image
			var ok1, ok2, ok3, ok4 bool
			for {
				select {
				case s1, ok1 = <-c1:
					go copy(newimage, s1.Bounds(), s1, image.Point{r.Min.X, r.Min.Y})
				case s2, ok2 = <-c2:
					go copy(newimage, s2.Bounds(), s2, image.Point{r.Max.X / 2, r.Min.Y})
				case s3, ok3 = <-c3:
					go copy(newimage, s3.Bounds(), s3, image.Point{r.Min.X, r.Max.Y / 2})
				case s4, ok4 = <-c4:
					go copy(newimage, s4.Bounds(), s4, image.Point{r.Max.X / 2, r.Max.Y / 2})
				}
				if ok1 && ok2 && ok3 && ok4 {
					break
				}
			}
			// wait till all copy goroutines are complete
			wg.Wait()
			buf2 := new(bytes.Buffer)
			jpeg.Encode(buf2, newimage, nil)
			c <- base64.StdEncoding.EncodeToString(buf2.Bytes())
		}()
		return c
	}

	//  Handler function for fan-out and fan-in
	func mosaic(w http.ResponseWriter, r *http.Request) {
		t0 := time.Now()
		// get the content from the POSTed form
		r.ParseMultipartForm(10485760) // max body in memory is 10MB
		file, _, _ := r.FormFile("image")
		defer file.Close()
		tileSize, _ := strconv.Atoi(r.FormValue("tile_size"))
		//
		//   // decode and get original image
		original, _, _ := image.Decode(file)
		bounds := original.Bounds()
		db := cloneTilesDB()

		// fan-out
		c1 := cut(original, &db, tileSize, bounds.Min.X, bounds.Min.Y, bounds.Max.X/2, bounds.Max.Y/2)
		c2 := cut(original, &db, tileSize, bounds.Max.X/2, bounds.Min.Y, bounds.Max.X, bounds.Max.Y/2)
		c3 := cut(original, &db, tileSize, bounds.Min.X, bounds.Max.Y/2, bounds.Max.X/2, bounds.Max.Y)
		c4 := cut(original, &db, tileSize, bounds.Max.X/2, bounds.Max.Y/2, bounds.Max.X, bounds.Max.Y)

		// fan-in
		c := combine(bounds, c1, c2, c3, c4)

		buf1 := new(bytes.Buffer)
		jpeg.Encode(buf1, original, nil)
		originalStr := base64.StdEncoding.EncodeToString(buf1.Bytes())

		t1 := time.Now()
		images := map[string]string{
			"original": originalStr,
			"mosaic":   <-c,
			"duration": fmt.Sprintf("%v ", t1.Sub(t0)),
		}

		t, _ := template.ParseFiles("results.html")
		t.Execute(w, images)
	}


snippet Deploying_Go_mosaic_docker_mosaic
	package main

	import (
		"fmt"
		"image"
		"image/color"
		"io/ioutil"
		"math"
		"os"
	)

	// resize an image by its ratio e.g. ratio 2 means reduce the size by 1/2, 10 means reduce the size by 1/10
	func resize(in image.Image, newWidth int) image.NRGBA {
		bounds := in.Bounds()
		width := bounds.Max.X - bounds.Min.X
		ratio := width / newWidth
		out := image.NewNRGBA(image.Rect(bounds.Min.X/ratio, bounds.Min.X/ratio, bounds.Max.X/ratio, bounds.Max.Y/ratio))
		for y, j := bounds.Min.Y, bounds.Min.Y; y < bounds.Max.Y; y, j = y+ratio, j+1 {
			for x, i := bounds.Min.X, bounds.Min.X; x < bounds.Max.X; x, i = x+ratio, i+1 {
				r, g, b, a := in.At(x, y).RGBA()
				out.SetNRGBA(i, j, color.NRGBA{uint8(r), uint8(g), uint8(b), uint8(a)})
			}
		}
		return *out
	}

	// find the average color of the picture
	func averageColor(img image.Image) [3]float64 {
		bounds := img.Bounds()
		r, g, b := 0.0, 0.0, 0.0
		for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
			for x := bounds.Min.X; x < bounds.Max.X; x++ {
				r1, g1, b1, _ := img.At(x, y).RGBA()
				r, g, b = r+float64(r1), g+float64(g1), b+float64(b1)
			}
		}
		totalPixels := float64(bounds.Max.X * bounds.Max.Y)
		return [3]float64{r / totalPixels, g / totalPixels, b / totalPixels}
	}

	var TILESDB map[string][3]float64

	func cloneTilesDB() map[string][3]float64 {
		db := make(map[string][3]float64)
		for k, v := range TILESDB {
			db[k] = v
		}
		return db
	}

	// populate a tiles database in memory
	func tilesDB() {
		fmt.Println("Start populating tiles db ...")
		files, _ := ioutil.ReadDir("tiles")
		for _, f := range files {
			name := "tiles/" + f.Name()
			file, err := os.Open(name)
			if err == nil {
				img, _, err := image.Decode(file)
				if err == nil {
					TILESDB[name] = averageColor(img)
				} else {
					fmt.Println("error in populating tiles db:", err, name)
				}
			} else {
				fmt.Println("cannot open file", name, "when populating tiles db:", err)
			}
			file.Close()
		}
		fmt.Println("Finished populating tiles db.")
	}

	// find the nearest matching image
	func nearest(target [3]float64, db *map[string][3]float64) string {
		var filename string
		smallest := 1000000.0
		for k, v := range *db {
			dist := distance(target, v)
			if dist < smallest {
				filename, smallest = k, dist
			}
		}
		delete(*db, filename)
		return filename
	}

	// find the Eucleadian distance between 2 points
	func distance(p1 [3]float64, p2 [3]float64) float64 {
		return math.Sqrt(sq(p2[0]-p1[0]) + sq(p2[1]-p1[1]) + sq(p2[2]-p1[2]))
	}

	// find the square
	func sq(n float64) float64 {
		return n * n
	}


snippet Deploying_Go_mosaic_heroku_main
	package main

	import (
		"bytes"
		"encoding/base64"
		"fmt"
		"html/template"
		"image"
		"image/draw"
		"image/jpeg"
		"net/http"
		"os"
		"runtime"
		"strconv"
		"sync"
		"time"
	)

	func main() {
		fmt.Println("Number of CPUs:", runtime.NumCPU())
		runtime.GOMAXPROCS(runtime.NumCPU())
		fmt.Println("Starting mosaic server ...")
		mux := http.NewServeMux()
		files := http.FileServer(http.Dir("public"))
		mux.Handle("/static/", http.StripPrefix("/static/", files))

		mux.HandleFunc("/", upload)
		mux.HandleFunc("/mosaic", mosaic)

		server := &http.Server{
			Addr:    ":" + os.Getenv("PORT"),
			Handler: mux,
		}
		TILESDB = make(map[string][3]float64)
		go tilesDB()
		fmt.Println("Mosaic server started.")
		server.ListenAndServe()

	}

	func upload(w http.ResponseWriter, r *http.Request) {
		t, _ := template.ParseFiles("upload.html")
		t.Execute(w, nil)
	}

	// cut out the image and return individual channels with image.Image
	// no encoding of JPEG
	func cut(original image.Image, db *map[string][3]float64, tileSize, x1, y1, x2, y2 int) <-chan image.Image {
		c := make(chan image.Image)
		sp := image.Point{0, 0}
		go func() {
			newimage := image.NewNRGBA(image.Rect(x1, y1, x2, y2))
			for y := y1; y < y2; y = y + tileSize {
				for x := x1; x < x2; x = x + tileSize {
					r, g, b, _ := original.At(x, y).RGBA()
					color := [3]float64{float64(r), float64(g), float64(b)}
					nearest := nearest(color, db)
					file, err := os.Open(nearest)
					if err == nil {
						img, _, err := image.Decode(file)
						if err == nil {
							t := resize(img, tileSize)
							tile := t.SubImage(t.Bounds())
							tileBounds := image.Rect(x, y, x+tileSize, y+tileSize)
							draw.Draw(newimage, tileBounds, tile, sp, draw.Src)
						} else {
							fmt.Println("error in decoding nearest", err, nearest)
						}
					} else {
						fmt.Println("error opening file when creating mosaic:", nearest)
					}
					file.Close()
				}
			}
			c <- newimage.SubImage(newimage.Rect)
		}()

		return c
	}

	// combine the images and return the encoding string
	func combine(r image.Rectangle, c1, c2, c3, c4 <-chan image.Image) <-chan string {
		c := make(chan string)
		// start a goroutine
		go func() {
			var wg sync.WaitGroup
			newimage := image.NewNRGBA(r)
			copy := func(dst draw.Image, r image.Rectangle, src image.Image, sp image.Point) {
				draw.Draw(dst, r, src, sp, draw.Src)
				wg.Done()
			}
			wg.Add(4)
			var s1, s2, s3, s4 image.Image
			var ok1, ok2, ok3, ok4 bool
			for {
				select {
				case s1, ok1 = <-c1:
					go copy(newimage, s1.Bounds(), s1, image.Point{r.Min.X, r.Min.Y})
				case s2, ok2 = <-c2:
					go copy(newimage, s2.Bounds(), s2, image.Point{r.Max.X / 2, r.Min.Y})
				case s3, ok3 = <-c3:
					go copy(newimage, s3.Bounds(), s3, image.Point{r.Min.X, r.Max.Y / 2})
				case s4, ok4 = <-c4:
					go copy(newimage, s4.Bounds(), s4, image.Point{r.Max.X / 2, r.Max.Y / 2})
				}
				if ok1 && ok2 && ok3 && ok4 {
					break
				}
			}
			// wait till all copy goroutines are complete
			wg.Wait()
			buf2 := new(bytes.Buffer)
			jpeg.Encode(buf2, newimage, nil)
			c <- base64.StdEncoding.EncodeToString(buf2.Bytes())
		}()
		return c
	}

	//  Handler function for fan-out and fan-in
	func mosaic(w http.ResponseWriter, r *http.Request) {
		t0 := time.Now()
		// get the content from the POSTed form
		r.ParseMultipartForm(10485760) // max body in memory is 10MB
		file, _, _ := r.FormFile("image")
		defer file.Close()
		tileSize, _ := strconv.Atoi(r.FormValue("tile_size"))
		//
		//   // decode and get original image
		original, _, _ := image.Decode(file)
		bounds := original.Bounds()
		db := cloneTilesDB()

		// fan-out
		c1 := cut(original, &db, tileSize, bounds.Min.X, bounds.Min.Y, bounds.Max.X/2, bounds.Max.Y/2)
		c2 := cut(original, &db, tileSize, bounds.Max.X/2, bounds.Min.Y, bounds.Max.X, bounds.Max.Y/2)
		c3 := cut(original, &db, tileSize, bounds.Min.X, bounds.Max.Y/2, bounds.Max.X/2, bounds.Max.Y)
		c4 := cut(original, &db, tileSize, bounds.Max.X/2, bounds.Max.Y/2, bounds.Max.X, bounds.Max.Y)

		// fan-in
		c := combine(bounds, c1, c2, c3, c4)

		buf1 := new(bytes.Buffer)
		jpeg.Encode(buf1, original, nil)
		originalStr := base64.StdEncoding.EncodeToString(buf1.Bytes())

		t1 := time.Now()
		images := map[string]string{
			"original": originalStr,
			"mosaic":   <-c,
			"duration": fmt.Sprintf("%v ", t1.Sub(t0)),
		}

		t, _ := template.ParseFiles("results.html")
		t.Execute(w, images)
	}


snippet Deploying_Go_mosaic_heroku_mosaic
	package main

	import (
		"fmt"
		"image"
		"image/color"
		"io/ioutil"
		"math"
		"os"
	)

	// resize an image by its ratio e.g. ratio 2 means reduce the size by 1/2, 10 means reduce the size by 1/10
	func resize(in image.Image, newWidth int) image.NRGBA {
		bounds := in.Bounds()
		width := bounds.Max.X - bounds.Min.X
		ratio := width / newWidth
		out := image.NewNRGBA(image.Rect(bounds.Min.X/ratio, bounds.Min.X/ratio, bounds.Max.X/ratio, bounds.Max.Y/ratio))
		for y, j := bounds.Min.Y, bounds.Min.Y; y < bounds.Max.Y; y, j = y+ratio, j+1 {
			for x, i := bounds.Min.X, bounds.Min.X; x < bounds.Max.X; x, i = x+ratio, i+1 {
				r, g, b, a := in.At(x, y).RGBA()
				out.SetNRGBA(i, j, color.NRGBA{uint8(r), uint8(g), uint8(b), uint8(a)})
			}
		}
		return *out
	}

	// find the average color of the picture
	func averageColor(img image.Image) [3]float64 {
		bounds := img.Bounds()
		r, g, b := 0.0, 0.0, 0.0
		for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
			for x := bounds.Min.X; x < bounds.Max.X; x++ {
				r1, g1, b1, _ := img.At(x, y).RGBA()
				r, g, b = r+float64(r1), g+float64(g1), b+float64(b1)
			}
		}
		totalPixels := float64(bounds.Max.X * bounds.Max.Y)
		return [3]float64{r / totalPixels, g / totalPixels, b / totalPixels}
	}

	var TILESDB map[string][3]float64

	func cloneTilesDB() map[string][3]float64 {
		db := make(map[string][3]float64)
		for k, v := range TILESDB {
			db[k] = v
		}
		return db
	}

	// populate a tiles database in memory
	func tilesDB() {
		fmt.Println("Start populating tiles db ...")
		files, _ := ioutil.ReadDir("tiles")
		for _, f := range files {
			name := "tiles/" + f.Name()
			file, err := os.Open(name)
			if err == nil {
				img, _, err := image.Decode(file)
				if err == nil {
					TILESDB[name] = averageColor(img)
				} else {
					fmt.Println("error in populating tiles db:", err, name)
				}
			} else {
				fmt.Println("cannot open file", name, "when populating tiles db:", err)
			}
			file.Close()
		}
		fmt.Println("Finished populating tiles db.")
	}

	// find the nearest matching image
	func nearest(target [3]float64, db *map[string][3]float64) string {
		var filename string
		smallest := 1000000.0
		for k, v := range *db {
			dist := distance(target, v)
			if dist < smallest {
				filename, smallest = k, dist
			}
		}
		delete(*db, filename)
		return filename
	}

	// find the Eucleadian distance between 2 points
	func distance(p1 [3]float64, p2 [3]float64) float64 {
		return math.Sqrt(sq(p2[0]-p1[0]) + sq(p2[1]-p1[1]) + sq(p2[2]-p1[2]))
	}

	// find the square
	func sq(n float64) float64 {
		return n * n
	}


snippet Deploying_Go_mosaic_standalone_main
	package main

	import (
		"bytes"
		"encoding/base64"
		"fmt"
		"html/template"
		"image"
		"image/draw"
		"image/jpeg"
		"net/http"
		"os"
		"runtime"
		"strconv"
		"sync"
		"time"
	)

	func main() {
		fmt.Println("Number of CPUs:", runtime.NumCPU())
		runtime.GOMAXPROCS(runtime.NumCPU())
		fmt.Println("Starting mosaic server ...")
		mux := http.NewServeMux()
		files := http.FileServer(http.Dir("public"))
		mux.Handle("/static/", http.StripPrefix("/static/", files))

		mux.HandleFunc("/", upload)
		mux.HandleFunc("/mosaic", mosaic)

		server := &http.Server{
			Addr:    ":" + os.Getenv("PORT"),
			Handler: mux,
		}
		TILESDB = make(map[string][3]float64)
		go tilesDB()
		fmt.Println("Mosaic server started.")
		server.ListenAndServe()

	}

	func upload(w http.ResponseWriter, r *http.Request) {
		t, _ := template.ParseFiles("upload.html")
		t.Execute(w, nil)
	}

	// cut out the image and return individual channels with image.Image
	// no encoding of JPEG
	func cut(original image.Image, db *map[string][3]float64, tileSize, x1, y1, x2, y2 int) <-chan image.Image {
		c := make(chan image.Image)
		sp := image.Point{0, 0}
		go func() {
			newimage := image.NewNRGBA(image.Rect(x1, y1, x2, y2))
			for y := y1; y < y2; y = y + tileSize {
				for x := x1; x < x2; x = x + tileSize {
					r, g, b, _ := original.At(x, y).RGBA()
					color := [3]float64{float64(r), float64(g), float64(b)}
					nearest := nearest(color, db)
					file, err := os.Open(nearest)
					if err == nil {
						img, _, err := image.Decode(file)
						if err == nil {
							t := resize(img, tileSize)
							tile := t.SubImage(t.Bounds())
							tileBounds := image.Rect(x, y, x+tileSize, y+tileSize)
							draw.Draw(newimage, tileBounds, tile, sp, draw.Src)
						} else {
							fmt.Println("error in decoding nearest", err, nearest)
						}
					} else {
						fmt.Println("error opening file when creating mosaic:", nearest)
					}
					file.Close()
				}
			}
			c <- newimage.SubImage(newimage.Rect)
		}()

		return c
	}

	// combine the images and return the encoding string
	func combine(r image.Rectangle, c1, c2, c3, c4 <-chan image.Image) <-chan string {
		c := make(chan string)
		// start a goroutine
		go func() {
			var wg sync.WaitGroup
			newimage := image.NewNRGBA(r)
			copy := func(dst draw.Image, r image.Rectangle, src image.Image, sp image.Point) {
				draw.Draw(dst, r, src, sp, draw.Src)
				wg.Done()
			}
			wg.Add(4)
			var s1, s2, s3, s4 image.Image
			var ok1, ok2, ok3, ok4 bool
			for {
				select {
				case s1, ok1 = <-c1:
					go copy(newimage, s1.Bounds(), s1, image.Point{r.Min.X, r.Min.Y})
				case s2, ok2 = <-c2:
					go copy(newimage, s2.Bounds(), s2, image.Point{r.Max.X / 2, r.Min.Y})
				case s3, ok3 = <-c3:
					go copy(newimage, s3.Bounds(), s3, image.Point{r.Min.X, r.Max.Y / 2})
				case s4, ok4 = <-c4:
					go copy(newimage, s4.Bounds(), s4, image.Point{r.Max.X / 2, r.Max.Y / 2})
				}
				if ok1 && ok2 && ok3 && ok4 {
					break
				}
			}
			// wait till all copy goroutines are complete
			wg.Wait()
			buf2 := new(bytes.Buffer)
			jpeg.Encode(buf2, newimage, nil)
			c <- base64.StdEncoding.EncodeToString(buf2.Bytes())
		}()
		return c
	}

	//  Handler function for fan-out and fan-in
	func mosaic(w http.ResponseWriter, r *http.Request) {
		t0 := time.Now()
		// get the content from the POSTed form
		r.ParseMultipartForm(10485760) // max body in memory is 10MB
		file, _, _ := r.FormFile("image")
		defer file.Close()
		tileSize, _ := strconv.Atoi(r.FormValue("tile_size"))
		//
		//   // decode and get original image
		original, _, _ := image.Decode(file)
		bounds := original.Bounds()
		db := cloneTilesDB()

		// fan-out
		c1 := cut(original, &db, tileSize, bounds.Min.X, bounds.Min.Y, bounds.Max.X/2, bounds.Max.Y/2)
		c2 := cut(original, &db, tileSize, bounds.Max.X/2, bounds.Min.Y, bounds.Max.X, bounds.Max.Y/2)
		c3 := cut(original, &db, tileSize, bounds.Min.X, bounds.Max.Y/2, bounds.Max.X/2, bounds.Max.Y)
		c4 := cut(original, &db, tileSize, bounds.Max.X/2, bounds.Max.Y/2, bounds.Max.X, bounds.Max.Y)

		// fan-in
		c := combine(bounds, c1, c2, c3, c4)

		buf1 := new(bytes.Buffer)
		jpeg.Encode(buf1, original, nil)
		originalStr := base64.StdEncoding.EncodeToString(buf1.Bytes())

		t1 := time.Now()
		images := map[string]string{
			"original": originalStr,
			"mosaic":   <-c,
			"duration": fmt.Sprintf("%v ", t1.Sub(t0)),
		}

		t, _ := template.ParseFiles("results.html")
		t.Execute(w, images)
	}


snippet Deploying_Go_mosaic_standalone_mosaic
	package main

	import (
		"fmt"
		"image"
		"image/color"
		"io/ioutil"
		"math"
		"os"
	)

	// resize an image by its ratio e.g. ratio 2 means reduce the size by 1/2, 10 means reduce the size by 1/10
	func resize(in image.Image, newWidth int) image.NRGBA {
		bounds := in.Bounds()
		width := bounds.Max.X - bounds.Min.X
		ratio := width / newWidth
		out := image.NewNRGBA(image.Rect(bounds.Min.X/ratio, bounds.Min.X/ratio, bounds.Max.X/ratio, bounds.Max.Y/ratio))
		for y, j := bounds.Min.Y, bounds.Min.Y; y < bounds.Max.Y; y, j = y+ratio, j+1 {
			for x, i := bounds.Min.X, bounds.Min.X; x < bounds.Max.X; x, i = x+ratio, i+1 {
				r, g, b, a := in.At(x, y).RGBA()
				out.SetNRGBA(i, j, color.NRGBA{uint8(r), uint8(g), uint8(b), uint8(a)})
			}
		}
		return *out
	}

	// find the average color of the picture
	func averageColor(img image.Image) [3]float64 {
		bounds := img.Bounds()
		r, g, b := 0.0, 0.0, 0.0
		for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
			for x := bounds.Min.X; x < bounds.Max.X; x++ {
				r1, g1, b1, _ := img.At(x, y).RGBA()
				r, g, b = r+float64(r1), g+float64(g1), b+float64(b1)
			}
		}
		totalPixels := float64(bounds.Max.X * bounds.Max.Y)
		return [3]float64{r / totalPixels, g / totalPixels, b / totalPixels}
	}

	var TILESDB map[string][3]float64

	func cloneTilesDB() map[string][3]float64 {
		db := make(map[string][3]float64)
		for k, v := range TILESDB {
			db[k] = v
		}
		return db
	}

	// populate a tiles database in memory
	func tilesDB() {
		fmt.Println("Start populating tiles db ...")
		files, _ := ioutil.ReadDir("tiles")
		for _, f := range files {
			name := "tiles/" + f.Name()
			file, err := os.Open(name)
			if err == nil {
				img, _, err := image.Decode(file)
				if err == nil {
					TILESDB[name] = averageColor(img)
				} else {
					fmt.Println("error in populating tiles db:", err, name)
				}
			} else {
				fmt.Println("cannot open file", name, "when populating tiles db:", err)
			}
			file.Close()
		}
		fmt.Println("Finished populating tiles db.")
	}

	// find the nearest matching image
	func nearest(target [3]float64, db *map[string][3]float64) string {
		var filename string
		smallest := 1000000.0
		for k, v := range *db {
			dist := distance(target, v)
			if dist < smallest {
				filename, smallest = k, dist
			}
		}
		delete(*db, filename)
		return filename
	}

	// find the Eucleadian distance between 2 points
	func distance(p1 [3]float64, p2 [3]float64) float64 {
		return math.Sqrt(sq(p2[0]-p1[0]) + sq(p2[1]-p1[1]) + sq(p2[2]-p1[2]))
	}

	// find the square
	func sq(n float64) float64 {
		return n * n
	}


snippet Deploying_Go_ws_d_data
	package main

	import (
		"database/sql"
		_ "github.com/lib/pq"
	)

	var Db *sql.DB

	// connect to the Db
	func init() {
		var err error
		Db, err = sql.Open("postgres", "host=babar.elephantsql.com user=qjnqlnxs dbname=qjnqlnxs password=VSIjUweR1jWi3lf33R9EmlYVppgFJrwu sslmode=disable")
		if err != nil {
			panic(err)
		}
	}

	// Get a single post
	func retrievePost(id int) (post Post, err error) {
		post = Post{}
		err = Db.QueryRow("select id, content, author from posts where id = $1", id).Scan(&post.Id, &post.Content, &post.Author)
		return
	}

	// Create a new post
	func (post *Post) create() (err error) {
		statement := "insert into posts (content, author) values ($1, $2) returning id"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		err = stmt.QueryRow(post.Content, post.Author).Scan(&post.Id)
		return
	}

	// Update a post
	func (post *Post) update() (err error) {
		_, err = Db.Exec("update posts set content = $2, author = $3 where id = $1", post.Id, post.Content, post.Author)
		return
	}

	// Delete a post
	func (post *Post) delete() (err error) {
		_, err = Db.Exec("delete from posts where id = $1", post.Id)
		return
	}


snippet Deploying_Go_ws_d_server
	package main

	import (
		"encoding/json"
		"net/http"
		"path"
		"strconv"
	)

	type Post struct {
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	func main() {
		server := http.Server{
			Addr: ":8080",
		}
		http.HandleFunc("/post/", handlePost)
		server.ListenAndServe()
	}

	// main handler function
	func handlePost(w http.ResponseWriter, r *http.Request) {
		var err error
		switch r.Method {
		case "GET":
			err = getPost(w, r)
		case "POST":
			err = postPost(w, r)
		case "PUT":
			err = putPost(w, r)
		case "DELETE":
			err = deletePost(w, r)
		}
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	// Retrieve a post
	// GET /post/1
	func getPost(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrievePost(id)
		if err != nil {
			return
		}
		output, err := json.MarshalIndent(&post, "", "\t\t")
		if err != nil {
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Write(output)
		return
	}

	// Create a post
	// POST /post/
	func postPost(w http.ResponseWriter, r *http.Request) (err error) {
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		var post Post
		json.Unmarshal(body, &post)
		err = post.create()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Update a post
	// PUT /post/1
	func putPost(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrievePost(id)
		if err != nil {
			return
		}
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, &post)
		err = post.update()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Delete a post
	// DELETE /post/1
	func deletePost(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrievePost(id)
		if err != nil {
			return
		}
		err = post.delete()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}


snippet Deploying_Go_ws_g_data
	package gwp

	import (
		"database/sql"
		_ "github.com/ziutek/mymysql/godrv"
	)

	var Db *sql.DB

	// connect to the Db
	func init() {
		var err error
		Db, err = sql.Open("mymysql", "cloudsql:ws-g-1234:gwp*gwp/root/root123")
		if err != nil {
			panic(err)
		}
	}

	// Get a single post
	func retrievePost(id int) (post Post, err error) {
		post = Post{}
		err = Db.QueryRow("select id, content, author from posts where id = ?", id).Scan(&post.Id, &post.Content, &post.Author)
		return
	}

	// Create a new post
	func (post *Post) create() (err error) {
		statement := "insert into posts (content, author) values (?, ?)"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		stmt.QueryRow(post.Content, post.Author)
		return
	}

	// Update a post
	func (post *Post) update() (err error) {
		_, err = Db.Exec("update posts set content = ?, author = ? where id = ?", post.Content, post.Author, post.Id)
		return
	}

	// Delete a post
	func (post *Post) delete() (err error) {
		_, err = Db.Exec("delete from posts where id = ?", post.Id)
		return
	}


snippet Deploying_Go_ws_g_server
	package gwp

	import (
		"encoding/json"
		"net/http"
		"path"
		"strconv"
	)

	type Post struct {
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	func init() {
		http.HandleFunc("/post/", handlePost)
	}

	// main handler function
	func handlePost(w http.ResponseWriter, r *http.Request) {
		var err error
		switch r.Method {
		case "GET":
			err = getPost(w, r)
		case "POST":
			err = postPost(w, r)
		case "PUT":
			err = putPost(w, r)
		case "DELETE":
			err = deletePost(w, r)
		}
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	// Retrieve a post
	// GET /post/1
	func getPost(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrievePost(id)
		if err != nil {
			return
		}
		output, err := json.MarshalIndent(&post, "", "\t\t")
		if err != nil {
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Write(output)
		return
	}

	// Create a post
	// POST /post/
	func postPost(w http.ResponseWriter, r *http.Request) (err error) {
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		var post Post
		json.Unmarshal(body, &post)
		err = post.create()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Update a post
	// PUT /post/1
	func putPost(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrievePost(id)
		if err != nil {
			return
		}
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, &post)
		err = post.update()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Delete a post
	// DELETE /post/1
	func deletePost(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrievePost(id)
		if err != nil {
			return
		}
		err = post.delete()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}


snippet Deploying_Go_ws_h_data
	package main

	import (
		"database/sql"
		_ "github.com/lib/pq"
	)

	var Db *sql.DB

	// connect to the Db
	func init() {
		var err error
		Db, err = sql.Open("postgres", "host=babar.elephantsql.com user=qjnqlnxs dbname=qjnqlnxs password=VSIjUweR1jWi3lf33R9EmlYVppgFJrwu sslmode=disable")
		if err != nil {
			panic(err)
		}
	}

	// Get a single post
	func retrievePost(id int) (post Post, err error) {
		post = Post{}
		err = Db.QueryRow("select id, content, author from posts where id = $1", id).Scan(&post.Id, &post.Content, &post.Author)
		return
	}

	// Create a new post
	func (post *Post) create() (err error) {
		statement := "insert into posts (content, author) values ($1, $2) returning id"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		err = stmt.QueryRow(post.Content, post.Author).Scan(&post.Id)
		return
	}

	// Update a post
	func (post *Post) update() (err error) {
		_, err = Db.Exec("update posts set content = $2, author = $3 where id = $1", post.Id, post.Content, post.Author)
		return
	}

	// Delete a post
	func (post *Post) delete() (err error) {
		_, err = Db.Exec("delete from posts where id = $1", post.Id)
		return
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_bench_test
	// +build go1.1

	package pq

	import (
		"bufio"
		"bytes"
		"database/sql"
		"database/sql/driver"
		"io"
		"math/rand"
		"net"
		"runtime"
		"strconv"
		"strings"
		"sync"
		"testing"
		"time"

		"github.com/lib/pq/oid"
	)

	var (
		selectStringQuery = "SELECT '" + strings.Repeat("0123456789", 10) + "'"
		selectSeriesQuery = "SELECT generate_series(1, 100)"
	)

	func BenchmarkSelectString(b *testing.B) {
		var result string
		benchQuery(b, selectStringQuery, &result)
	}

	func BenchmarkSelectSeries(b *testing.B) {
		var result int
		benchQuery(b, selectSeriesQuery, &result)
	}

	func benchQuery(b *testing.B, query string, result interface{}) {
		b.StopTimer()
		db := openTestConn(b)
		defer db.Close()
		b.StartTimer()

		for i := 0; i < b.N; i++ {
			benchQueryLoop(b, db, query, result)
		}
	}

	func benchQueryLoop(b *testing.B, db *sql.DB, query string, result interface{}) {
		rows, err := db.Query(query)
		if err != nil {
			b.Fatal(err)
		}
		defer rows.Close()
		for rows.Next() {
			err = rows.Scan(result)
			if err != nil {
				b.Fatal("failed to scan", err)
			}
		}
	}

	// reading from circularConn yields content[:prefixLen] once, followed by
	// content[prefixLen:] over and over again. It never returns EOF.
	type circularConn struct {
		content   string
		prefixLen int
		pos       int
		net.Conn  // for all other net.Conn methods that will never be called
	}

	func (r *circularConn) Read(b []byte) (n int, err error) {
		n = copy(b, r.content[r.pos:])
		r.pos += n
		if r.pos >= len(r.content) {
			r.pos = r.prefixLen
		}
		return
	}

	func (r *circularConn) Write(b []byte) (n int, err error) { return len(b), nil }

	func (r *circularConn) Close() error { return nil }

	func fakeConn(content string, prefixLen int) *conn {
		c := &circularConn{content: content, prefixLen: prefixLen}
		return &conn{buf: bufio.NewReader(c), c: c}
	}

	// This benchmark is meant to be the same as BenchmarkSelectString, but takes
	// out some of the factors this package can't control. The numbers are less noisy,
	// but also the costs of network communication aren't accurately represented.
	func BenchmarkMockSelectString(b *testing.B) {
		b.StopTimer()
		// taken from a recorded run of BenchmarkSelectString
		// See: http://www.postgresql.org/docs/current/static/protocol-message-formats.html
		const response = "1\x00\x00\x00\x04" +
			"t\x00\x00\x00\x06\x00\x00" +
			"T\x00\x00\x00!\x00\x01?column?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\xc1\xff\xfe\xff\xff\xff\xff\x00\x00" +
			"Z\x00\x00\x00\x05I" +
			"2\x00\x00\x00\x04" +
			"D\x00\x00\x00n\x00\x01\x00\x00\x00d0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
			"C\x00\x00\x00\rSELECT 1\x00" +
			"Z\x00\x00\x00\x05I" +
			"3\x00\x00\x00\x04" +
			"Z\x00\x00\x00\x05I"
		c := fakeConn(response, 0)
		b.StartTimer()

		for i := 0; i < b.N; i++ {
			benchMockQuery(b, c, selectStringQuery)
		}
	}

	var seriesRowData = func() string {
		var buf bytes.Buffer
		for i := 1; i <= 100; i++ {
			digits := byte(2)
			if i >= 100 {
				digits = 3
			} else if i < 10 {
				digits = 1
			}
			buf.WriteString("D\x00\x00\x00")
			buf.WriteByte(10 + digits)
			buf.WriteString("\x00\x01\x00\x00\x00")
			buf.WriteByte(digits)
			buf.WriteString(strconv.Itoa(i))
		}
		return buf.String()
	}()

	func BenchmarkMockSelectSeries(b *testing.B) {
		b.StopTimer()
		var response = "1\x00\x00\x00\x04" +
			"t\x00\x00\x00\x06\x00\x00" +
			"T\x00\x00\x00!\x00\x01?column?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\xc1\xff\xfe\xff\xff\xff\xff\x00\x00" +
			"Z\x00\x00\x00\x05I" +
			"2\x00\x00\x00\x04" +
			seriesRowData +
			"C\x00\x00\x00\x0fSELECT 100\x00" +
			"Z\x00\x00\x00\x05I" +
			"3\x00\x00\x00\x04" +
			"Z\x00\x00\x00\x05I"
		c := fakeConn(response, 0)
		b.StartTimer()

		for i := 0; i < b.N; i++ {
			benchMockQuery(b, c, selectSeriesQuery)
		}
	}

	func benchMockQuery(b *testing.B, c *conn, query string) {
		stmt, err := c.Prepare(query)
		if err != nil {
			b.Fatal(err)
		}
		defer stmt.Close()
		rows, err := stmt.Query(nil)
		if err != nil {
			b.Fatal(err)
		}
		defer rows.Close()
		var dest [1]driver.Value
		for {
			if err := rows.Next(dest[:]); err != nil {
				if err == io.EOF {
					break
				}
				b.Fatal(err)
			}
		}
	}

	func BenchmarkPreparedSelectString(b *testing.B) {
		var result string
		benchPreparedQuery(b, selectStringQuery, &result)
	}

	func BenchmarkPreparedSelectSeries(b *testing.B) {
		var result int
		benchPreparedQuery(b, selectSeriesQuery, &result)
	}

	func benchPreparedQuery(b *testing.B, query string, result interface{}) {
		b.StopTimer()
		db := openTestConn(b)
		defer db.Close()
		stmt, err := db.Prepare(query)
		if err != nil {
			b.Fatal(err)
		}
		defer stmt.Close()
		b.StartTimer()

		for i := 0; i < b.N; i++ {
			benchPreparedQueryLoop(b, db, stmt, result)
		}
	}

	func benchPreparedQueryLoop(b *testing.B, db *sql.DB, stmt *sql.Stmt, result interface{}) {
		rows, err := stmt.Query()
		if err != nil {
			b.Fatal(err)
		}
		if !rows.Next() {
			rows.Close()
			b.Fatal("no rows")
		}
		defer rows.Close()
		for rows.Next() {
			err = rows.Scan(&result)
			if err != nil {
				b.Fatal("failed to scan")
			}
		}
	}

	// See the comment for BenchmarkMockSelectString.
	func BenchmarkMockPreparedSelectString(b *testing.B) {
		b.StopTimer()
		const parseResponse = "1\x00\x00\x00\x04" +
			"t\x00\x00\x00\x06\x00\x00" +
			"T\x00\x00\x00!\x00\x01?column?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\xc1\xff\xfe\xff\xff\xff\xff\x00\x00" +
			"Z\x00\x00\x00\x05I"
		const responses = parseResponse +
			"2\x00\x00\x00\x04" +
			"D\x00\x00\x00n\x00\x01\x00\x00\x00d0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +
			"C\x00\x00\x00\rSELECT 1\x00" +
			"Z\x00\x00\x00\x05I"
		c := fakeConn(responses, len(parseResponse))

		stmt, err := c.Prepare(selectStringQuery)
		if err != nil {
			b.Fatal(err)
		}
		b.StartTimer()

		for i := 0; i < b.N; i++ {
			benchPreparedMockQuery(b, c, stmt)
		}
	}

	func BenchmarkMockPreparedSelectSeries(b *testing.B) {
		b.StopTimer()
		const parseResponse = "1\x00\x00\x00\x04" +
			"t\x00\x00\x00\x06\x00\x00" +
			"T\x00\x00\x00!\x00\x01?column?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\xc1\xff\xfe\xff\xff\xff\xff\x00\x00" +
			"Z\x00\x00\x00\x05I"
		var responses = parseResponse +
			"2\x00\x00\x00\x04" +
			seriesRowData +
			"C\x00\x00\x00\x0fSELECT 100\x00" +
			"Z\x00\x00\x00\x05I"
		c := fakeConn(responses, len(parseResponse))

		stmt, err := c.Prepare(selectSeriesQuery)
		if err != nil {
			b.Fatal(err)
		}
		b.StartTimer()

		for i := 0; i < b.N; i++ {
			benchPreparedMockQuery(b, c, stmt)
		}
	}

	func benchPreparedMockQuery(b *testing.B, c *conn, stmt driver.Stmt) {
		rows, err := stmt.Query(nil)
		if err != nil {
			b.Fatal(err)
		}
		defer rows.Close()
		var dest [1]driver.Value
		for {
			if err := rows.Next(dest[:]); err != nil {
				if err == io.EOF {
					break
				}
				b.Fatal(err)
			}
		}
	}

	func BenchmarkEncodeInt64(b *testing.B) {
		for i := 0; i < b.N; i++ {
			encode(&parameterStatus{}, int64(1234), oid.T_int8)
		}
	}

	func BenchmarkEncodeFloat64(b *testing.B) {
		for i := 0; i < b.N; i++ {
			encode(&parameterStatus{}, 3.14159, oid.T_float8)
		}
	}

	var testByteString = []byte("abcdefghijklmnopqrstuvwxyz")

	func BenchmarkEncodeByteaHex(b *testing.B) {
		for i := 0; i < b.N; i++ {
			encode(&parameterStatus{serverVersion: 90000}, testByteString, oid.T_bytea)
		}
	}
	func BenchmarkEncodeByteaEscape(b *testing.B) {
		for i := 0; i < b.N; i++ {
			encode(&parameterStatus{serverVersion: 84000}, testByteString, oid.T_bytea)
		}
	}

	func BenchmarkEncodeBool(b *testing.B) {
		for i := 0; i < b.N; i++ {
			encode(&parameterStatus{}, true, oid.T_bool)
		}
	}

	var testTimestamptz = time.Date(2001, time.January, 1, 0, 0, 0, 0, time.Local)

	func BenchmarkEncodeTimestamptz(b *testing.B) {
		for i := 0; i < b.N; i++ {
			encode(&parameterStatus{}, testTimestamptz, oid.T_timestamptz)
		}
	}

	var testIntBytes = []byte("1234")

	func BenchmarkDecodeInt64(b *testing.B) {
		for i := 0; i < b.N; i++ {
			decode(&parameterStatus{}, testIntBytes, oid.T_int8)
		}
	}

	var testFloatBytes = []byte("3.14159")

	func BenchmarkDecodeFloat64(b *testing.B) {
		for i := 0; i < b.N; i++ {
			decode(&parameterStatus{}, testFloatBytes, oid.T_float8)
		}
	}

	var testBoolBytes = []byte{'t'}

	func BenchmarkDecodeBool(b *testing.B) {
		for i := 0; i < b.N; i++ {
			decode(&parameterStatus{}, testBoolBytes, oid.T_bool)
		}
	}

	func TestDecodeBool(t *testing.T) {
		db := openTestConn(t)
		rows, err := db.Query("select true")
		if err != nil {
			t.Fatal(err)
		}
		rows.Close()
	}

	var testTimestamptzBytes = []byte("2013-09-17 22:15:32.360754-07")

	func BenchmarkDecodeTimestamptz(b *testing.B) {
		for i := 0; i < b.N; i++ {
			decode(&parameterStatus{}, testTimestamptzBytes, oid.T_timestamptz)
		}
	}

	func BenchmarkDecodeTimestamptzMultiThread(b *testing.B) {
		oldProcs := runtime.GOMAXPROCS(0)
		defer runtime.GOMAXPROCS(oldProcs)
		runtime.GOMAXPROCS(runtime.NumCPU())
		globalLocationCache = newLocationCache()

		f := func(wg *sync.WaitGroup, loops int) {
			defer wg.Done()
			for i := 0; i < loops; i++ {
				decode(&parameterStatus{}, testTimestamptzBytes, oid.T_timestamptz)
			}
		}

		wg := &sync.WaitGroup{}
		b.ResetTimer()
		for j := 0; j < 10; j++ {
			wg.Add(1)
			go f(wg, b.N/10)
		}
		wg.Wait()
	}

	func BenchmarkLocationCache(b *testing.B) {
		globalLocationCache = newLocationCache()
		for i := 0; i < b.N; i++ {
			globalLocationCache.getLocation(rand.Intn(10000))
		}
	}

	func BenchmarkLocationCacheMultiThread(b *testing.B) {
		oldProcs := runtime.GOMAXPROCS(0)
		defer runtime.GOMAXPROCS(oldProcs)
		runtime.GOMAXPROCS(runtime.NumCPU())
		globalLocationCache = newLocationCache()

		f := func(wg *sync.WaitGroup, loops int) {
			defer wg.Done()
			for i := 0; i < loops; i++ {
				globalLocationCache.getLocation(rand.Intn(10000))
			}
		}

		wg := &sync.WaitGroup{}
		b.ResetTimer()
		for j := 0; j < 10; j++ {
			wg.Add(1)
			go f(wg, b.N/10)
		}
		wg.Wait()
	}

	// Stress test the performance of parsing results from the wire.
	func BenchmarkResultParsing(b *testing.B) {
		b.StopTimer()

		db := openTestConn(b)
		defer db.Close()
		_, err := db.Exec("BEGIN")
		if err != nil {
			b.Fatal(err)
		}

		b.StartTimer()
		for i := 0; i < b.N; i++ {
			res, err := db.Query("SELECT generate_series(1, 50000)")
			if err != nil {
				b.Fatal(err)
			}
			res.Close()
		}
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_buf
	package pq

	import (
		"bytes"
		"encoding/binary"

		"github.com/lib/pq/oid"
	)

	type readBuf []byte

	func (b *readBuf) int32() (n int) {
		n = int(int32(binary.BigEndian.Uint32(*b)))
		*b = (*b)[4:]
		return
	}

	func (b *readBuf) oid() (n oid.Oid) {
		n = oid.Oid(binary.BigEndian.Uint32(*b))
		*b = (*b)[4:]
		return
	}

	func (b *readBuf) int16() (n int) {
		n = int(binary.BigEndian.Uint16(*b))
		*b = (*b)[2:]
		return
	}

	func (b *readBuf) string() string {
		i := bytes.IndexByte(*b, 0)
		if i < 0 {
			errorf("invalid message format; expected string terminator")
		}
		s := (*b)[:i]
		*b = (*b)[i+1:]
		return string(s)
	}

	func (b *readBuf) next(n int) (v []byte) {
		v = (*b)[:n]
		*b = (*b)[n:]
		return
	}

	func (b *readBuf) byte() byte {
		return b.next(1)[0]
	}

	type writeBuf []byte

	func (b *writeBuf) int32(n int) {
		x := make([]byte, 4)
		binary.BigEndian.PutUint32(x, uint32(n))
		*b = append(*b, x...)
	}

	func (b *writeBuf) int16(n int) {
		x := make([]byte, 2)
		binary.BigEndian.PutUint16(x, uint16(n))
		*b = append(*b, x...)
	}

	func (b *writeBuf) string(s string) {
		*b = append(*b, (s + "\000")...)
	}

	func (b *writeBuf) byte(c byte) {
		*b = append(*b, c)
	}

	func (b *writeBuf) bytes(v []byte) {
		*b = append(*b, v...)
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_conn
	package pq

	import (
		"bufio"
		"crypto/md5"
		"crypto/tls"
		"crypto/x509"
		"database/sql"
		"database/sql/driver"
		"encoding/binary"
		"errors"
		"fmt"
		"io"
		"io/ioutil"
		"net"
		"os"
		"os/user"
		"path"
		"path/filepath"
		"strconv"
		"strings"
		"time"
		"unicode"

		"github.com/lib/pq/oid"
	)

	// Common error types
	var (
		ErrNotSupported              = errors.New("pq: Unsupported command")
		ErrInFailedTransaction       = errors.New("pq: Could not complete operation in a failed transaction")
		ErrSSLNotSupported           = errors.New("pq: SSL is not enabled on the server")
		ErrSSLKeyHasWorldPermissions = errors.New("pq: Private key file has group or world access. Permissions should be u=rw (0600) or less.")
		ErrCouldNotDetectUsername    = errors.New("pq: Could not detect default username. Please provide one explicitly.")
	)

	type drv struct{}

	func (d *drv) Open(name string) (driver.Conn, error) {
		return Open(name)
	}

	func init() {
		sql.Register("postgres", &drv{})
	}

	type parameterStatus struct {
		// server version in the same format as server_version_num, or 0 if
		// unavailable
		serverVersion int

		// the current location based on the TimeZone value of the session, if
		// available
		currentLocation *time.Location
	}

	type transactionStatus byte

	const (
		txnStatusIdle                transactionStatus = 'I'
		txnStatusIdleInTransaction   transactionStatus = 'T'
		txnStatusInFailedTransaction transactionStatus = 'E'
	)

	func (s transactionStatus) String() string {
		switch s {
		case txnStatusIdle:
			return "idle"
		case txnStatusIdleInTransaction:
			return "idle in transaction"
		case txnStatusInFailedTransaction:
			return "in a failed transaction"
		default:
			errorf("unknown transactionStatus %d", s)
		}

		panic("not reached")
	}

	type Dialer interface {
		Dial(network, address string) (net.Conn, error)
		DialTimeout(network, address string, timeout time.Duration) (net.Conn, error)
	}

	type defaultDialer struct{}

	func (d defaultDialer) Dial(ntw, addr string) (net.Conn, error) {
		return net.Dial(ntw, addr)
	}
	func (d defaultDialer) DialTimeout(ntw, addr string, timeout time.Duration) (net.Conn, error) {
		return net.DialTimeout(ntw, addr, timeout)
	}

	type conn struct {
		c         net.Conn
		buf       *bufio.Reader
		namei     int
		scratch   [512]byte
		txnStatus transactionStatus

		parameterStatus parameterStatus

		saveMessageType   byte
		saveMessageBuffer []byte

		// If true, this connection is bad and all public-facing functions should
		// return ErrBadConn.
		bad bool
	}

	func (c *conn) writeBuf(b byte) *writeBuf {
		c.scratch[0] = b
		w := writeBuf(c.scratch[:5])
		return &w
	}

	func Open(name string) (_ driver.Conn, err error) {
		return DialOpen(defaultDialer{}, name)
	}

	func DialOpen(d Dialer, name string) (_ driver.Conn, err error) {
		defer func() {
			// Handle any panics during connection initialization.  Note that we
			// specifically do *not* want to use errRecover(), as that would turn
			// any connection errors into ErrBadConns, hiding the real error
			// message from the user.
			e := recover()
			if e == nil {
				// Do nothing
				return
			}
			var ok bool
			err, ok = e.(error)
			if !ok {
				err = fmt.Errorf("pq: unexpected error: %#v", e)
			}
		}()

		o := make(values)

		// A number of defaults are applied here, in this order:
		//
		// * Very low precedence defaults applied in every situation
		// * Environment variables
		// * Explicitly passed connection information
		o.Set("host", "localhost")
		o.Set("port", "5432")
		// N.B.: Extra float digits should be set to 3, but that breaks
		// Postgres 8.4 and older, where the max is 2.
		o.Set("extra_float_digits", "2")
		for k, v := range parseEnviron(os.Environ()) {
			o.Set(k, v)
		}

		if strings.HasPrefix(name, "postgres://") {
			name, err = ParseURL(name)
			if err != nil {
				return nil, err
			}
		}

		if err := parseOpts(name, o); err != nil {
			return nil, err
		}

		// Use the "fallback" application name if necessary
		if fallback := o.Get("fallback_application_name"); fallback != "" {
			if !o.Isset("application_name") {
				o.Set("application_name", fallback)
			}
		}

		// We can't work with any client_encoding other than UTF-8 currently.
		// However, we have historically allowed the user to set it to UTF-8
		// explicitly, and there's no reason to break such programs, so allow that.
		// Note that the "options" setting could also set client_encoding, but
		// parsing its value is not worth it.  Instead, we always explicitly send
		// client_encoding as a separate run-time parameter, which should override
		// anything set in options.
		if enc := o.Get("client_encoding"); enc != "" && !isUTF8(enc) {
			return nil, errors.New("client_encoding must be absent or 'UTF8'")
		}
		o.Set("client_encoding", "UTF8")
		// DateStyle needs a similar treatment.
		if datestyle := o.Get("datestyle"); datestyle != "" {
			if datestyle != "ISO, MDY" {
				panic(fmt.Sprintf("setting datestyle must be absent or %v; got %v",
					"ISO, MDY", datestyle))
			}
		} else {
			o.Set("datestyle", "ISO, MDY")
		}

		// If a user is not provided by any other means, the last
		// resort is to use the current operating system provided user
		// name.
		if o.Get("user") == "" {
			u, err := userCurrent()
			if err != nil {
				return nil, err
			} else {
				o.Set("user", u)
			}
		}

		c, err := dial(d, o)
		if err != nil {
			return nil, err
		}

		cn := &conn{c: c}
		cn.ssl(o)
		cn.buf = bufio.NewReader(cn.c)
		cn.startup(o)
		// reset the deadline, in case one was set (see dial)
		if timeout := o.Get("connect_timeout"); timeout != "" && timeout != "0" {
			err = cn.c.SetDeadline(time.Time{})
		}
		return cn, err
	}

	func dial(d Dialer, o values) (net.Conn, error) {
		ntw, addr := network(o)
		// SSL is not necessary or supported over UNIX domain sockets
		if ntw == "unix" {
			o["sslmode"] = "disable"
		}

		// Zero or not specified means wait indefinitely.
		if timeout := o.Get("connect_timeout"); timeout != "" && timeout != "0" {
			seconds, err := strconv.ParseInt(timeout, 10, 0)
			if err != nil {
				return nil, fmt.Errorf("invalid value for parameter connect_timeout: %s", err)
			}
			duration := time.Duration(seconds) * time.Second
			// connect_timeout should apply to the entire connection establishment
			// procedure, so we both use a timeout for the TCP connection
			// establishment and set a deadline for doing the initial handshake.
			// The deadline is then reset after startup() is done.
			deadline := time.Now().Add(duration)
			conn, err := d.DialTimeout(ntw, addr, duration)
			if err != nil {
				return nil, err
			}
			err = conn.SetDeadline(deadline)
			return conn, err
		}
		return d.Dial(ntw, addr)
	}

	func network(o values) (string, string) {
		host := o.Get("host")

		if strings.HasPrefix(host, "/") {
			sockPath := path.Join(host, ".s.PGSQL."+o.Get("port"))
			return "unix", sockPath
		}

		return "tcp", host + ":" + o.Get("port")
	}

	type values map[string]string

	func (vs values) Set(k, v string) {
		vs[k] = v
	}

	func (vs values) Get(k string) (v string) {
		return vs[k]
	}

	func (vs values) Isset(k string) bool {
		_, ok := vs[k]
		return ok
	}

	// scanner implements a tokenizer for libpq-style option strings.
	type scanner struct {
		s []rune
		i int
	}

	// newScanner returns a new scanner initialized with the option string s.
	func newScanner(s string) *scanner {
		return &scanner{[]rune(s), 0}
	}

	// Next returns the next rune.
	// It returns 0, false if the end of the text has been reached.
	func (s *scanner) Next() (rune, bool) {
		if s.i >= len(s.s) {
			return 0, false
		}
		r := s.s[s.i]
		s.i++
		return r, true
	}

	// SkipSpaces returns the next non-whitespace rune.
	// It returns 0, false if the end of the text has been reached.
	func (s *scanner) SkipSpaces() (rune, bool) {
		r, ok := s.Next()
		for unicode.IsSpace(r) && ok {
			r, ok = s.Next()
		}
		return r, ok
	}

	// parseOpts parses the options from name and adds them to the values.
	//
	// The parsing code is based on conninfo_parse from libpq's fe-connect.c
	func parseOpts(name string, o values) error {
		s := newScanner(name)

		for {
			var (
				keyRunes, valRunes []rune
				r                  rune
				ok                 bool
			)

			if r, ok = s.SkipSpaces(); !ok {
				break
			}

			// Scan the key
			for !unicode.IsSpace(r) && r != '=' {
				keyRunes = append(keyRunes, r)
				if r, ok = s.Next(); !ok {
					break
				}
			}

			// Skip any whitespace if we're not at the = yet
			if r != '=' {
				r, ok = s.SkipSpaces()
			}

			// The current character should be =
			if r != '=' || !ok {
				return fmt.Errorf(`missing "=" after %q in connection info string"`, string(keyRunes))
			}

			// Skip any whitespace after the =
			if r, ok = s.SkipSpaces(); !ok {
				// If we reach the end here, the last value is just an empty string as per libpq.
				o.Set(string(keyRunes), "")
				break
			}

			if r != '\'' {
				for !unicode.IsSpace(r) {
					if r == '\\' {
						if r, ok = s.Next(); !ok {
							return fmt.Errorf(`missing character after backslash`)
						}
					}
					valRunes = append(valRunes, r)

					if r, ok = s.Next(); !ok {
						break
					}
				}
			} else {
			quote:
				for {
					if r, ok = s.Next(); !ok {
						return fmt.Errorf(`unterminated quoted string literal in connection string`)
					}
					switch r {
					case '\'':
						break quote
					case '\\':
						r, _ = s.Next()
						fallthrough
					default:
						valRunes = append(valRunes, r)
					}
				}
			}

			o.Set(string(keyRunes), string(valRunes))
		}

		return nil
	}

	func (cn *conn) isInTransaction() bool {
		return cn.txnStatus == txnStatusIdleInTransaction ||
			cn.txnStatus == txnStatusInFailedTransaction
	}

	func (cn *conn) checkIsInTransaction(intxn bool) {
		if cn.isInTransaction() != intxn {
			cn.bad = true
			errorf("unexpected transaction status %v", cn.txnStatus)
		}
	}

	func (cn *conn) Begin() (_ driver.Tx, err error) {
		if cn.bad {
			return nil, driver.ErrBadConn
		}
		defer cn.errRecover(&err)

		cn.checkIsInTransaction(false)
		_, commandTag, err := cn.simpleExec("BEGIN")
		if err != nil {
			return nil, err
		}
		if commandTag != "BEGIN" {
			cn.bad = true
			return nil, fmt.Errorf("unexpected command tag %s", commandTag)
		}
		if cn.txnStatus != txnStatusIdleInTransaction {
			cn.bad = true
			return nil, fmt.Errorf("unexpected transaction status %v", cn.txnStatus)
		}
		return cn, nil
	}

	func (cn *conn) Commit() (err error) {
		if cn.bad {
			return driver.ErrBadConn
		}
		defer cn.errRecover(&err)

		cn.checkIsInTransaction(true)
		// We don't want the client to think that everything is okay if it tries
		// to commit a failed transaction.  However, no matter what we return,
		// database/sql will release this connection back into the free connection
		// pool so we have to abort the current transaction here.  Note that you
		// would get the same behaviour if you issued a COMMIT in a failed
		// transaction, so it's also the least surprising thing to do here.
		if cn.txnStatus == txnStatusInFailedTransaction {
			if err := cn.Rollback(); err != nil {
				return err
			}
			return ErrInFailedTransaction
		}

		_, commandTag, err := cn.simpleExec("COMMIT")
		if err != nil {
			if cn.isInTransaction() {
				cn.bad = true
			}
			return err
		}
		if commandTag != "COMMIT" {
			cn.bad = true
			return fmt.Errorf("unexpected command tag %s", commandTag)
		}
		cn.checkIsInTransaction(false)
		return nil
	}

	func (cn *conn) Rollback() (err error) {
		if cn.bad {
			return driver.ErrBadConn
		}
		defer cn.errRecover(&err)

		cn.checkIsInTransaction(true)
		_, commandTag, err := cn.simpleExec("ROLLBACK")
		if err != nil {
			if cn.isInTransaction() {
				cn.bad = true
			}
			return err
		}
		if commandTag != "ROLLBACK" {
			return fmt.Errorf("unexpected command tag %s", commandTag)
		}
		cn.checkIsInTransaction(false)
		return nil
	}

	func (cn *conn) gname() string {
		cn.namei++
		return strconv.FormatInt(int64(cn.namei), 10)
	}

	func (cn *conn) simpleExec(q string) (res driver.Result, commandTag string, err error) {
		b := cn.writeBuf('Q')
		b.string(q)
		cn.send(b)

		for {
			t, r := cn.recv1()
			switch t {
			case 'C':
				res, commandTag = cn.parseComplete(r.string())
			case 'Z':
				cn.processReadyForQuery(r)
				// done
				return
			case 'E':
				err = parseError(r)
			case 'T', 'D', 'I':
				// ignore any results
			default:
				cn.bad = true
				errorf("unknown response for simple query: %q", t)
			}
		}
	}

	func (cn *conn) simpleQuery(q string) (res driver.Rows, err error) {
		defer cn.errRecover(&err)

		st := &stmt{cn: cn, name: ""}

		b := cn.writeBuf('Q')
		b.string(q)
		cn.send(b)

		for {
			t, r := cn.recv1()
			switch t {
			case 'C', 'I':
				// We allow queries which don't return any results through Query as
				// well as Exec.  We still have to give database/sql a rows object
				// the user can close, though, to avoid connections from being
				// leaked.  A "rows" with done=true works fine for that purpose.
				if err != nil {
					cn.bad = true
					errorf("unexpected message %q in simple query execution", t)
				}
				res = &rows{st: st, done: true}
			case 'Z':
				cn.processReadyForQuery(r)
				// done
				return
			case 'E':
				res = nil
				err = parseError(r)
			case 'D':
				if res == nil {
					cn.bad = true
					errorf("unexpected DataRow in simple query execution")
				}
				// the query didn't fail; kick off to Next
				cn.saveMessage(t, r)
				return
			case 'T':
				// res might be non-nil here if we received a previous
				// CommandComplete, but that's fine; just overwrite it
				res = &rows{st: st}
				st.cols, st.rowTyps = parseMeta(r)

				// To work around a bug in QueryRow in Go 1.2 and earlier, wait
				// until the first DataRow has been received.
			default:
				cn.bad = true
				errorf("unknown response for simple query: %q", t)
			}
		}
	}

	func (cn *conn) prepareTo(q, stmtName string) (_ *stmt, err error) {
		st := &stmt{cn: cn, name: stmtName}

		b := cn.writeBuf('P')
		b.string(st.name)
		b.string(q)
		b.int16(0)
		cn.send(b)

		b = cn.writeBuf('D')
		b.byte('S')
		b.string(st.name)
		cn.send(b)

		cn.send(cn.writeBuf('S'))

		for {
			t, r := cn.recv1()
			switch t {
			case '1':
			case 't':
				nparams := r.int16()
				st.paramTyps = make([]oid.Oid, nparams)

				for i := range st.paramTyps {
					st.paramTyps[i] = r.oid()
				}
			case 'T':
				st.cols, st.rowTyps = parseMeta(r)
			case 'n':
				// no data
			case 'Z':
				cn.processReadyForQuery(r)
				return st, err
			case 'E':
				err = parseError(r)
			default:
				cn.bad = true
				errorf("unexpected describe rows response: %q", t)
			}
		}
	}

	func (cn *conn) Prepare(q string) (_ driver.Stmt, err error) {
		if cn.bad {
			return nil, driver.ErrBadConn
		}
		defer cn.errRecover(&err)

		if len(q) >= 4 && strings.EqualFold(q[:4], "COPY") {
			return cn.prepareCopyIn(q)
		}
		return cn.prepareTo(q, cn.gname())
	}

	func (cn *conn) Close() (err error) {
		if cn.bad {
			return driver.ErrBadConn
		}
		defer cn.errRecover(&err)

		// Don't go through send(); ListenerConn relies on us not scribbling on the
		// scratch buffer of this connection.
		err = cn.sendSimpleMessage('X')
		if err != nil {
			return err
		}

		return cn.c.Close()
	}

	// Implement the "Queryer" interface
	func (cn *conn) Query(query string, args []driver.Value) (_ driver.Rows, err error) {
		if cn.bad {
			return nil, driver.ErrBadConn
		}
		defer cn.errRecover(&err)

		// Check to see if we can use the "simpleQuery" interface, which is
		// *much* faster than going through prepare/exec
		if len(args) == 0 {
			return cn.simpleQuery(query)
		}

		st, err := cn.prepareTo(query, "")
		if err != nil {
			panic(err)
		}

		st.exec(args)
		return &rows{st: st}, nil
	}

	// Implement the optional "Execer" interface for one-shot queries
	func (cn *conn) Exec(query string, args []driver.Value) (_ driver.Result, err error) {
		if cn.bad {
			return nil, driver.ErrBadConn
		}
		defer cn.errRecover(&err)

		// Check to see if we can use the "simpleExec" interface, which is
		// *much* faster than going through prepare/exec
		if len(args) == 0 {
			// ignore commandTag, our caller doesn't care
			r, _, err := cn.simpleExec(query)
			return r, err
		}

		// Use the unnamed statement to defer planning until bind
		// time, or else value-based selectivity estimates cannot be
		// used.
		st, err := cn.prepareTo(query, "")
		if err != nil {
			panic(err)
		}

		r, err := st.Exec(args)
		if err != nil {
			panic(err)
		}

		return r, err
	}

	// Assumes len(*m) is > 5
	func (cn *conn) send(m *writeBuf) {
		b := (*m)[1:]
		binary.BigEndian.PutUint32(b, uint32(len(b)))

		if (*m)[0] == 0 {
			*m = b
		}

		_, err := cn.c.Write(*m)
		if err != nil {
			panic(err)
		}
	}

	// Send a message of type typ to the server on the other end of cn.  The
	// message should have no payload.  This method does not use the scratch
	// buffer.
	func (cn *conn) sendSimpleMessage(typ byte) (err error) {
		_, err = cn.c.Write([]byte{typ, '\x00', '\x00', '\x00', '\x04'})
		return err
	}

	// saveMessage memorizes a message and its buffer in the conn struct.
	// recvMessage will then return these values on the next call to it.  This
	// method is useful in cases where you have to see what the next message is
	// going to be (e.g. to see whether it's an error or not) but you can't handle
	// the message yourself.
	func (cn *conn) saveMessage(typ byte, buf *readBuf) {
		if cn.saveMessageType != 0 {
			cn.bad = true
			errorf("unexpected saveMessageType %d", cn.saveMessageType)
		}
		cn.saveMessageType = typ
		cn.saveMessageBuffer = *buf
	}

	// recvMessage receives any message from the backend, or returns an error if
	// a problem occurred while reading the message.
	func (cn *conn) recvMessage(r *readBuf) (byte, error) {
		// workaround for a QueryRow bug, see exec
		if cn.saveMessageType != 0 {
			t := cn.saveMessageType
			*r = cn.saveMessageBuffer
			cn.saveMessageType = 0
			cn.saveMessageBuffer = nil
			return t, nil
		}

		x := cn.scratch[:5]
		_, err := io.ReadFull(cn.buf, x)
		if err != nil {
			return 0, err
		}

		// read the type and length of the message that follows
		t := x[0]
		n := int(binary.BigEndian.Uint32(x[1:])) - 4
		var y []byte
		if n <= len(cn.scratch) {
			y = cn.scratch[:n]
		} else {
			y = make([]byte, n)
		}
		_, err = io.ReadFull(cn.buf, y)
		if err != nil {
			return 0, err
		}
		*r = y
		return t, nil
	}

	// recv receives a message from the backend, but if an error happened while
	// reading the message or the received message was an ErrorResponse, it panics.
	// NoticeResponses are ignored.  This function should generally be used only
	// during the startup sequence.
	func (cn *conn) recv() (t byte, r *readBuf) {
		for {
			var err error
			r = &readBuf{}
			t, err = cn.recvMessage(r)
			if err != nil {
				panic(err)
			}

			switch t {
			case 'E':
				panic(parseError(r))
			case 'N':
				// ignore
			default:
				return
			}
		}
	}

	// recv1Buf is exactly equivalent to recv1, except it uses a buffer supplied by
	// the caller to avoid an allocation.
	func (cn *conn) recv1Buf(r *readBuf) byte {
		for {
			t, err := cn.recvMessage(r)
			if err != nil {
				panic(err)
			}

			switch t {
			case 'A', 'N':
				// ignore
			case 'S':
				cn.processParameterStatus(r)
			default:
				return t
			}
		}
	}

	// recv1 receives a message from the backend, panicking if an error occurs
	// while attempting to read it.  All asynchronous messages are ignored, with
	// the exception of ErrorResponse.
	func (cn *conn) recv1() (t byte, r *readBuf) {
		r = &readBuf{}
		t = cn.recv1Buf(r)
		return t, r
	}

	func (cn *conn) ssl(o values) {
		verifyCaOnly := false
		tlsConf := tls.Config{}
		switch mode := o.Get("sslmode"); mode {
		case "require", "":
			tlsConf.InsecureSkipVerify = true
		case "verify-ca":
			// We must skip TLS's own verification since it requires full
			// verification since Go 1.3.
			tlsConf.InsecureSkipVerify = true
			verifyCaOnly = true
		case "verify-full":
			tlsConf.ServerName = o.Get("host")
		case "disable":
			return
		default:
			errorf(`unsupported sslmode %q; only "require" (default), "verify-full", and "disable" supported`, mode)
		}

		cn.setupSSLClientCertificates(&tlsConf, o)
		cn.setupSSLCA(&tlsConf, o)

		w := cn.writeBuf(0)
		w.int32(80877103)
		cn.send(w)

		b := cn.scratch[:1]
		_, err := io.ReadFull(cn.c, b)
		if err != nil {
			panic(err)
		}

		if b[0] != 'S' {
			panic(ErrSSLNotSupported)
		}

		client := tls.Client(cn.c, &tlsConf)
		if verifyCaOnly {
			cn.verifyCA(client, &tlsConf)
		}
		cn.c = client
	}

	// verifyCA carries out a TLS handshake to the server and verifies the
	// presented certificate against the effective CA, i.e. the one specified in
	// sslrootcert or the system CA if sslrootcert was not specified.
	func (cn *conn) verifyCA(client *tls.Conn, tlsConf *tls.Config) {
		err := client.Handshake()
		if err != nil {
			panic(err)
		}
		certs := client.ConnectionState().PeerCertificates
		opts := x509.VerifyOptions{
			DNSName:       client.ConnectionState().ServerName,
			Intermediates: x509.NewCertPool(),
			Roots:         tlsConf.RootCAs,
		}
		for i, cert := range certs {
			if i == 0 {
				continue
			}
			opts.Intermediates.AddCert(cert)
		}
		_, err = certs[0].Verify(opts)
		if err != nil {
			panic(err)
		}
	}

	// This function sets up SSL client certificates based on either the "sslkey"
	// and "sslcert" settings (possibly set via the environment variables PGSSLKEY
	// and PGSSLCERT, respectively), or if they aren't set, from the .postgresql
	// directory in the user's home directory.  If the file paths are set
	// explicitly, the files must exist.  The key file must also not be
	// world-readable, or this function will panic with
	// ErrSSLKeyHasWorldPermissions.
	func (cn *conn) setupSSLClientCertificates(tlsConf *tls.Config, o values) {
		var missingOk bool

		sslkey := o.Get("sslkey")
		sslcert := o.Get("sslcert")
		if sslkey != "" && sslcert != "" {
			// If the user has set an sslkey and sslcert, they *must* exist.
			missingOk = false
		} else {
			// Automatically load certificates from ~/.postgresql.
			user, err := user.Current()
			if err != nil {
				// user.Current() might fail when cross-compiling.  We have to
				// ignore the error and continue without client certificates, since
				// we wouldn't know where to load them from.
				return
			}

			sslkey = filepath.Join(user.HomeDir, ".postgresql", "postgresql.key")
			sslcert = filepath.Join(user.HomeDir, ".postgresql", "postgresql.crt")
			missingOk = true
		}

		// Check that both files exist, and report the error or stop, depending on
		// which behaviour we want.  Note that we don't do any more extensive
		// checks than this (such as checking that the paths aren't directories);
		// LoadX509KeyPair() will take care of the rest.
		keyfinfo, err := os.Stat(sslkey)
		if err != nil && missingOk {
			return
		} else if err != nil {
			panic(err)
		}
		_, err = os.Stat(sslcert)
		if err != nil && missingOk {
			return
		} else if err != nil {
			panic(err)
		}

		// If we got this far, the key file must also have the correct permissions
		kmode := keyfinfo.Mode()
		if kmode != kmode&0600 {
			panic(ErrSSLKeyHasWorldPermissions)
		}

		cert, err := tls.LoadX509KeyPair(sslcert, sslkey)
		if err != nil {
			panic(err)
		}
		tlsConf.Certificates = []tls.Certificate{cert}
	}

	// Sets up RootCAs in the TLS configuration if sslrootcert is set.
	func (cn *conn) setupSSLCA(tlsConf *tls.Config, o values) {
		if sslrootcert := o.Get("sslrootcert"); sslrootcert != "" {
			tlsConf.RootCAs = x509.NewCertPool()

			cert, err := ioutil.ReadFile(sslrootcert)
			if err != nil {
				panic(err)
			}

			ok := tlsConf.RootCAs.AppendCertsFromPEM(cert)
			if !ok {
				errorf("couldn't parse pem in sslrootcert")
			}
		}
	}

	// isDriverSetting returns true iff a setting is purely for configuring the
	// driver's options and should not be sent to the server in the connection
	// startup packet.
	func isDriverSetting(key string) bool {
		switch key {
		case "host", "port":
			return true
		case "password":
			return true
		case "sslmode", "sslcert", "sslkey", "sslrootcert":
			return true
		case "fallback_application_name":
			return true
		case "connect_timeout":
			return true

		default:
			return false
		}
	}

	func (cn *conn) startup(o values) {
		w := cn.writeBuf(0)
		w.int32(196608)
		// Send the backend the name of the database we want to connect to, and the
		// user we want to connect as.  Additionally, we send over any run-time
		// parameters potentially included in the connection string.  If the server
		// doesn't recognize any of them, it will reply with an error.
		for k, v := range o {
			if isDriverSetting(k) {
				// skip options which can't be run-time parameters
				continue
			}
			// The protocol requires us to supply the database name as "database"
			// instead of "dbname".
			if k == "dbname" {
				k = "database"
			}
			w.string(k)
			w.string(v)
		}
		w.string("")
		cn.send(w)

		for {
			t, r := cn.recv()
			switch t {
			case 'K':
			case 'S':
				cn.processParameterStatus(r)
			case 'R':
				cn.auth(r, o)
			case 'Z':
				cn.processReadyForQuery(r)
				return
			default:
				errorf("unknown response for startup: %q", t)
			}
		}
	}

	func (cn *conn) auth(r *readBuf, o values) {
		switch code := r.int32(); code {
		case 0:
			// OK
		case 3:
			w := cn.writeBuf('p')
			w.string(o.Get("password"))
			cn.send(w)

			t, r := cn.recv()
			if t != 'R' {
				errorf("unexpected password response: %q", t)
			}

			if r.int32() != 0 {
				errorf("unexpected authentication response: %q", t)
			}
		case 5:
			s := string(r.next(4))
			w := cn.writeBuf('p')
			w.string("md5" + md5s(md5s(o.Get("password")+o.Get("user"))+s))
			cn.send(w)

			t, r := cn.recv()
			if t != 'R' {
				errorf("unexpected password response: %q", t)
			}

			if r.int32() != 0 {
				errorf("unexpected authentication response: %q", t)
			}
		default:
			errorf("unknown authentication response: %d", code)
		}
	}

	type stmt struct {
		cn        *conn
		name      string
		cols      []string
		rowTyps   []oid.Oid
		paramTyps []oid.Oid
		closed    bool
	}

	func (st *stmt) Close() (err error) {
		if st.closed {
			return nil
		}
		if st.cn.bad {
			return driver.ErrBadConn
		}
		defer st.cn.errRecover(&err)

		w := st.cn.writeBuf('C')
		w.byte('S')
		w.string(st.name)
		st.cn.send(w)

		st.cn.send(st.cn.writeBuf('S'))

		t, _ := st.cn.recv1()
		if t != '3' {
			st.cn.bad = true
			errorf("unexpected close response: %q", t)
		}
		st.closed = true

		t, r := st.cn.recv1()
		if t != 'Z' {
			st.cn.bad = true
			errorf("expected ready for query, but got: %q", t)
		}
		st.cn.processReadyForQuery(r)

		return nil
	}

	func (st *stmt) Query(v []driver.Value) (r driver.Rows, err error) {
		if st.cn.bad {
			return nil, driver.ErrBadConn
		}
		defer st.cn.errRecover(&err)

		st.exec(v)
		return &rows{st: st}, nil
	}

	func (st *stmt) Exec(v []driver.Value) (res driver.Result, err error) {
		if st.cn.bad {
			return nil, driver.ErrBadConn
		}
		defer st.cn.errRecover(&err)

		st.exec(v)

		for {
			t, r := st.cn.recv1()
			switch t {
			case 'E':
				err = parseError(r)
			case 'C':
				res, _ = st.cn.parseComplete(r.string())
			case 'Z':
				st.cn.processReadyForQuery(r)
				// done
				return
			case 'T', 'D', 'I':
				// ignore any results
			default:
				st.cn.bad = true
				errorf("unknown exec response: %q", t)
			}
		}
	}

	func (st *stmt) exec(v []driver.Value) {
		if len(v) >= 65536 {
			errorf("got %d parameters but PostgreSQL only supports 65535 parameters", len(v))
		}
		if len(v) != len(st.paramTyps) {
			errorf("got %d parameters but the statement requires %d", len(v), len(st.paramTyps))
		}

		w := st.cn.writeBuf('B')
		w.string("")
		w.string(st.name)
		w.int16(0)
		w.int16(len(v))
		for i, x := range v {
			if x == nil {
				w.int32(-1)
			} else {
				b := encode(&st.cn.parameterStatus, x, st.paramTyps[i])
				w.int32(len(b))
				w.bytes(b)
			}
		}
		w.int16(0)
		st.cn.send(w)

		w = st.cn.writeBuf('E')
		w.string("")
		w.int32(0)
		st.cn.send(w)

		st.cn.send(st.cn.writeBuf('S'))

		var err error
		for {
			t, r := st.cn.recv1()
			switch t {
			case 'E':
				err = parseError(r)
			case '2':
				if err != nil {
					panic(err)
				}
				goto workaround
			case 'Z':
				st.cn.processReadyForQuery(r)
				if err != nil {
					panic(err)
				}
				return
			default:
				st.cn.bad = true
				errorf("unexpected bind response: %q", t)
			}
		}

		// Work around a bug in sql.DB.QueryRow: in Go 1.2 and earlier it ignores
		// any errors from rows.Next, which masks errors that happened during the
		// execution of the query.  To avoid the problem in common cases, we wait
		// here for one more message from the database.  If it's not an error the
		// query will likely succeed (or perhaps has already, if it's a
		// CommandComplete), so we push the message into the conn struct; recv1
		// will return it as the next message for rows.Next or rows.Close.
		// However, if it's an error, we wait until ReadyForQuery and then return
		// the error to our caller.
	workaround:
		for {
			t, r := st.cn.recv1()
			switch t {
			case 'E':
				err = parseError(r)
			case 'C', 'D', 'I':
				// the query didn't fail, but we can't process this message
				st.cn.saveMessage(t, r)
				return
			case 'Z':
				if err == nil {
					st.cn.bad = true
					errorf("unexpected ReadyForQuery during extended query execution")
				}
				st.cn.processReadyForQuery(r)
				panic(err)
			default:
				st.cn.bad = true
				errorf("unexpected message during query execution: %q", t)
			}
		}
	}

	func (st *stmt) NumInput() int {
		return len(st.paramTyps)
	}

	// parseComplete parses the "command tag" from a CommandComplete message, and
	// returns the number of rows affected (if applicable) and a string
	// identifying only the command that was executed, e.g. "ALTER TABLE".  If the
	// command tag could not be parsed, parseComplete panics.
	func (cn *conn) parseComplete(commandTag string) (driver.Result, string) {
		commandsWithAffectedRows := []string{
			"SELECT ",
			// INSERT is handled below
			"UPDATE ",
			"DELETE ",
			"FETCH ",
			"MOVE ",
			"COPY ",
		}

		var affectedRows *string
		for _, tag := range commandsWithAffectedRows {
			if strings.HasPrefix(commandTag, tag) {
				t := commandTag[len(tag):]
				affectedRows = &t
				commandTag = tag[:len(tag)-1]
				break
			}
		}
		// INSERT also includes the oid of the inserted row in its command tag.
		// Oids in user tables are deprecated, and the oid is only returned when
		// exactly one row is inserted, so it's unlikely to be of value to any
		// real-world application and we can ignore it.
		if affectedRows == nil && strings.HasPrefix(commandTag, "INSERT ") {
			parts := strings.Split(commandTag, " ")
			if len(parts) != 3 {
				cn.bad = true
				errorf("unexpected INSERT command tag %s", commandTag)
			}
			affectedRows = &parts[len(parts)-1]
			commandTag = "INSERT"
		}
		// There should be no affected rows attached to the tag, just return it
		if affectedRows == nil {
			return driver.RowsAffected(0), commandTag
		}
		n, err := strconv.ParseInt(*affectedRows, 10, 64)
		if err != nil {
			cn.bad = true
			errorf("could not parse commandTag: %s", err)
		}
		return driver.RowsAffected(n), commandTag
	}

	type rows struct {
		st   *stmt
		done bool
		rb   readBuf
	}

	func (rs *rows) Close() error {
		// no need to look at cn.bad as Next() will
		for {
			err := rs.Next(nil)
			switch err {
			case nil:
			case io.EOF:
				return nil
			default:
				return err
			}
		}
	}

	func (rs *rows) Columns() []string {
		return rs.st.cols
	}

	func (rs *rows) Next(dest []driver.Value) (err error) {
		if rs.done {
			return io.EOF
		}

		conn := rs.st.cn
		if conn.bad {
			return driver.ErrBadConn
		}
		defer conn.errRecover(&err)

		for {
			t := conn.recv1Buf(&rs.rb)
			switch t {
			case 'E':
				err = parseError(&rs.rb)
			case 'C', 'I':
				continue
			case 'Z':
				conn.processReadyForQuery(&rs.rb)
				rs.done = true
				if err != nil {
					return err
				}
				return io.EOF
			case 'D':
				n := rs.rb.int16()
				if n < len(dest) {
					dest = dest[:n]
				}
				for i := range dest {
					l := rs.rb.int32()
					if l == -1 {
						dest[i] = nil
						continue
					}
					dest[i] = decode(&conn.parameterStatus, rs.rb.next(l), rs.st.rowTyps[i])
				}
				return
			default:
				errorf("unexpected message after execute: %q", t)
			}
		}
	}

	// QuoteIdentifier quotes an "identifier" (e.g. a table or a column name) to be
	// used as part of an SQL statement.  For example:
	//
	//    tblname := "my_table"
	//    data := "my_data"
	//    err = db.Exec(fmt.Sprintf("INSERT INTO %s VALUES ($1)", pq.QuoteIdentifier(tblname)), data)
	//
	// Any double quotes in name will be escaped.  The quoted identifier will be
	// case sensitive when used in a query.  If the input string contains a zero
	// byte, the result will be truncated immediately before it.
	func QuoteIdentifier(name string) string {
		end := strings.IndexRune(name, 0)
		if end > -1 {
			name = name[:end]
		}
		return `"` + strings.Replace(name, `"`, `""`, -1) + `"`
	}

	func md5s(s string) string {
		h := md5.New()
		h.Write([]byte(s))
		return fmt.Sprintf("%x", h.Sum(nil))
	}

	func (c *conn) processParameterStatus(r *readBuf) {
		var err error

		param := r.string()
		switch param {
		case "server_version":
			var major1 int
			var major2 int
			var minor int
			_, err = fmt.Sscanf(r.string(), "%d.%d.%d", &major1, &major2, &minor)
			if err == nil {
				c.parameterStatus.serverVersion = major1*10000 + major2*100 + minor
			}

		case "TimeZone":
			c.parameterStatus.currentLocation, err = time.LoadLocation(r.string())
			if err != nil {
				c.parameterStatus.currentLocation = nil
			}

		default:
			// ignore
		}
	}

	func (c *conn) processReadyForQuery(r *readBuf) {
		c.txnStatus = transactionStatus(r.byte())
	}

	func parseMeta(r *readBuf) (cols []string, rowTyps []oid.Oid) {
		n := r.int16()
		cols = make([]string, n)
		rowTyps = make([]oid.Oid, n)
		for i := range cols {
			cols[i] = r.string()
			r.next(6)
			rowTyps[i] = r.oid()
			r.next(8)
		}
		return
	}

	// parseEnviron tries to mimic some of libpq's environment handling
	//
	// To ease testing, it does not directly reference os.Environ, but is
	// designed to accept its output.
	//
	// Environment-set connection information is intended to have a higher
	// precedence than a library default but lower than any explicitly
	// passed information (such as in the URL or connection string).
	func parseEnviron(env []string) (out map[string]string) {
		out = make(map[string]string)

		for _, v := range env {
			parts := strings.SplitN(v, "=", 2)

			accrue := func(keyname string) {
				out[keyname] = parts[1]
			}
			unsupported := func() {
				panic(fmt.Sprintf("setting %v not supported", parts[0]))
			}

			// The order of these is the same as is seen in the
			// PostgreSQL 9.1 manual. Unsupported but well-defined
			// keys cause a panic; these should be unset prior to
			// execution. Options which pq expects to be set to a
			// certain value are allowed, but must be set to that
			// value if present (they can, of course, be absent).
			switch parts[0] {
			case "PGHOST":
				accrue("host")
			case "PGHOSTADDR":
				unsupported()
			case "PGPORT":
				accrue("port")
			case "PGDATABASE":
				accrue("dbname")
			case "PGUSER":
				accrue("user")
			case "PGPASSWORD":
				accrue("password")
			case "PGPASSFILE", "PGSERVICE", "PGSERVICEFILE", "PGREALM":
				unsupported()
			case "PGOPTIONS":
				accrue("options")
			case "PGAPPNAME":
				accrue("application_name")
			case "PGSSLMODE":
				accrue("sslmode")
			case "PGSSLCERT":
				accrue("sslcert")
			case "PGSSLKEY":
				accrue("sslkey")
			case "PGSSLROOTCERT":
				accrue("sslrootcert")
			case "PGREQUIRESSL", "PGSSLCRL":
				unsupported()
			case "PGREQUIREPEER":
				unsupported()
			case "PGKRBSRVNAME", "PGGSSLIB":
				unsupported()
			case "PGCONNECT_TIMEOUT":
				accrue("connect_timeout")
			case "PGCLIENTENCODING":
				accrue("client_encoding")
			case "PGDATESTYLE":
				accrue("datestyle")
			case "PGTZ":
				accrue("timezone")
			case "PGGEQO":
				accrue("geqo")
			case "PGSYSCONFDIR", "PGLOCALEDIR":
				unsupported()
			}
		}

		return out
	}

	// isUTF8 returns whether name is a fuzzy variation of the string "UTF-8".
	func isUTF8(name string) bool {
		// Recognize all sorts of silly things as "UTF-8", like Postgres does
		s := strings.Map(alnumLowerASCII, name)
		return s == "utf8" || s == "unicode"
	}

	func alnumLowerASCII(ch rune) rune {
		if 'A' <= ch && ch <= 'Z' {
			return ch + ('a' - 'A')
		}
		if 'a' <= ch && ch <= 'z' || '0' <= ch && ch <= '9' {
			return ch
		}
		return -1 // discard
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_conn_test
	package pq

	import (
		"database/sql"
		"database/sql/driver"
		"fmt"
		"io"
		"os"
		"reflect"
		"testing"
		"time"
	)

	type Fatalistic interface {
		Fatal(args ...interface{})
	}

	func openTestConnConninfo(conninfo string) (*sql.DB, error) {
		datname := os.Getenv("PGDATABASE")
		sslmode := os.Getenv("PGSSLMODE")
		timeout := os.Getenv("PGCONNECT_TIMEOUT")

		if datname == "" {
			os.Setenv("PGDATABASE", "pqgotest")
		}

		if sslmode == "" {
			os.Setenv("PGSSLMODE", "disable")
		}

		if timeout == "" {
			os.Setenv("PGCONNECT_TIMEOUT", "20")
		}

		return sql.Open("postgres", conninfo)
	}

	func openTestConn(t Fatalistic) *sql.DB {
		conn, err := openTestConnConninfo("")
		if err != nil {
			t.Fatal(err)
		}

		return conn
	}

	func getServerVersion(t *testing.T, db *sql.DB) int {
		var version int
		err := db.QueryRow("SHOW server_version_num").Scan(&version)
		if err != nil {
			t.Fatal(err)
		}
		return version
	}

	func TestReconnect(t *testing.T) {
		db1 := openTestConn(t)
		defer db1.Close()
		tx, err := db1.Begin()
		if err != nil {
			t.Fatal(err)
		}
		var pid1 int
		err = tx.QueryRow("SELECT pg_backend_pid()").Scan(&pid1)
		if err != nil {
			t.Fatal(err)
		}
		db2 := openTestConn(t)
		defer db2.Close()
		_, err = db2.Exec("SELECT pg_terminate_backend($1)", pid1)
		if err != nil {
			t.Fatal(err)
		}
		// The rollback will probably "fail" because we just killed
		// its connection above
		_ = tx.Rollback()

		const expected int = 42
		var result int
		err = db1.QueryRow(fmt.Sprintf("SELECT %d", expected)).Scan(&result)
		if err != nil {
			t.Fatal(err)
		}
		if result != expected {
			t.Errorf("got %v; expected %v", result, expected)
		}
	}

	func TestCommitInFailedTransaction(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		txn, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		rows, err := txn.Query("SELECT error")
		if err == nil {
			rows.Close()
			t.Fatal("expected failure")
		}
		err = txn.Commit()
		if err != ErrInFailedTransaction {
			t.Fatalf("expected ErrInFailedTransaction; got %#v", err)
		}
	}

	func TestOpenURL(t *testing.T) {
		db, err := openTestConnConninfo("postgres://")
		if err != nil {
			t.Fatal(err)
		}
		defer db.Close()
		// database/sql might not call our Open at all unless we do something with
		// the connection
		txn, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		txn.Rollback()
	}

	func TestExec(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		_, err := db.Exec("CREATE TEMP TABLE temp (a int)")
		if err != nil {
			t.Fatal(err)
		}

		r, err := db.Exec("INSERT INTO temp VALUES (1)")
		if err != nil {
			t.Fatal(err)
		}

		if n, _ := r.RowsAffected(); n != 1 {
			t.Fatalf("expected 1 row affected, not %d", n)
		}

		r, err = db.Exec("INSERT INTO temp VALUES ($1), ($2), ($3)", 1, 2, 3)
		if err != nil {
			t.Fatal(err)
		}

		if n, _ := r.RowsAffected(); n != 3 {
			t.Fatalf("expected 3 rows affected, not %d", n)
		}

		// SELECT doesn't send the number of returned rows in the command tag
		// before 9.0
		if getServerVersion(t, db) >= 90000 {
			r, err = db.Exec("SELECT g FROM generate_series(1, 2) g")
			if err != nil {
				t.Fatal(err)
			}
			if n, _ := r.RowsAffected(); n != 2 {
				t.Fatalf("expected 2 rows affected, not %d", n)
			}

			r, err = db.Exec("SELECT g FROM generate_series(1, $1) g", 3)
			if err != nil {
				t.Fatal(err)
			}
			if n, _ := r.RowsAffected(); n != 3 {
				t.Fatalf("expected 3 rows affected, not %d", n)
			}
		}
	}

	func TestStatment(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		st, err := db.Prepare("SELECT 1")
		if err != nil {
			t.Fatal(err)
		}

		st1, err := db.Prepare("SELECT 2")
		if err != nil {
			t.Fatal(err)
		}

		r, err := st.Query()
		if err != nil {
			t.Fatal(err)
		}
		defer r.Close()

		if !r.Next() {
			t.Fatal("expected row")
		}

		var i int
		err = r.Scan(&i)
		if err != nil {
			t.Fatal(err)
		}

		if i != 1 {
			t.Fatalf("expected 1, got %d", i)
		}

		// st1

		r1, err := st1.Query()
		if err != nil {
			t.Fatal(err)
		}
		defer r1.Close()

		if !r1.Next() {
			if r.Err() != nil {
				t.Fatal(r1.Err())
			}
			t.Fatal("expected row")
		}

		err = r1.Scan(&i)
		if err != nil {
			t.Fatal(err)
		}

		if i != 2 {
			t.Fatalf("expected 2, got %d", i)
		}
	}

	func TestRowsCloseBeforeDone(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		r, err := db.Query("SELECT 1")
		if err != nil {
			t.Fatal(err)
		}

		err = r.Close()
		if err != nil {
			t.Fatal(err)
		}

		if r.Next() {
			t.Fatal("unexpected row")
		}

		if r.Err() != nil {
			t.Fatal(r.Err())
		}
	}

	func TestParameterCountMismatch(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		var notused int
		err := db.QueryRow("SELECT false", 1).Scan(&notused)
		if err == nil {
			t.Fatal("expected err")
		}
		// make sure we clean up correctly
		err = db.QueryRow("SELECT 1").Scan(&notused)
		if err != nil {
			t.Fatal(err)
		}

		err = db.QueryRow("SELECT $1").Scan(&notused)
		if err == nil {
			t.Fatal("expected err")
		}
		// make sure we clean up correctly
		err = db.QueryRow("SELECT 1").Scan(&notused)
		if err != nil {
			t.Fatal(err)
		}
	}

	// Test that EmptyQueryResponses are handled correctly.
	func TestEmptyQuery(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		_, err := db.Exec("")
		if err != nil {
			t.Fatal(err)
		}
		rows, err := db.Query("")
		if err != nil {
			t.Fatal(err)
		}
		cols, err := rows.Columns()
		if err != nil {
			t.Fatal(err)
		}
		if len(cols) != 0 {
			t.Fatalf("unexpected number of columns %d in response to an empty query", len(cols))
		}
		if rows.Next() {
			t.Fatal("unexpected row")
		}
		if rows.Err() != nil {
			t.Fatal(rows.Err())
		}

		stmt, err := db.Prepare("")
		if err != nil {
			t.Fatal(err)
		}
		_, err = stmt.Exec()
		if err != nil {
			t.Fatal(err)
		}
		rows, err = stmt.Query()
		if err != nil {
			t.Fatal(err)
		}
		cols, err = rows.Columns()
		if err != nil {
			t.Fatal(err)
		}
		if len(cols) != 0 {
			t.Fatalf("unexpected number of columns %d in response to an empty query", len(cols))
		}
		if rows.Next() {
			t.Fatal("unexpected row")
		}
		if rows.Err() != nil {
			t.Fatal(rows.Err())
		}
	}

	func TestEncodeDecode(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		q := `
			SELECT
				E'\\000\\001\\002'::bytea,
				'foobar'::text,
				NULL::integer,
				'2000-1-1 01:02:03.04-7'::timestamptz,
				0::boolean,
				123,
				3.14::float8
			WHERE
					E'\\000\\001\\002'::bytea = $1
				AND 'foobar'::text = $2
				AND $3::integer is NULL
		`
		// AND '2000-1-1 12:00:00.000000-7'::timestamp = $3

		exp1 := []byte{0, 1, 2}
		exp2 := "foobar"

		r, err := db.Query(q, exp1, exp2, nil)
		if err != nil {
			t.Fatal(err)
		}
		defer r.Close()

		if !r.Next() {
			if r.Err() != nil {
				t.Fatal(r.Err())
			}
			t.Fatal("expected row")
		}

		var got1 []byte
		var got2 string
		var got3 = sql.NullInt64{Valid: true}
		var got4 time.Time
		var got5, got6, got7 interface{}

		err = r.Scan(&got1, &got2, &got3, &got4, &got5, &got6, &got7)
		if err != nil {
			t.Fatal(err)
		}

		if !reflect.DeepEqual(exp1, got1) {
			t.Errorf("expected %q byte: %q", exp1, got1)
		}

		if !reflect.DeepEqual(exp2, got2) {
			t.Errorf("expected %q byte: %q", exp2, got2)
		}

		if got3.Valid {
			t.Fatal("expected invalid")
		}

		if got4.Year() != 2000 {
			t.Fatal("wrong year")
		}

		if got5 != false {
			t.Fatalf("expected false, got %q", got5)
		}

		if got6 != int64(123) {
			t.Fatalf("expected 123, got %d", got6)
		}

		if got7 != float64(3.14) {
			t.Fatalf("expected 3.14, got %f", got7)
		}
	}

	func TestNoData(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		st, err := db.Prepare("SELECT 1 WHERE true = false")
		if err != nil {
			t.Fatal(err)
		}
		defer st.Close()

		r, err := st.Query()
		if err != nil {
			t.Fatal(err)
		}
		defer r.Close()

		if r.Next() {
			if r.Err() != nil {
				t.Fatal(r.Err())
			}
			t.Fatal("unexpected row")
		}

		_, err = db.Query("SELECT * FROM nonexistenttable WHERE age=$1", 20)
		if err == nil {
			t.Fatal("Should have raised an error on non existent table")
		}

		_, err = db.Query("SELECT * FROM nonexistenttable")
		if err == nil {
			t.Fatal("Should have raised an error on non existent table")
		}
	}

	func TestErrorDuringStartup(t *testing.T) {
		// Don't use the normal connection setup, this is intended to
		// blow up in the startup packet from a non-existent user.
		db, err := openTestConnConninfo("user=thisuserreallydoesntexist")
		if err != nil {
			t.Fatal(err)
		}
		defer db.Close()

		_, err = db.Begin()
		if err == nil {
			t.Fatal("expected error")
		}

		e, ok := err.(*Error)
		if !ok {
			t.Fatalf("expected Error, got %#v", err)
		} else if e.Code.Name() != "invalid_authorization_specification" && e.Code.Name() != "invalid_password" {
			t.Fatalf("expected invalid_authorization_specification or invalid_password, got %s (%+v)", e.Code.Name(), err)
		}
	}

	func TestBadConn(t *testing.T) {
		var err error

		cn := conn{}
		func() {
			defer cn.errRecover(&err)
			panic(io.EOF)
		}()
		if err != driver.ErrBadConn {
			t.Fatalf("expected driver.ErrBadConn, got: %#v", err)
		}
		if !cn.bad {
			t.Fatalf("expected cn.bad")
		}

		cn = conn{}
		func() {
			defer cn.errRecover(&err)
			e := &Error{Severity: Efatal}
			panic(e)
		}()
		if err != driver.ErrBadConn {
			t.Fatalf("expected driver.ErrBadConn, got: %#v", err)
		}
		if !cn.bad {
			t.Fatalf("expected cn.bad")
		}
	}

	func TestErrorOnExec(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		txn, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		defer txn.Rollback()

		_, err = txn.Exec("CREATE TEMPORARY TABLE foo(f1 int PRIMARY KEY)")
		if err != nil {
			t.Fatal(err)
		}

		_, err = txn.Exec("INSERT INTO foo VALUES (0), (0)")
		if err == nil {
			t.Fatal("Should have raised error")
		}

		e, ok := err.(*Error)
		if !ok {
			t.Fatalf("expected Error, got %#v", err)
		} else if e.Code.Name() != "unique_violation" {
			t.Fatalf("expected unique_violation, got %s (%+v)", e.Code.Name(), err)
		}
	}

	func TestErrorOnQuery(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		txn, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		defer txn.Rollback()

		_, err = txn.Exec("CREATE TEMPORARY TABLE foo(f1 int PRIMARY KEY)")
		if err != nil {
			t.Fatal(err)
		}

		_, err = txn.Query("INSERT INTO foo VALUES (0), (0)")
		if err == nil {
			t.Fatal("Should have raised error")
		}

		e, ok := err.(*Error)
		if !ok {
			t.Fatalf("expected Error, got %#v", err)
		} else if e.Code.Name() != "unique_violation" {
			t.Fatalf("expected unique_violation, got %s (%+v)", e.Code.Name(), err)
		}
	}

	func TestErrorOnQueryRowSimpleQuery(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		txn, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		defer txn.Rollback()

		_, err = txn.Exec("CREATE TEMPORARY TABLE foo(f1 int PRIMARY KEY)")
		if err != nil {
			t.Fatal(err)
		}

		var v int
		err = txn.QueryRow("INSERT INTO foo VALUES (0), (0)").Scan(&v)
		if err == nil {
			t.Fatal("Should have raised error")
		}

		e, ok := err.(*Error)
		if !ok {
			t.Fatalf("expected Error, got %#v", err)
		} else if e.Code.Name() != "unique_violation" {
			t.Fatalf("expected unique_violation, got %s (%+v)", e.Code.Name(), err)
		}
	}

	// Test the QueryRow bug workarounds in stmt.exec() and simpleQuery()
	func TestQueryRowBugWorkaround(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		// stmt.exec()
		_, err := db.Exec("CREATE TEMP TABLE notnulltemp (a varchar(10) not null)")
		if err != nil {
			t.Fatal(err)
		}

		var a string
		err = db.QueryRow("INSERT INTO notnulltemp(a) values($1) RETURNING a", nil).Scan(&a)
		if err == sql.ErrNoRows {
			t.Fatalf("expected constraint violation error; got: %v", err)
		}
		pge, ok := err.(*Error)
		if !ok {
			t.Fatalf("expected *Error; got: %#v", err)
		}
		if pge.Code.Name() != "not_null_violation" {
			t.Fatalf("expected not_null_violation; got: %s (%+v)", pge.Code.Name(), err)
		}

		// Test workaround in simpleQuery()
		tx, err := db.Begin()
		if err != nil {
			t.Fatalf("unexpected error %s in Begin", err)
		}
		defer tx.Rollback()

		_, err = tx.Exec("SET LOCAL check_function_bodies TO FALSE")
		if err != nil {
			t.Fatalf("could not disable check_function_bodies: %s", err)
		}
		_, err = tx.Exec(`
	CREATE OR REPLACE FUNCTION bad_function()
	RETURNS integer
	-- hack to prevent the function from being inlined
	SET check_function_bodies TO TRUE
	AS $$
		SELECT text 'bad'
	$$ LANGUAGE sql`)
		if err != nil {
			t.Fatalf("could not create function: %s", err)
		}

		err = tx.QueryRow("SELECT * FROM bad_function()").Scan(&a)
		if err == nil {
			t.Fatalf("expected error")
		}
		pge, ok = err.(*Error)
		if !ok {
			t.Fatalf("expected *Error; got: %#v", err)
		}
		if pge.Code.Name() != "invalid_function_definition" {
			t.Fatalf("expected invalid_function_definition; got: %s (%+v)", pge.Code.Name(), err)
		}

		err = tx.Rollback()
		if err != nil {
			t.Fatalf("unexpected error %s in Rollback", err)
		}

		// Also test that simpleQuery()'s workaround works when the query fails
		// after a row has been received.
		rows, err := db.Query(`
	select
		(select generate_series(1, ss.i))
	from (select gs.i
		  from generate_series(1, 2) gs(i)
		  order by gs.i limit 2) ss`)
		if err != nil {
			t.Fatalf("query failed: %s", err)
		}
		if !rows.Next() {
			t.Fatalf("expected at least one result row; got %s", rows.Err())
		}
		var i int
		err = rows.Scan(&i)
		if err != nil {
			t.Fatalf("rows.Scan() failed: %s", err)
		}
		if i != 1 {
			t.Fatalf("unexpected value for i: %d", i)
		}
		if rows.Next() {
			t.Fatalf("unexpected row")
		}
		pge, ok = rows.Err().(*Error)
		if !ok {
			t.Fatalf("expected *Error; got: %#v", err)
		}
		if pge.Code.Name() != "cardinality_violation" {
			t.Fatalf("expected cardinality_violation; got: %s (%+v)", pge.Code.Name(), rows.Err())
		}
	}

	func TestSimpleQuery(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		r, err := db.Query("select 1")
		if err != nil {
			t.Fatal(err)
		}
		defer r.Close()

		if !r.Next() {
			t.Fatal("expected row")
		}
	}

	func TestBindError(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		_, err := db.Exec("create temp table test (i integer)")
		if err != nil {
			t.Fatal(err)
		}

		_, err = db.Query("select * from test where i=$1", "hhh")
		if err == nil {
			t.Fatal("expected an error")
		}

		// Should not get error here
		r, err := db.Query("select * from test where i=$1", 1)
		if err != nil {
			t.Fatal(err)
		}
		defer r.Close()
	}

	func TestParseErrorInExtendedQuery(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		rows, err := db.Query("PARSE_ERROR $1", 1)
		if err == nil {
			t.Fatal("expected error")
		}

		rows, err = db.Query("SELECT 1")
		if err != nil {
			t.Fatal(err)
		}
		rows.Close()
	}

	// TestReturning tests that an INSERT query using the RETURNING clause returns a row.
	func TestReturning(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		_, err := db.Exec("CREATE TEMP TABLE distributors (did integer default 0, dname text)")
		if err != nil {
			t.Fatal(err)
		}

		rows, err := db.Query("INSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets') " +
			"RETURNING did;")
		if err != nil {
			t.Fatal(err)
		}
		if !rows.Next() {
			t.Fatal("no rows")
		}
		var did int
		err = rows.Scan(&did)
		if err != nil {
			t.Fatal(err)
		}
		if did != 0 {
			t.Fatalf("bad value for did: got %d, want %d", did, 0)
		}

		if rows.Next() {
			t.Fatal("unexpected next row")
		}
		err = rows.Err()
		if err != nil {
			t.Fatal(err)
		}
	}

	func TestIssue186(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		// Exec() a query which returns results
		_, err := db.Exec("VALUES (1), (2), (3)")
		if err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("VALUES ($1), ($2), ($3)", 1, 2, 3)
		if err != nil {
			t.Fatal(err)
		}

		// Query() a query which doesn't return any results
		txn, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		defer txn.Rollback()

		rows, err := txn.Query("CREATE TEMP TABLE foo(f1 int)")
		if err != nil {
			t.Fatal(err)
		}
		if err = rows.Close(); err != nil {
			t.Fatal(err)
		}

		// small trick to get NoData from a parameterized query
		_, err = txn.Exec("CREATE RULE nodata AS ON INSERT TO foo DO INSTEAD NOTHING")
		if err != nil {
			t.Fatal(err)
		}
		rows, err = txn.Query("INSERT INTO foo VALUES ($1)", 1)
		if err != nil {
			t.Fatal(err)
		}
		if err = rows.Close(); err != nil {
			t.Fatal(err)
		}
	}

	func TestIssue196(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		row := db.QueryRow("SELECT float4 '0.10000122' = $1, float8 '35.03554004971999' = $2",
			float32(0.10000122), float64(35.03554004971999))

		var float4match, float8match bool
		err := row.Scan(&float4match, &float8match)
		if err != nil {
			t.Fatal(err)
		}
		if !float4match {
			t.Errorf("Expected float4 fidelity to be maintained; got no match")
		}
		if !float8match {
			t.Errorf("Expected float8 fidelity to be maintained; got no match")
		}
	}

	// Test that any CommandComplete messages sent before the query results are
	// ignored.
	func TestIssue282(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		var search_path string
		err := db.QueryRow(`
			SET LOCAL search_path TO pg_catalog;
			SET LOCAL search_path TO pg_catalog;
			SHOW search_path`).Scan(&search_path)
		if err != nil {
			t.Fatal(err)
		}
		if search_path != "pg_catalog" {
			t.Fatalf("unexpected search_path %s", search_path)
		}
	}

	func TestReadFloatPrecision(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		row := db.QueryRow("SELECT float4 '0.10000122', float8 '35.03554004971999'")
		var float4val float32
		var float8val float64
		err := row.Scan(&float4val, &float8val)
		if err != nil {
			t.Fatal(err)
		}
		if float4val != float32(0.10000122) {
			t.Errorf("Expected float4 fidelity to be maintained; got no match")
		}
		if float8val != float64(35.03554004971999) {
			t.Errorf("Expected float8 fidelity to be maintained; got no match")
		}
	}

	func TestXactMultiStmt(t *testing.T) {
		// minified test case based on bug reports from
		// pico303@gmail.com and rangelspam@gmail.com
		t.Skip("Skipping failing test")
		db := openTestConn(t)
		defer db.Close()

		tx, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		defer tx.Commit()

		rows, err := tx.Query("select 1")
		if err != nil {
			t.Fatal(err)
		}

		if rows.Next() {
			var val int32
			if err = rows.Scan(&val); err != nil {
				t.Fatal(err)
			}
		} else {
			t.Fatal("Expected at least one row in first query in xact")
		}

		rows2, err := tx.Query("select 2")
		if err != nil {
			t.Fatal(err)
		}

		if rows2.Next() {
			var val2 int32
			if err := rows2.Scan(&val2); err != nil {
				t.Fatal(err)
			}
		} else {
			t.Fatal("Expected at least one row in second query in xact")
		}

		if err = rows.Err(); err != nil {
			t.Fatal(err)
		}

		if err = rows2.Err(); err != nil {
			t.Fatal(err)
		}

		if err = tx.Commit(); err != nil {
			t.Fatal(err)
		}
	}

	var envParseTests = []struct {
		Expected map[string]string
		Env      []string
	}{
		{
			Env:      []string{"PGDATABASE=hello", "PGUSER=goodbye"},
			Expected: map[string]string{"dbname": "hello", "user": "goodbye"},
		},
		{
			Env:      []string{"PGDATESTYLE=ISO, MDY"},
			Expected: map[string]string{"datestyle": "ISO, MDY"},
		},
		{
			Env:      []string{"PGCONNECT_TIMEOUT=30"},
			Expected: map[string]string{"connect_timeout": "30"},
		},
	}

	func TestParseEnviron(t *testing.T) {
		for i, tt := range envParseTests {
			results := parseEnviron(tt.Env)
			if !reflect.DeepEqual(tt.Expected, results) {
				t.Errorf("%d: Expected: %#v Got: %#v", i, tt.Expected, results)
			}
		}
	}

	func TestParseComplete(t *testing.T) {
		tpc := func(commandTag string, command string, affectedRows int64, shouldFail bool) {
			defer func() {
				if p := recover(); p != nil {
					if !shouldFail {
						t.Error(p)
					}
				}
			}()
			cn := &conn{}
			res, c := cn.parseComplete(commandTag)
			if c != command {
				t.Errorf("Expected %v, got %v", command, c)
			}
			n, err := res.RowsAffected()
			if err != nil {
				t.Fatal(err)
			}
			if n != affectedRows {
				t.Errorf("Expected %d, got %d", affectedRows, n)
			}
		}

		tpc("ALTER TABLE", "ALTER TABLE", 0, false)
		tpc("INSERT 0 1", "INSERT", 1, false)
		tpc("UPDATE 100", "UPDATE", 100, false)
		tpc("SELECT 100", "SELECT", 100, false)
		tpc("FETCH 100", "FETCH", 100, false)
		// allow COPY (and others) without row count
		tpc("COPY", "COPY", 0, false)
		// don't fail on command tags we don't recognize
		tpc("UNKNOWNCOMMANDTAG", "UNKNOWNCOMMANDTAG", 0, false)

		// failure cases
		tpc("INSERT 1", "", 0, true)   // missing oid
		tpc("UPDATE 0 1", "", 0, true) // too many numbers
		tpc("SELECT foo", "", 0, true) // invalid row count
	}

	func TestExecerInterface(t *testing.T) {
		// Gin up a straw man private struct just for the type check
		cn := &conn{c: nil}
		var cni interface{} = cn

		_, ok := cni.(driver.Execer)
		if !ok {
			t.Fatal("Driver doesn't implement Execer")
		}
	}

	func TestNullAfterNonNull(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		r, err := db.Query("SELECT 9::integer UNION SELECT NULL::integer")
		if err != nil {
			t.Fatal(err)
		}

		var n sql.NullInt64

		if !r.Next() {
			if r.Err() != nil {
				t.Fatal(err)
			}
			t.Fatal("expected row")
		}

		if err := r.Scan(&n); err != nil {
			t.Fatal(err)
		}

		if n.Int64 != 9 {
			t.Fatalf("expected 2, not %d", n.Int64)
		}

		if !r.Next() {
			if r.Err() != nil {
				t.Fatal(err)
			}
			t.Fatal("expected row")
		}

		if err := r.Scan(&n); err != nil {
			t.Fatal(err)
		}

		if n.Valid {
			t.Fatal("expected n to be invalid")
		}

		if n.Int64 != 0 {
			t.Fatalf("expected n to 2, not %d", n.Int64)
		}
	}

	func Test64BitErrorChecking(t *testing.T) {
		defer func() {
			if err := recover(); err != nil {
				t.Fatal("panic due to 0xFFFFFFFF != -1 " +
					"when int is 64 bits")
			}
		}()

		db := openTestConn(t)
		defer db.Close()

		r, err := db.Query(`SELECT *
	FROM (VALUES (0::integer, NULL::text), (1, 'test string')) AS t;`)

		if err != nil {
			t.Fatal(err)
		}

		defer r.Close()

		for r.Next() {
		}
	}

	func TestCommit(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		_, err := db.Exec("CREATE TEMP TABLE temp (a int)")
		if err != nil {
			t.Fatal(err)
		}
		sqlInsert := "INSERT INTO temp VALUES (1)"
		sqlSelect := "SELECT * FROM temp"
		tx, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		_, err = tx.Exec(sqlInsert)
		if err != nil {
			t.Fatal(err)
		}
		err = tx.Commit()
		if err != nil {
			t.Fatal(err)
		}
		var i int
		err = db.QueryRow(sqlSelect).Scan(&i)
		if err != nil {
			t.Fatal(err)
		}
		if i != 1 {
			t.Fatalf("expected 1, got %d", i)
		}
	}

	func TestErrorClass(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		_, err := db.Query("SELECT int 'notint'")
		if err == nil {
			t.Fatal("expected error")
		}
		pge, ok := err.(*Error)
		if !ok {
			t.Fatalf("expected *pq.Error, got %#+v", err)
		}
		if pge.Code.Class() != "22" {
			t.Fatalf("expected class 28, got %v", pge.Code.Class())
		}
		if pge.Code.Class().Name() != "data_exception" {
			t.Fatalf("expected data_exception, got %v", pge.Code.Class().Name())
		}
	}

	func TestParseOpts(t *testing.T) {
		tests := []struct {
			in       string
			expected values
			valid    bool
		}{
			{"dbname=hello user=goodbye", values{"dbname": "hello", "user": "goodbye"}, true},
			{"dbname=hello user=goodbye  ", values{"dbname": "hello", "user": "goodbye"}, true},
			{"dbname = hello user=goodbye", values{"dbname": "hello", "user": "goodbye"}, true},
			{"dbname=hello user =goodbye", values{"dbname": "hello", "user": "goodbye"}, true},
			{"dbname=hello user= goodbye", values{"dbname": "hello", "user": "goodbye"}, true},
			{"host=localhost password='correct horse battery staple'", values{"host": "localhost", "password": "correct horse battery staple"}, true},
			{"dbname= password=", values{"dbname": "", "password": ""}, true},
			{"dbname=hello user=''", values{"dbname": "hello", "user": ""}, true},
			{"user='' dbname=hello", values{"dbname": "hello", "user": ""}, true},
			// The last option value is an empty string if there's no non-whitespace after its =
			{"dbname=hello user=   ", values{"dbname": "hello", "user": ""}, true},

			// The parser ignores spaces after = and interprets the next set of non-whitespace characters as the value.
			{"user= password=foo", values{"user": "password=foo"}, true},

			// Backslash escapes next char
			{`user=a\ \'\\b`, values{"user": `a '\b`}, true},
			{`user='a \'b'`, values{"user": `a 'b`}, true},

			// Incomplete escape
			{`user=x\`, values{}, false},

			// No '=' after the key
			{"postgre://marko@internet", values{}, false},
			{"dbname user=goodbye", values{}, false},
			{"user=foo blah", values{}, false},
			{"user=foo blah   ", values{}, false},

			// Unterminated quoted value
			{"dbname=hello user='unterminated", values{}, false},
		}

		for _, test := range tests {
			o := make(values)
			err := parseOpts(test.in, o)

			switch {
			case err != nil && test.valid:
				t.Errorf("%q got unexpected error: %s", test.in, err)
			case err == nil && test.valid && !reflect.DeepEqual(test.expected, o):
				t.Errorf("%q got: %#v want: %#v", test.in, o, test.expected)
			case err == nil && !test.valid:
				t.Errorf("%q expected an error", test.in)
			}
		}
	}

	func TestRuntimeParameters(t *testing.T) {
		type RuntimeTestResult int
		const (
			ResultUnknown RuntimeTestResult = iota
			ResultSuccess
			ResultError // other error
		)

		tests := []struct {
			conninfo        string
			param           string
			expected        string
			expectedOutcome RuntimeTestResult
		}{
			// invalid parameter
			{"DOESNOTEXIST=foo", "", "", ResultError},
			// we can only work with a specific value for these two
			{"client_encoding=SQL_ASCII", "", "", ResultError},
			{"datestyle='ISO, YDM'", "", "", ResultError},
			// "options" should work exactly as it does in libpq
			{"options='-c search_path=pqgotest'", "search_path", "pqgotest", ResultSuccess},
			// pq should override client_encoding in this case
			{"options='-c client_encoding=SQL_ASCII'", "client_encoding", "UTF8", ResultSuccess},
			// allow client_encoding to be set explicitly
			{"client_encoding=UTF8", "client_encoding", "UTF8", ResultSuccess},
			// test a runtime parameter not supported by libpq
			{"work_mem='139kB'", "work_mem", "139kB", ResultSuccess},
			// test fallback_application_name
			{"application_name=foo fallback_application_name=bar", "application_name", "foo", ResultSuccess},
			{"application_name='' fallback_application_name=bar", "application_name", "", ResultSuccess},
			{"fallback_application_name=bar", "application_name", "bar", ResultSuccess},
		}

		for _, test := range tests {
			db, err := openTestConnConninfo(test.conninfo)
			if err != nil {
				t.Fatal(err)
			}

			// application_name didn't exist before 9.0
			if test.param == "application_name" && getServerVersion(t, db) < 90000 {
				db.Close()
				continue
			}

			tryGetParameterValue := func() (value string, outcome RuntimeTestResult) {
				defer db.Close()
				row := db.QueryRow("SELECT current_setting($1)", test.param)
				err = row.Scan(&value)
				if err != nil {
					return "", ResultError
				}
				return value, ResultSuccess
			}

			value, outcome := tryGetParameterValue()
			if outcome != test.expectedOutcome && outcome == ResultError {
				t.Fatalf("%v: unexpected error: %v", test.conninfo, err)
			}
			if outcome != test.expectedOutcome {
				t.Fatalf("unexpected outcome %v (was expecting %v) for conninfo \"%s\"",
					outcome, test.expectedOutcome, test.conninfo)
			}
			if value != test.expected {
				t.Fatalf("bad value for %s: got %s, want %s with conninfo \"%s\"",
					test.param, value, test.expected, test.conninfo)
			}
		}
	}

	func TestIsUTF8(t *testing.T) {
		var cases = []struct {
			name string
			want bool
		}{
			{"unicode", true},
			{"utf-8", true},
			{"utf_8", true},
			{"UTF-8", true},
			{"UTF8", true},
			{"utf8", true},
			{"u n ic_ode", true},
			{"ut_f%8", true},
			{"ubf8", false},
			{"punycode", false},
		}

		for _, test := range cases {
			if g := isUTF8(test.name); g != test.want {
				t.Errorf("isUTF8(%q) = %v want %v", test.name, g, test.want)
			}
		}
	}

	func TestQuoteIdentifier(t *testing.T) {
		var cases = []struct {
			input string
			want  string
		}{
			{`foo`, `"foo"`},
			{`foo bar baz`, `"foo bar baz"`},
			{`foo"bar`, `"foo""bar"`},
			{"foo\x00bar", `"foo"`},
			{"\x00foo", `""`},
		}

		for _, test := range cases {
			got := QuoteIdentifier(test.input)
			if got != test.want {
				t.Errorf("QuoteIdentifier(%q) = %v want %v", test.input, got, test.want)
			}
		}
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_copy
	package pq

	import (
		"database/sql/driver"
		"encoding/binary"
		"errors"
		"fmt"
		"sync"
	)

	var (
		errCopyInClosed               = errors.New("pq: copyin statement has already been closed")
		errBinaryCopyNotSupported     = errors.New("pq: only text format supported for COPY")
		errCopyToNotSupported         = errors.New("pq: COPY TO is not supported")
		errCopyNotSupportedOutsideTxn = errors.New("pq: COPY is only allowed inside a transaction")
	)

	// CopyIn creates a COPY FROM statement which can be prepared with
	// Tx.Prepare().  The target table should be visible in search_path.
	func CopyIn(table string, columns ...string) string {
		stmt := "COPY " + QuoteIdentifier(table) + " ("
		for i, col := range columns {
			if i != 0 {
				stmt += ", "
			}
			stmt += QuoteIdentifier(col)
		}
		stmt += ") FROM STDIN"
		return stmt
	}

	// CopyInSchema creates a COPY FROM statement which can be prepared with
	// Tx.Prepare().
	func CopyInSchema(schema, table string, columns ...string) string {
		stmt := "COPY " + QuoteIdentifier(schema) + "." + QuoteIdentifier(table) + " ("
		for i, col := range columns {
			if i != 0 {
				stmt += ", "
			}
			stmt += QuoteIdentifier(col)
		}
		stmt += ") FROM STDIN"
		return stmt
	}

	type copyin struct {
		cn      *conn
		buffer  []byte
		rowData chan []byte
		done    chan bool

		closed bool

		sync.Mutex // guards err
		err        error
	}

	const ciBufferSize = 64 * 1024

	// flush buffer before the buffer is filled up and needs reallocation
	const ciBufferFlushSize = 63 * 1024

	func (cn *conn) prepareCopyIn(q string) (_ driver.Stmt, err error) {
		if !cn.isInTransaction() {
			return nil, errCopyNotSupportedOutsideTxn
		}

		ci := &copyin{
			cn:      cn,
			buffer:  make([]byte, 0, ciBufferSize),
			rowData: make(chan []byte),
			done:    make(chan bool, 1),
		}
		// add CopyData identifier + 4 bytes for message length
		ci.buffer = append(ci.buffer, 'd', 0, 0, 0, 0)

		b := cn.writeBuf('Q')
		b.string(q)
		cn.send(b)

	awaitCopyInResponse:
		for {
			t, r := cn.recv1()
			switch t {
			case 'G':
				if r.byte() != 0 {
					err = errBinaryCopyNotSupported
					break awaitCopyInResponse
				}
				go ci.resploop()
				return ci, nil
			case 'H':
				err = errCopyToNotSupported
				break awaitCopyInResponse
			case 'E':
				err = parseError(r)
			case 'Z':
				if err == nil {
					cn.bad = true
					errorf("unexpected ReadyForQuery in response to COPY")
				}
				cn.processReadyForQuery(r)
				return nil, err
			default:
				cn.bad = true
				errorf("unknown response for copy query: %q", t)
			}
		}

		// something went wrong, abort COPY before we return
		b = cn.writeBuf('f')
		b.string(err.Error())
		cn.send(b)

		for {
			t, r := cn.recv1()
			switch t {
			case 'c', 'C', 'E':
			case 'Z':
				// correctly aborted, we're done
				cn.processReadyForQuery(r)
				return nil, err
			default:
				cn.bad = true
				errorf("unknown response for CopyFail: %q", t)
			}
		}
	}

	func (ci *copyin) flush(buf []byte) {
		// set message length (without message identifier)
		binary.BigEndian.PutUint32(buf[1:], uint32(len(buf)-1))

		_, err := ci.cn.c.Write(buf)
		if err != nil {
			panic(err)
		}
	}

	func (ci *copyin) resploop() {
		for {
			var r readBuf
			t, err := ci.cn.recvMessage(&r)
			if err != nil {
				ci.cn.bad = true
				ci.setError(err)
				ci.done <- true
				return
			}
			switch t {
			case 'C':
				// complete
			case 'Z':
				ci.cn.processReadyForQuery(&r)
				ci.done <- true
				return
			case 'E':
				err := parseError(&r)
				ci.setError(err)
			default:
				ci.cn.bad = true
				ci.setError(fmt.Errorf("unknown response during CopyIn: %q", t))
				ci.done <- true
				return
			}
		}
	}

	func (ci *copyin) isErrorSet() bool {
		ci.Lock()
		isSet := (ci.err != nil)
		ci.Unlock()
		return isSet
	}

	// setError() sets ci.err if one has not been set already.  Caller must not be
	// holding ci.Mutex.
	func (ci *copyin) setError(err error) {
		ci.Lock()
		if ci.err == nil {
			ci.err = err
		}
		ci.Unlock()
	}

	func (ci *copyin) NumInput() int {
		return -1
	}

	func (ci *copyin) Query(v []driver.Value) (r driver.Rows, err error) {
		return nil, ErrNotSupported
	}

	// Exec inserts values into the COPY stream. The insert is asynchronous
	// and Exec can return errors from previous Exec calls to the same
	// COPY stmt.
	//
	// You need to call Exec(nil) to sync the COPY stream and to get any
	// errors from pending data, since Stmt.Close() doesn't return errors
	// to the user.
	func (ci *copyin) Exec(v []driver.Value) (r driver.Result, err error) {
		if ci.closed {
			return nil, errCopyInClosed
		}

		if ci.cn.bad {
			return nil, driver.ErrBadConn
		}
		defer ci.cn.errRecover(&err)

		if ci.isErrorSet() {
			return nil, ci.err
		}

		if len(v) == 0 {
			err = ci.Close()
			ci.closed = true
			return nil, err
		}

		numValues := len(v)
		for i, value := range v {
			ci.buffer = appendEncodedText(&ci.cn.parameterStatus, ci.buffer, value)
			if i < numValues-1 {
				ci.buffer = append(ci.buffer, '\t')
			}
		}

		ci.buffer = append(ci.buffer, '\n')

		if len(ci.buffer) > ciBufferFlushSize {
			ci.flush(ci.buffer)
			// reset buffer, keep bytes for message identifier and length
			ci.buffer = ci.buffer[:5]
		}

		return driver.RowsAffected(0), nil
	}

	func (ci *copyin) Close() (err error) {
		if ci.closed {
			return errCopyInClosed
		}

		if ci.cn.bad {
			return driver.ErrBadConn
		}
		defer ci.cn.errRecover(&err)

		if len(ci.buffer) > 0 {
			ci.flush(ci.buffer)
		}
		// Avoid touching the scratch buffer as resploop could be using it.
		err = ci.cn.sendSimpleMessage('c')
		if err != nil {
			return err
		}

		<-ci.done

		if ci.isErrorSet() {
			err = ci.err
			return err
		}
		return nil
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_copy_test
	package pq

	import (
		"bytes"
		"database/sql"
		"strings"
		"testing"
	)

	func TestCopyInStmt(t *testing.T) {
		var stmt string
		stmt = CopyIn("table name")
		if stmt != `COPY "table name" () FROM STDIN` {
			t.Fatal(stmt)
		}

		stmt = CopyIn("table name", "column 1", "column 2")
		if stmt != `COPY "table name" ("column 1", "column 2") FROM STDIN` {
			t.Fatal(stmt)
		}

		stmt = CopyIn(`table " name """`, `co"lumn""`)
		if stmt != `COPY "table "" name """"""" ("co""lumn""""") FROM STDIN` {
			t.Fatal(stmt)
		}
	}

	func TestCopyInSchemaStmt(t *testing.T) {
		var stmt string
		stmt = CopyInSchema("schema name", "table name")
		if stmt != `COPY "schema name"."table name" () FROM STDIN` {
			t.Fatal(stmt)
		}

		stmt = CopyInSchema("schema name", "table name", "column 1", "column 2")
		if stmt != `COPY "schema name"."table name" ("column 1", "column 2") FROM STDIN` {
			t.Fatal(stmt)
		}

		stmt = CopyInSchema(`schema " name """`, `table " name """`, `co"lumn""`)
		if stmt != `COPY "schema "" name """"""".`+
			`"table "" name """"""" ("co""lumn""""") FROM STDIN` {
			t.Fatal(stmt)
		}
	}

	func TestCopyInMultipleValues(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		txn, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		defer txn.Rollback()

		_, err = txn.Exec("CREATE TEMP TABLE temp (a int, b varchar)")
		if err != nil {
			t.Fatal(err)
		}

		stmt, err := txn.Prepare(CopyIn("temp", "a", "b"))
		if err != nil {
			t.Fatal(err)
		}

		longString := strings.Repeat("#", 500)

		for i := 0; i < 500; i++ {
			_, err = stmt.Exec(int64(i), longString)
			if err != nil {
				t.Fatal(err)
			}
		}

		_, err = stmt.Exec()
		if err != nil {
			t.Fatal(err)
		}

		err = stmt.Close()
		if err != nil {
			t.Fatal(err)
		}

		var num int
		err = txn.QueryRow("SELECT COUNT(*) FROM temp").Scan(&num)
		if err != nil {
			t.Fatal(err)
		}

		if num != 500 {
			t.Fatalf("expected 500 items, not %d", num)
		}
	}

	func TestCopyInTypes(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		txn, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		defer txn.Rollback()

		_, err = txn.Exec("CREATE TEMP TABLE temp (num INTEGER, text VARCHAR, blob BYTEA, nothing VARCHAR)")
		if err != nil {
			t.Fatal(err)
		}

		stmt, err := txn.Prepare(CopyIn("temp", "num", "text", "blob", "nothing"))
		if err != nil {
			t.Fatal(err)
		}

		_, err = stmt.Exec(int64(1234567890), "Hll\n !\r\t\\", []byte{0, 255, 9, 10, 13}, nil)
		if err != nil {
			t.Fatal(err)
		}

		_, err = stmt.Exec()
		if err != nil {
			t.Fatal(err)
		}

		err = stmt.Close()
		if err != nil {
			t.Fatal(err)
		}

		var num int
		var text string
		var blob []byte
		var nothing sql.NullString

		err = txn.QueryRow("SELECT * FROM temp").Scan(&num, &text, &blob, &nothing)
		if err != nil {
			t.Fatal(err)
		}

		if num != 1234567890 {
			t.Fatal("unexpected result", num)
		}
		if text != "Hll\n !\r\t\\" {
			t.Fatal("unexpected result", text)
		}
		if bytes.Compare(blob, []byte{0, 255, 9, 10, 13}) != 0 {
			t.Fatal("unexpected result", blob)
		}
		if nothing.Valid {
			t.Fatal("unexpected result", nothing.String)
		}
	}

	func TestCopyInWrongType(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		txn, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		defer txn.Rollback()

		_, err = txn.Exec("CREATE TEMP TABLE temp (num INTEGER)")
		if err != nil {
			t.Fatal(err)
		}

		stmt, err := txn.Prepare(CopyIn("temp", "num"))
		if err != nil {
			t.Fatal(err)
		}
		defer stmt.Close()

		_, err = stmt.Exec("Hll\n !\r\t\\")
		if err != nil {
			t.Fatal(err)
		}

		_, err = stmt.Exec()
		if err == nil {
			t.Fatal("expected error")
		}
		if pge := err.(*Error); pge.Code.Name() != "invalid_text_representation" {
			t.Fatalf("expected 'invalid input syntax for integer' error, got %s (%+v)", pge.Code.Name(), pge)
		}
	}

	func TestCopyOutsideOfTxnError(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		_, err := db.Prepare(CopyIn("temp", "num"))
		if err == nil {
			t.Fatal("COPY outside of transaction did not return an error")
		}
		if err != errCopyNotSupportedOutsideTxn {
			t.Fatalf("expected %s, got %s", err, err.Error())
		}
	}

	func TestCopyInBinaryError(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		txn, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		defer txn.Rollback()

		_, err = txn.Exec("CREATE TEMP TABLE temp (num INTEGER)")
		if err != nil {
			t.Fatal(err)
		}
		_, err = txn.Prepare("COPY temp (num) FROM STDIN WITH binary")
		if err != errBinaryCopyNotSupported {
			t.Fatalf("expected %s, got %+v", errBinaryCopyNotSupported, err)
		}
		// check that the protocol is in a valid state
		err = txn.Rollback()
		if err != nil {
			t.Fatal(err)
		}
	}

	func TestCopyFromError(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		txn, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		defer txn.Rollback()

		_, err = txn.Exec("CREATE TEMP TABLE temp (num INTEGER)")
		if err != nil {
			t.Fatal(err)
		}
		_, err = txn.Prepare("COPY temp (num) TO STDOUT")
		if err != errCopyToNotSupported {
			t.Fatalf("expected %s, got %+v", errCopyToNotSupported, err)
		}
		// check that the protocol is in a valid state
		err = txn.Rollback()
		if err != nil {
			t.Fatal(err)
		}
	}

	func TestCopySyntaxError(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		txn, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		defer txn.Rollback()

		_, err = txn.Prepare("COPY ")
		if err == nil {
			t.Fatal("expected error")
		}
		if pge := err.(*Error); pge.Code.Name() != "syntax_error" {
			t.Fatalf("expected syntax error, got %s (%+v)", pge.Code.Name(), pge)
		}
		// check that the protocol is in a valid state
		err = txn.Rollback()
		if err != nil {
			t.Fatal(err)
		}
	}

	// Tests for connection errors in copyin.resploop()
	func TestCopyRespLoopConnectionError(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		txn, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		defer txn.Rollback()

		var pid int
		err = txn.QueryRow("SELECT pg_backend_pid()").Scan(&pid)
		if err != nil {
			t.Fatal(err)
		}

		_, err = txn.Exec("CREATE TEMP TABLE temp (a int)")
		if err != nil {
			t.Fatal(err)
		}

		stmt, err := txn.Prepare(CopyIn("temp", "a"))
		if err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("SELECT pg_terminate_backend($1)", pid)
		if err != nil {
			t.Fatal(err)
		}

		// We have to try and send something over, since postgres won't process
		// SIGTERMs while it's waiting for CopyData/CopyEnd messages; see
		// tcop/postgres.c.
		_, err = stmt.Exec(1)
		if err != nil {
			t.Fatal(err)
		}
		_, err = stmt.Exec()
		if err == nil {
			t.Fatalf("expected error")
		}
		pge, ok := err.(*Error)
		if !ok {
			t.Fatalf("expected *pq.Error, got %+#v", err)
		} else if pge.Code.Name() != "admin_shutdown" {
			t.Fatalf("expected admin_shutdown, got %s", pge.Code.Name())
		}

		err = stmt.Close()
		if err != nil {
			t.Fatal(err)
		}
	}

	func BenchmarkCopyIn(b *testing.B) {
		db := openTestConn(b)
		defer db.Close()

		txn, err := db.Begin()
		if err != nil {
			b.Fatal(err)
		}
		defer txn.Rollback()

		_, err = txn.Exec("CREATE TEMP TABLE temp (a int, b varchar)")
		if err != nil {
			b.Fatal(err)
		}

		stmt, err := txn.Prepare(CopyIn("temp", "a", "b"))
		if err != nil {
			b.Fatal(err)
		}

		for i := 0; i < b.N; i++ {
			_, err = stmt.Exec(int64(i), "hello world!")
			if err != nil {
				b.Fatal(err)
			}
		}

		_, err = stmt.Exec()
		if err != nil {
			b.Fatal(err)
		}

		err = stmt.Close()
		if err != nil {
			b.Fatal(err)
		}

		var num int
		err = txn.QueryRow("SELECT COUNT(*) FROM temp").Scan(&num)
		if err != nil {
			b.Fatal(err)
		}

		if num != b.N {
			b.Fatalf("expected %d items, not %d", b.N, num)
		}
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_doc
	/*
	Package pq is a pure Go Postgres driver for the database/sql package.

	In most cases clients will use the database/sql package instead of
	using this package directly. For example:

		import (
			"database/sql"

			_ "github.com/lib/pq"
		)

		func main() {
			db, err := sql.Open("postgres", "user=pqgotest dbname=pqgotest sslmode=verify-full")
			if err != nil {
				log.Fatal(err)
			}

			age := 21
			rows, err := db.Query("SELECT name FROM users WHERE age = $1", age)
			
		}

	You can also connect to a database using a URL. For example:

		db, err := sql.Open("postgres", "postgres://pqgotest:password@localhost/pqgotest?sslmode=verify-full")


	Connection String Parameters


	Similarly to libpq, when establishing a connection using pq you are expected to
	supply a connection string containing zero or more parameters.
	A subset of the connection parameters supported by libpq are also supported by pq.
	Additionally, pq also lets you specify run-time parameters (such as search_path or work_mem)
	directly in the connection string.  This is different from libpq, which does not allow
	run-time parameters in the connection string, instead requiring you to supply
	them in the options parameter.

	For compatibility with libpq, the following special connection parameters are
	supported:

		* dbname - The name of the database to connect to
		* user - The user to sign in as
		* password - The user's password
		* host - The host to connect to. Values that start with / are for unix domain sockets. (default is localhost)
		* port - The port to bind to. (default is 5432)
		* sslmode - Whether or not to use SSL (default is require, this is not the default for libpq)
		* fallback_application_name - An application_name to fall back to if one isn't provided.
		* connect_timeout - Maximum wait for connection, in seconds. Zero or not specified means wait indefinitely.
		* sslcert - Cert file location. The file must contain PEM encoded data.
		* sslkey - Key file location. The file must contain PEM encoded data.
		* sslrootcert - The location of the root certificate file. The file must contain PEM encoded data.

	Valid values for sslmode are:

		* disable - No SSL
		* require - Always SSL (skip verification)
		* verify-ca - Always SSL (verify that the certificate presented by the server was signed by a trusted CA)
		* verify-full - Always SSL (verify that the certification presented by the server was signed by a trusted CA and the server host name matches the one in the certificate)

	See http://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-CONNSTRING
	for more information about connection string parameters.

	Use single quotes for values that contain whitespace:

		"user=pqgotest password='with spaces'"

	A backslash will escape the next character in values:

		"user=space\ man password='it\'s valid'

	Note that the connection parameter client_encoding (which sets the
	text encoding for the connection) may be set but must be "UTF8",
	matching with the same rules as Postgres. It is an error to provide
	any other value.

	In addition to the parameters listed above, any run-time parameter that can be
	set at backend start time can be set in the connection string.  For more
	information, see
	http://www.postgresql.org/docs/current/static/runtime-config.html.

	Most environment variables as specified at http://www.postgresql.org/docs/current/static/libpq-envars.html
	supported by libpq are also supported by pq.  If any of the environment
	variables not supported by pq are set, pq will panic during connection
	establishment.  Environment variables have a lower precedence than explicitly
	provided connection parameters.


	Queries

	database/sql does not dictate any specific format for parameter
	markers in query strings, and pq uses the Postgres-native ordinal markers,
	as shown above. The same marker can be reused for the same parameter:

		rows, err := db.Query(`SELECT name FROM users WHERE favorite_fruit = $1
			OR age BETWEEN $2 AND $2 + 3`, "orange", 64)

	pq does not support the LastInsertId() method of the Result type in database/sql.
	To return the identifier of an INSERT (or UPDATE or DELETE), use the Postgres
	RETURNING clause with a standard Query or QueryRow call:

		var userid int
		err := db.QueryRow(`INSERT INTO users(name, favorite_fruit, age)
			VALUES('beatrice', 'starfruit', 93) RETURNING id`).Scan(&userid)

	For more details on RETURNING, see the Postgres documentation:

		http://www.postgresql.org/docs/current/static/sql-insert.html
		http://www.postgresql.org/docs/current/static/sql-update.html
		http://www.postgresql.org/docs/current/static/sql-delete.html

	For additional instructions on querying see the documentation for the database/sql package.

	Errors

	pq may return errors of type *pq.Error which can be interrogated for error details:

			if err, ok := err.(*pq.Error); ok {
				fmt.Println("pq error:", err.Code.Name())
			}

	See the pq.Error type for details.


	Bulk imports

	You can perform bulk imports by preparing a statement returned by pq.CopyIn (or
	pq.CopyInSchema) in an explicit transaction (sql.Tx). The returned statement
	handle can then be repeatedly "executed" to copy data into the target table.
	After all data has been processed you should call Exec() once with no arguments
	to flush all buffered data. Any call to Exec() might return an error which
	should be handled appropriately, but because of the internal buffering an error
	returned by Exec() might not be related to the data passed in the call that
	failed.

	CopyIn uses COPY FROM internally. It is not possible to COPY outside of an
	explicit transaction in pq.

	Usage example:

		txn, err := db.Begin()
		if err != nil {
			log.Fatal(err)
		}

		stmt, err := txn.Prepare(pq.CopyIn("users", "name", "age"))
		if err != nil {
			log.Fatal(err)
		}

		for _, user := range users {
			_, err = stmt.Exec(user.Name, int64(user.Age))
			if err != nil {
				log.Fatal(err)
			}
		}

		_, err = stmt.Exec()
		if err != nil {
			log.Fatal(err)
		}

		err = stmt.Close()
		if err != nil {
			log.Fatal(err)
		}

		err = txn.Commit()
		if err != nil {
			log.Fatal(err)
		}


	Notifications


	PostgreSQL supports a simple publish/subscribe model over database
	connections.  See http://www.postgresql.org/docs/current/static/sql-notify.html
	for more information about the general mechanism.

	To start listening for notifications, you first have to open a new connection
	to the database by calling NewListener.  This connection can not be used for
	anything other than LISTEN / NOTIFY.  Calling Listen will open a "notification
	channel"; once a notification channel is open, a notification generated on that
	channel will effect a send on the Listener.Notify channel.  A notification
	channel will remain open until Unlisten is called, though connection loss might
	result in some notifications being lost.  To solve this problem, Listener sends
	a nil pointer over the Notify channel any time the connection is re-established
	following a connection loss.  The application can get information about the
	state of the underlying connection by setting an event callback in the call to
	NewListener.

	A single Listener can safely be used from concurrent goroutines, which means
	that there is often no need to create more than one Listener in your
	application.  However, a Listener is always connected to a single database, so
	you will need to create a new Listener instance for every database you want to
	receive notifications in.

	The channel name in both Listen and Unlisten is case sensitive, and can contain
	any characters legal in an identifier (see
	http://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS
	for more information).  Note that the channel name will be truncated to 63
	bytes by the PostgreSQL server.

	You can find a complete, working example of Listener usage at
	http://godoc.org/github.com/lib/pq/listen_example.

	*/
	package pq


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_encode
	package pq

	import (
		"bytes"
		"database/sql/driver"
		"encoding/hex"
		"fmt"
		"math"
		"strconv"
		"strings"
		"sync"
		"time"

		"github.com/lib/pq/oid"
	)

	func encode(parameterStatus *parameterStatus, x interface{}, pgtypOid oid.Oid) []byte {
		switch v := x.(type) {
		case int64:
			return []byte(fmt.Sprintf("%d", v))
		case float32:
			return []byte(fmt.Sprintf("%.9f", v))
		case float64:
			return []byte(fmt.Sprintf("%.17f", v))
		case []byte:
			if pgtypOid == oid.T_bytea {
				return encodeBytea(parameterStatus.serverVersion, v)
			}

			return v
		case string:
			if pgtypOid == oid.T_bytea {
				return encodeBytea(parameterStatus.serverVersion, []byte(v))
			}

			return []byte(v)
		case bool:
			return []byte(fmt.Sprintf("%t", v))
		case time.Time:
			return formatTs(v)

		default:
			errorf("encode: unknown type for %T", v)
		}

		panic("not reached")
	}

	func decode(parameterStatus *parameterStatus, s []byte, typ oid.Oid) interface{} {
		switch typ {
		case oid.T_bytea:
			return parseBytea(s)
		case oid.T_timestamptz:
			return parseTs(parameterStatus.currentLocation, string(s))
		case oid.T_timestamp, oid.T_date:
			return parseTs(nil, string(s))
		case oid.T_time:
			return mustParse("15:04:05", typ, s)
		case oid.T_timetz:
			return mustParse("15:04:05-07", typ, s)
		case oid.T_bool:
			return s[0] == 't'
		case oid.T_int8, oid.T_int2, oid.T_int4:
			i, err := strconv.ParseInt(string(s), 10, 64)
			if err != nil {
				errorf("%s", err)
			}
			return i
		case oid.T_float4, oid.T_float8:
			bits := 64
			if typ == oid.T_float4 {
				bits = 32
			}
			f, err := strconv.ParseFloat(string(s), bits)
			if err != nil {
				errorf("%s", err)
			}
			return f
		}

		return s
	}

	// appendEncodedText encodes item in text format as required by COPY
	// and appends to buf
	func appendEncodedText(parameterStatus *parameterStatus, buf []byte, x interface{}) []byte {
		switch v := x.(type) {
		case int64:
			return strconv.AppendInt(buf, v, 10)
		case float32:
			return strconv.AppendFloat(buf, float64(v), 'f', -1, 32)
		case float64:
			return strconv.AppendFloat(buf, v, 'f', -1, 64)
		case []byte:
			encodedBytea := encodeBytea(parameterStatus.serverVersion, v)
			return appendEscapedText(buf, string(encodedBytea))
		case string:
			return appendEscapedText(buf, v)
		case bool:
			return strconv.AppendBool(buf, v)
		case time.Time:
			return append(buf, formatTs(v)...)
		case nil:
			return append(buf, "\\N"...)
		default:
			errorf("encode: unknown type for %T", v)
		}

		panic("not reached")
	}

	func appendEscapedText(buf []byte, text string) []byte {
		escapeNeeded := false
		startPos := 0
		var c byte

		// check if we need to escape
		for i := 0; i < len(text); i++ {
			c = text[i]
			if c == '\\' || c == '\n' || c == '\r' || c == '\t' {
				escapeNeeded = true
				startPos = i
				break
			}
		}
		if !escapeNeeded {
			return append(buf, text...)
		}

		// copy till first char to escape, iterate the rest
		result := append(buf, text[:startPos]...)
		for i := startPos; i < len(text); i++ {
			c = text[i]
			switch c {
			case '\\':
				result = append(result, '\\', '\\')
			case '\n':
				result = append(result, '\\', 'n')
			case '\r':
				result = append(result, '\\', 'r')
			case '\t':
				result = append(result, '\\', 't')
			default:
				result = append(result, c)
			}
		}
		return result
	}

	func mustParse(f string, typ oid.Oid, s []byte) time.Time {
		str := string(s)

		// check for a 30-minute-offset timezone
		if (typ == oid.T_timestamptz || typ == oid.T_timetz) &&
			str[len(str)-3] == ':' {
			f += ":00"
		}
		t, err := time.Parse(f, str)
		if err != nil {
			errorf("decode: %s", err)
		}
		return t
	}

	func expect(str, char string, pos int) {
		if c := str[pos : pos+1]; c != char {
			errorf("expected '%v' at position %v; got '%v'", char, pos, c)
		}
	}

	func mustAtoi(str string) int {
		result, err := strconv.Atoi(str)
		if err != nil {
			errorf("expected number; got '%v'", str)
		}
		return result
	}

	// The location cache caches the time zones typically used by the client.
	type locationCache struct {
		cache map[int]*time.Location
		lock  sync.Mutex
	}

	// All connections share the same list of timezones. Benchmarking shows that
	// about 5% speed could be gained by putting the cache in the connection and
	// losing the mutex, at the cost of a small amount of memory and a somewhat
	// significant increase in code complexity.
	var globalLocationCache *locationCache = newLocationCache()

	func newLocationCache() *locationCache {
		return &locationCache{cache: make(map[int]*time.Location)}
	}

	// Returns the cached timezone for the specified offset, creating and caching
	// it if necessary.
	func (c *locationCache) getLocation(offset int) *time.Location {
		c.lock.Lock()
		defer c.lock.Unlock()

		location, ok := c.cache[offset]
		if !ok {
			location = time.FixedZone("", offset)
			c.cache[offset] = location
		}

		return location
	}

	var infinityTsEnabled = false
	var infinityTsNegative time.Time
	var infinityTsPositive time.Time

	const (
		infinityTsEnabledAlready        = "pq: infinity timestamp enabled already"
		infinityTsNegativeMustBeSmaller = "pq: infinity timestamp: negative value must be smaller (before) than positive"
	)

	/*
	 * If EnableInfinityTs is not called, "-infinity" and "infinity" will return
	 * []byte("-infinity") and []byte("infinity") respectively, and potentially
	 * cause error "sql: Scan error on column index 0: unsupported driver -> Scan pair: []uint8 -> *time.Time",
	 * when scanning into a time.Time value.
	 *
	 * Once EnableInfinityTs has been called, all connections created using this
	 * driver will decode Postgres' "-infinity" and "infinity" for "timestamp",
	 * "timestamp with time zone" and "date" types to the predefined minimum and
	 * maximum times, respectively.  When encoding time.Time values, any time which
	 * equals or preceeds the predefined minimum time will be encoded to
	 * "-infinity".  Any values at or past the maximum time will similarly be
	 * encoded to "infinity".
	 *
	 *
	 * If EnableInfinityTs is called with negative >= positive, it will panic.
	 * Calling EnableInfinityTs after a connection has been established results in
	 * undefined behavior.  If EnableInfinityTs is called more than once, it will
	 * panic.
	 */
	func EnableInfinityTs(negative time.Time, positive time.Time) {
		if infinityTsEnabled {
			panic(infinityTsEnabledAlready)
		}
		if !negative.Before(positive) {
			panic(infinityTsNegativeMustBeSmaller)
		}
		infinityTsEnabled = true
		infinityTsNegative = negative
		infinityTsPositive = positive
	}

	/*
	 * Testing might want to toggle infinityTsEnabled
	 */
	func disableInfinityTs() {
		infinityTsEnabled = false
	}

	// This is a time function specific to the Postgres default DateStyle
	// setting ("ISO, MDY"), the only one we currently support. This
	// accounts for the discrepancies between the parsing available with
	// time.Parse and the Postgres date formatting quirks.
	func parseTs(currentLocation *time.Location, str string) interface{} {
		switch str {
		case "-infinity":
			if infinityTsEnabled {
				return infinityTsNegative
			}
			return []byte(str)
		case "infinity":
			if infinityTsEnabled {
				return infinityTsPositive
			}
			return []byte(str)
		}

		monSep := strings.IndexRune(str, '-')
		// this is Gregorian year, not ISO Year
		// In Gregorian system, the year 1 BC is followed by AD 1
		year := mustAtoi(str[:monSep])
		daySep := monSep + 3
		month := mustAtoi(str[monSep+1 : daySep])
		expect(str, "-", daySep)
		timeSep := daySep + 3
		day := mustAtoi(str[daySep+1 : timeSep])

		var hour, minute, second int
		if len(str) > monSep+len("01-01")+1 {
			expect(str, " ", timeSep)
			minSep := timeSep + 3
			expect(str, ":", minSep)
			hour = mustAtoi(str[timeSep+1 : minSep])
			secSep := minSep + 3
			expect(str, ":", secSep)
			minute = mustAtoi(str[minSep+1 : secSep])
			secEnd := secSep + 3
			second = mustAtoi(str[secSep+1 : secEnd])
		}
		remainderIdx := monSep + len("01-01 00:00:00") + 1
		// Three optional (but ordered) sections follow: the
		// fractional seconds, the time zone offset, and the BC
		// designation. We set them up here and adjust the other
		// offsets if the preceding sections exist.

		nanoSec := 0
		tzOff := 0

		if remainderIdx < len(str) && str[remainderIdx:remainderIdx+1] == "." {
			fracStart := remainderIdx + 1
			fracOff := strings.IndexAny(str[fracStart:], "-+ ")
			if fracOff < 0 {
				fracOff = len(str) - fracStart
			}
			fracSec := mustAtoi(str[fracStart : fracStart+fracOff])
			nanoSec = fracSec * (1000000000 / int(math.Pow(10, float64(fracOff))))

			remainderIdx += fracOff + 1
		}
		if tzStart := remainderIdx; tzStart < len(str) && (str[tzStart:tzStart+1] == "-" || str[tzStart:tzStart+1] == "+") {
			// time zone separator is always '-' or '+' (UTC is +00)
			var tzSign int
			if c := str[tzStart : tzStart+1]; c == "-" {
				tzSign = -1
			} else if c == "+" {
				tzSign = +1
			} else {
				errorf("expected '-' or '+' at position %v; got %v", tzStart, c)
			}
			tzHours := mustAtoi(str[tzStart+1 : tzStart+3])
			remainderIdx += 3
			var tzMin, tzSec int
			if tzStart+3 < len(str) && str[tzStart+3:tzStart+4] == ":" {
				tzMin = mustAtoi(str[tzStart+4 : tzStart+6])
				remainderIdx += 3
			}
			if tzStart+6 < len(str) && str[tzStart+6:tzStart+7] == ":" {
				tzSec = mustAtoi(str[tzStart+7 : tzStart+9])
				remainderIdx += 3
			}
			tzOff = tzSign * ((tzHours * 60 * 60) + (tzMin * 60) + tzSec)
		}
		var isoYear int
		if remainderIdx < len(str) && str[remainderIdx:remainderIdx+3] == " BC" {
			isoYear = 1 - year
			remainderIdx += 3
		} else {
			isoYear = year
		}
		if remainderIdx < len(str) {
			errorf("expected end of input, got %v", str[remainderIdx:])
		}
		t := time.Date(isoYear, time.Month(month), day,
			hour, minute, second, nanoSec,
			globalLocationCache.getLocation(tzOff))

		if currentLocation != nil {
			// Set the location of the returned Time based on the session's
			// TimeZone value, but only if the local time zone database agrees with
			// the remote database on the offset.
			lt := t.In(currentLocation)
			_, newOff := lt.Zone()
			if newOff == tzOff {
				t = lt
			}
		}

		return t
	}

	// formatTs formats t into a format postgres understands.
	func formatTs(t time.Time) (b []byte) {
		if infinityTsEnabled {
			// t <= -infinity : ! (t > -infinity)
			if !t.After(infinityTsNegative) {
				return []byte("-infinity")
			}
			// t >= infinity : ! (!t < infinity)
			if !t.Before(infinityTsPositive) {
				return []byte("infinity")
			}
		}
		// Need to send dates before 0001 A.D. with " BC" suffix, instead of the
		// minus sign preferred by Go.
		// Beware, "0000" in ISO is "1 BC", "-0001" is "2 BC" and so on
		bc := false
		if t.Year() <= 0 {
			// flip year sign, and add 1, e.g: "0" will be "1", and "-10" will be "11"
			t = t.AddDate((-t.Year())*2+1, 0, 0)
			bc = true
		}
		b = []byte(t.Format(time.RFC3339Nano))

		_, offset := t.Zone()
		offset = offset % 60
		if offset != 0 {
			// RFC3339Nano already printed the minus sign
			if offset < 0 {
				offset = -offset
			}

			b = append(b, ':')
			if offset < 10 {
				b = append(b, '0')
			}
			b = strconv.AppendInt(b, int64(offset), 10)
		}

		if bc {
			b = append(b, " BC"...)
		}
		return b
	}

	// Parse a bytea value received from the server.  Both "hex" and the legacy
	// "escape" format are supported.
	func parseBytea(s []byte) (result []byte) {
		if len(s) >= 2 && bytes.Equal(s[:2], []byte("\\x")) {
			// bytea_output = hex
			s = s[2:] // trim off leading "\\x"
			result = make([]byte, hex.DecodedLen(len(s)))
			_, err := hex.Decode(result, s)
			if err != nil {
				errorf("%s", err)
			}
		} else {
			// bytea_output = escape
			for len(s) > 0 {
				if s[0] == '\\' {
					// escaped '\\'
					if len(s) >= 2 && s[1] == '\\' {
						result = append(result, '\\')
						s = s[2:]
						continue
					}

					// '\\' followed by an octal number
					if len(s) < 4 {
						errorf("invalid bytea sequence %v", s)
					}
					r, err := strconv.ParseInt(string(s[1:4]), 8, 9)
					if err != nil {
						errorf("could not parse bytea value: %s", err.Error())
					}
					result = append(result, byte(r))
					s = s[4:]
				} else {
					// We hit an unescaped, raw byte.  Try to read in as many as
					// possible in one go.
					i := bytes.IndexByte(s, '\\')
					if i == -1 {
						result = append(result, s...)
						break
					}
					result = append(result, s[:i]...)
					s = s[i:]
				}
			}
		}

		return result
	}

	func encodeBytea(serverVersion int, v []byte) (result []byte) {
		if serverVersion >= 90000 {
			// Use the hex format if we know that the server supports it
			result = make([]byte, 2+hex.EncodedLen(len(v)))
			result[0] = '\\'
			result[1] = 'x'
			hex.Encode(result[2:], v)
		} else {
			// .. or resort to "escape"
			for _, b := range v {
				if b == '\\' {
					result = append(result, '\\', '\\')
				} else if b < 0x20 || b > 0x7e {
					result = append(result, []byte(fmt.Sprintf("\\%03o", b))...)
				} else {
					result = append(result, b)
				}
			}
		}

		return result
	}

	// NullTime represents a time.Time that may be null. NullTime implements the
	// sql.Scanner interface so it can be used as a scan destination, similar to
	// sql.NullString.
	type NullTime struct {
		Time  time.Time
		Valid bool // Valid is true if Time is not NULL
	}

	// Scan implements the Scanner interface.
	func (nt *NullTime) Scan(value interface{}) error {
		nt.Time, nt.Valid = value.(time.Time)
		return nil
	}

	// Value implements the driver Valuer interface.
	func (nt NullTime) Value() (driver.Value, error) {
		if !nt.Valid {
			return nil, nil
		}
		return nt.Time, nil
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_encode_test
	package pq

	import (
		"bytes"
		"fmt"
		"testing"
		"time"

		"github.com/lib/pq/oid"
	)

	func TestScanTimestamp(t *testing.T) {
		var nt NullTime
		tn := time.Now()
		nt.Scan(tn)
		if !nt.Valid {
			t.Errorf("Expected Valid=false")
		}
		if nt.Time != tn {
			t.Errorf("Time value mismatch")
		}
	}

	func TestScanNilTimestamp(t *testing.T) {
		var nt NullTime
		nt.Scan(nil)
		if nt.Valid {
			t.Errorf("Expected Valid=false")
		}
	}

	var timeTests = []struct {
		str     string
		timeval time.Time
	}{
		{"22001-02-03", time.Date(22001, time.February, 3, 0, 0, 0, 0, time.FixedZone("", 0))},
		{"2001-02-03", time.Date(2001, time.February, 3, 0, 0, 0, 0, time.FixedZone("", 0))},
		{"2001-02-03 04:05:06", time.Date(2001, time.February, 3, 4, 5, 6, 0, time.FixedZone("", 0))},
		{"2001-02-03 04:05:06.000001", time.Date(2001, time.February, 3, 4, 5, 6, 1000, time.FixedZone("", 0))},
		{"2001-02-03 04:05:06.00001", time.Date(2001, time.February, 3, 4, 5, 6, 10000, time.FixedZone("", 0))},
		{"2001-02-03 04:05:06.0001", time.Date(2001, time.February, 3, 4, 5, 6, 100000, time.FixedZone("", 0))},
		{"2001-02-03 04:05:06.001", time.Date(2001, time.February, 3, 4, 5, 6, 1000000, time.FixedZone("", 0))},
		{"2001-02-03 04:05:06.01", time.Date(2001, time.February, 3, 4, 5, 6, 10000000, time.FixedZone("", 0))},
		{"2001-02-03 04:05:06.1", time.Date(2001, time.February, 3, 4, 5, 6, 100000000, time.FixedZone("", 0))},
		{"2001-02-03 04:05:06.12", time.Date(2001, time.February, 3, 4, 5, 6, 120000000, time.FixedZone("", 0))},
		{"2001-02-03 04:05:06.123", time.Date(2001, time.February, 3, 4, 5, 6, 123000000, time.FixedZone("", 0))},
		{"2001-02-03 04:05:06.1234", time.Date(2001, time.February, 3, 4, 5, 6, 123400000, time.FixedZone("", 0))},
		{"2001-02-03 04:05:06.12345", time.Date(2001, time.February, 3, 4, 5, 6, 123450000, time.FixedZone("", 0))},
		{"2001-02-03 04:05:06.123456", time.Date(2001, time.February, 3, 4, 5, 6, 123456000, time.FixedZone("", 0))},
		{"2001-02-03 04:05:06.123-07", time.Date(2001, time.February, 3, 4, 5, 6, 123000000,
			time.FixedZone("", -7*60*60))},
		{"2001-02-03 04:05:06-07", time.Date(2001, time.February, 3, 4, 5, 6, 0,
			time.FixedZone("", -7*60*60))},
		{"2001-02-03 04:05:06-07:42", time.Date(2001, time.February, 3, 4, 5, 6, 0,
			time.FixedZone("", -(7*60*60+42*60)))},
		{"2001-02-03 04:05:06-07:30:09", time.Date(2001, time.February, 3, 4, 5, 6, 0,
			time.FixedZone("", -(7*60*60+30*60+9)))},
		{"2001-02-03 04:05:06+07", time.Date(2001, time.February, 3, 4, 5, 6, 0,
			time.FixedZone("", 7*60*60))},
		{"0011-02-03 04:05:06 BC", time.Date(-10, time.February, 3, 4, 5, 6, 0, time.FixedZone("", 0))},
		{"0011-02-03 04:05:06.123 BC", time.Date(-10, time.February, 3, 4, 5, 6, 123000000, time.FixedZone("", 0))},
		{"0011-02-03 04:05:06.123-07 BC", time.Date(-10, time.February, 3, 4, 5, 6, 123000000,
			time.FixedZone("", -7*60*60))},
		{"0001-02-03 04:05:06.123", time.Date(1, time.February, 3, 4, 5, 6, 123000000, time.FixedZone("", 0))},
		{"0001-02-03 04:05:06.123 BC", time.Date(1, time.February, 3, 4, 5, 6, 123000000, time.FixedZone("", 0)).AddDate(-1, 0, 0)},
		{"0001-02-03 04:05:06.123 BC", time.Date(0, time.February, 3, 4, 5, 6, 123000000, time.FixedZone("", 0))},
		{"0002-02-03 04:05:06.123 BC", time.Date(0, time.February, 3, 4, 5, 6, 123000000, time.FixedZone("", 0)).AddDate(-1, 0, 0)},
		{"0002-02-03 04:05:06.123 BC", time.Date(-1, time.February, 3, 4, 5, 6, 123000000, time.FixedZone("", 0))},
		{"12345-02-03 04:05:06.1", time.Date(12345, time.February, 3, 4, 5, 6, 100000000, time.FixedZone("", 0))},
		{"123456-02-03 04:05:06.1", time.Date(123456, time.February, 3, 4, 5, 6, 100000000, time.FixedZone("", 0))},
	}

	// Helper function for the two tests below
	func tryParse(str string) (t time.Time, err error) {
		defer func() {
			if p := recover(); p != nil {
				err = fmt.Errorf("%v", p)
				return
			}
		}()
		i := parseTs(nil, str)
		t, ok := i.(time.Time)
		if !ok {
			err = fmt.Errorf("Not a time.Time type, got %#v", i)
		}
		return
	}

	// Test that parsing the string results in the expected value.
	func TestParseTs(t *testing.T) {
		for i, tt := range timeTests {
			val, err := tryParse(tt.str)
			if err != nil {
				t.Errorf("%d: got error: %v", i, err)
			} else if val.String() != tt.timeval.String() {
				t.Errorf("%d: expected to parse %q into %q; got %q",
					i, tt.str, tt.timeval, val)
			}
		}
	}

	// Now test that sending the value into the database and parsing it back
	// returns the same time.Time value.
	func TestEncodeAndParseTs(t *testing.T) {
		db, err := openTestConnConninfo("timezone='Etc/UTC'")
		if err != nil {
			t.Fatal(err)
		}
		defer db.Close()

		for i, tt := range timeTests {
			var dbstr string
			err = db.QueryRow("SELECT ($1::timestamptz)::text", tt.timeval).Scan(&dbstr)
			if err != nil {
				t.Errorf("%d: could not send value %q to the database: %s", i, tt.timeval, err)
				continue
			}

			val, err := tryParse(dbstr)
			if err != nil {
				t.Errorf("%d: could not parse value %q: %s", i, dbstr, err)
				continue
			}
			val = val.In(tt.timeval.Location())
			if val.String() != tt.timeval.String() {
				t.Errorf("%d: expected to parse %q into %q; got %q", i, dbstr, tt.timeval, val)
			}
		}
	}

	var formatTimeTests = []struct {
		time     time.Time
		expected string
	}{
		{time.Time{}, "0001-01-01T00:00:00Z"},
		{time.Date(2001, time.February, 3, 4, 5, 6, 123456789, time.FixedZone("", 0)), "2001-02-03T04:05:06.123456789Z"},
		{time.Date(2001, time.February, 3, 4, 5, 6, 123456789, time.FixedZone("", 2*60*60)), "2001-02-03T04:05:06.123456789+02:00"},
		{time.Date(2001, time.February, 3, 4, 5, 6, 123456789, time.FixedZone("", -6*60*60)), "2001-02-03T04:05:06.123456789-06:00"},
		{time.Date(2001, time.February, 3, 4, 5, 6, 0, time.FixedZone("", -(7*60*60+30*60+9))), "2001-02-03T04:05:06-07:30:09"},

		{time.Date(1, time.February, 3, 4, 5, 6, 123456789, time.FixedZone("", 0)), "0001-02-03T04:05:06.123456789Z"},
		{time.Date(1, time.February, 3, 4, 5, 6, 123456789, time.FixedZone("", 2*60*60)), "0001-02-03T04:05:06.123456789+02:00"},
		{time.Date(1, time.February, 3, 4, 5, 6, 123456789, time.FixedZone("", -6*60*60)), "0001-02-03T04:05:06.123456789-06:00"},

		{time.Date(0, time.February, 3, 4, 5, 6, 123456789, time.FixedZone("", 0)), "0001-02-03T04:05:06.123456789Z BC"},
		{time.Date(0, time.February, 3, 4, 5, 6, 123456789, time.FixedZone("", 2*60*60)), "0001-02-03T04:05:06.123456789+02:00 BC"},
		{time.Date(0, time.February, 3, 4, 5, 6, 123456789, time.FixedZone("", -6*60*60)), "0001-02-03T04:05:06.123456789-06:00 BC"},

		{time.Date(1, time.February, 3, 4, 5, 6, 0, time.FixedZone("", -(7*60*60+30*60+9))), "0001-02-03T04:05:06-07:30:09"},
		{time.Date(0, time.February, 3, 4, 5, 6, 0, time.FixedZone("", -(7*60*60+30*60+9))), "0001-02-03T04:05:06-07:30:09 BC"},
	}

	func TestFormatTs(t *testing.T) {
		for i, tt := range formatTimeTests {
			val := string(formatTs(tt.time))
			if val != tt.expected {
				t.Errorf("%d: incorrect time format %q, want %q", i, val, tt.expected)
			}
		}
	}

	func TestTimestampWithTimeZone(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		tx, err := db.Begin()
		if err != nil {
			t.Fatal(err)
		}
		defer tx.Rollback()

		// try several different locations, all included in Go's zoneinfo.zip
		for _, locName := range []string{
			"UTC",
			"America/Chicago",
			"America/New_York",
			"Australia/Darwin",
			"Australia/Perth",
		} {
			loc, err := time.LoadLocation(locName)
			if err != nil {
				t.Logf("Could not load time zone %s - skipping", locName)
				continue
			}

			// Postgres timestamps have a resolution of 1 microsecond, so don't
			// use the full range of the Nanosecond argument
			refTime := time.Date(2012, 11, 6, 10, 23, 42, 123456000, loc)

			for _, pgTimeZone := range []string{"US/Eastern", "Australia/Darwin"} {
				// Switch Postgres's timezone to test different output timestamp formats
				_, err = tx.Exec(fmt.Sprintf("set time zone '%s'", pgTimeZone))
				if err != nil {
					t.Fatal(err)
				}

				var gotTime time.Time
				row := tx.QueryRow("select $1::timestamp with time zone", refTime)
				err = row.Scan(&gotTime)
				if err != nil {
					t.Fatal(err)
				}

				if !refTime.Equal(gotTime) {
					t.Errorf("timestamps not equal: %s != %s", refTime, gotTime)
				}

				// check that the time zone is set correctly based on TimeZone
				pgLoc, err := time.LoadLocation(pgTimeZone)
				if err != nil {
					t.Logf("Could not load time zone %s - skipping", pgLoc)
					continue
				}
				translated := refTime.In(pgLoc)
				if translated.String() != gotTime.String() {
					t.Errorf("timestamps not equal: %s != %s", translated, gotTime)
				}
			}
		}
	}

	func TestTimestampWithOutTimezone(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		test := func(ts, pgts string) {
			r, err := db.Query("SELECT $1::timestamp", pgts)
			if err != nil {
				t.Fatalf("Could not run query: %v", err)
			}

			n := r.Next()

			if n != true {
				t.Fatal("Expected at least one row")
			}

			var result time.Time
			err = r.Scan(&result)
			if err != nil {
				t.Fatalf("Did not expect error scanning row: %v", err)
			}

			expected, err := time.Parse(time.RFC3339, ts)
			if err != nil {
				t.Fatalf("Could not parse test time literal: %v", err)
			}

			if !result.Equal(expected) {
				t.Fatalf("Expected time to match %v: got mismatch %v",
					expected, result)
			}

			n = r.Next()
			if n != false {
				t.Fatal("Expected only one row")
			}
		}

		test("2000-01-01T00:00:00Z", "2000-01-01T00:00:00")

		// Test higher precision time
		test("2013-01-04T20:14:58.80033Z", "2013-01-04 20:14:58.80033")
	}

	func TestInfinityTimestamp(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()
		var err error
		var resultT time.Time

		expectedError := fmt.Errorf(`sql: Scan error on column index 0: unsupported driver -> Scan pair: []uint8 -> *time.Time`)
		type testCases []struct {
			Query       string
			Param       string
			ExpectedErr error
			ExpectedVal interface{}
		}
		tc := testCases{
			{"SELECT $1::timestamp", "-infinity", expectedError, "-infinity"},
			{"SELECT $1::timestamptz", "-infinity", expectedError, "-infinity"},
			{"SELECT $1::timestamp", "infinity", expectedError, "infinity"},
			{"SELECT $1::timestamptz", "infinity", expectedError, "infinity"},
		}
		// try to assert []byte to time.Time
		for _, q := range tc {
			err = db.QueryRow(q.Query, q.Param).Scan(&resultT)
			if err.Error() != q.ExpectedErr.Error() {
				t.Errorf("Scanning -/+infinity, expected error, %q, got %q", q.ExpectedErr, err)
			}
		}
		// yield []byte
		for _, q := range tc {
			var resultI interface{}
			err = db.QueryRow(q.Query, q.Param).Scan(&resultI)
			if err != nil {
				t.Errorf("Scanning -/+infinity, expected no error, got %q", err)
			}
			result, ok := resultI.([]byte)
			if !ok {
				t.Errorf("Scanning -/+infinity, expected []byte, got %#v", resultI)
			}
			if string(result) != q.ExpectedVal {
				t.Errorf("Scanning -/+infinity, expected %q, got %q", q.ExpectedVal, result)
			}
		}

		y1500 := time.Date(1500, time.January, 1, 0, 0, 0, 0, time.UTC)
		y2500 := time.Date(2500, time.January, 1, 0, 0, 0, 0, time.UTC)
		EnableInfinityTs(y1500, y2500)

		err = db.QueryRow("SELECT $1::timestamp", "infinity").Scan(&resultT)
		if err != nil {
			t.Errorf("Scanning infinity, expected no error, got %q", err)
		}
		if !resultT.Equal(y2500) {
			t.Errorf("Scanning infinity, expected %q, got %q", y2500, resultT)
		}

		err = db.QueryRow("SELECT $1::timestamptz", "infinity").Scan(&resultT)
		if err != nil {
			t.Errorf("Scanning infinity, expected no error, got %q", err)
		}
		if !resultT.Equal(y2500) {
			t.Errorf("Scanning Infinity, expected time %q, got %q", y2500, resultT.String())
		}

		err = db.QueryRow("SELECT $1::timestamp", "-infinity").Scan(&resultT)
		if err != nil {
			t.Errorf("Scanning -infinity, expected no error, got %q", err)
		}
		if !resultT.Equal(y1500) {
			t.Errorf("Scanning -infinity, expected time %q, got %q", y1500, resultT.String())
		}

		err = db.QueryRow("SELECT $1::timestamptz", "-infinity").Scan(&resultT)
		if err != nil {
			t.Errorf("Scanning -infinity, expected no error, got %q", err)
		}
		if !resultT.Equal(y1500) {
			t.Errorf("Scanning -infinity, expected time %q, got %q", y1500, resultT.String())
		}

		y_1500 := time.Date(-1500, time.January, 1, 0, 0, 0, 0, time.UTC)
		y11500 := time.Date(11500, time.January, 1, 0, 0, 0, 0, time.UTC)
		var s string
		err = db.QueryRow("SELECT $1::timestamp::text", y_1500).Scan(&s)
		if err != nil {
			t.Errorf("Encoding -infinity, expected no error, got %q", err)
		}
		if s != "-infinity" {
			t.Errorf("Encoding -infinity, expected %q, got %q", "-infinity", s)
		}
		err = db.QueryRow("SELECT $1::timestamptz::text", y_1500).Scan(&s)
		if err != nil {
			t.Errorf("Encoding -infinity, expected no error, got %q", err)
		}
		if s != "-infinity" {
			t.Errorf("Encoding -infinity, expected %q, got %q", "-infinity", s)
		}

		err = db.QueryRow("SELECT $1::timestamp::text", y11500).Scan(&s)
		if err != nil {
			t.Errorf("Encoding infinity, expected no error, got %q", err)
		}
		if s != "infinity" {
			t.Errorf("Encoding infinity, expected %q, got %q", "infinity", s)
		}
		err = db.QueryRow("SELECT $1::timestamptz::text", y11500).Scan(&s)
		if err != nil {
			t.Errorf("Encoding infinity, expected no error, got %q", err)
		}
		if s != "infinity" {
			t.Errorf("Encoding infinity, expected %q, got %q", "infinity", s)
		}

		disableInfinityTs()

		var panicErrorString string
		func() {
			defer func() {
				panicErrorString, _ = recover().(string)
			}()
			EnableInfinityTs(y2500, y1500)
		}()
		if panicErrorString != infinityTsNegativeMustBeSmaller {
			t.Errorf("Expected error, %q, got %q", infinityTsNegativeMustBeSmaller, panicErrorString)
		}
	}

	func TestStringWithNul(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		hello0world := string("hello\x00world")
		_, err := db.Query("SELECT $1::text", &hello0world)
		if err == nil {
			t.Fatal("Postgres accepts a string with nul in it; " +
				"injection attacks may be plausible")
		}
	}

	func TestByteaToText(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		b := []byte("hello world")
		row := db.QueryRow("SELECT $1::text", b)

		var result []byte
		err := row.Scan(&result)
		if err != nil {
			t.Fatal(err)
		}

		if string(result) != string(b) {
			t.Fatalf("expected %v but got %v", b, result)
		}
	}

	func TestTextToBytea(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		b := "hello world"
		row := db.QueryRow("SELECT $1::bytea", b)

		var result []byte
		err := row.Scan(&result)
		if err != nil {
			t.Fatal(err)
		}

		if !bytes.Equal(result, []byte(b)) {
			t.Fatalf("expected %v but got %v", b, result)
		}
	}

	func TestByteaOutputFormatEncoding(t *testing.T) {
		input := []byte("\\x\x00\x01\x02\xFF\xFEabcdefg0123")
		want := []byte("\\x5c78000102fffe6162636465666730313233")
		got := encode(&parameterStatus{serverVersion: 90000}, input, oid.T_bytea)
		if !bytes.Equal(want, got) {
			t.Errorf("invalid hex bytea output, got %v but expected %v", got, want)
		}

		want = []byte("\\\\x\\000\\001\\002\\377\\376abcdefg0123")
		got = encode(&parameterStatus{serverVersion: 84000}, input, oid.T_bytea)
		if !bytes.Equal(want, got) {
			t.Errorf("invalid escape bytea output, got %v but expected %v", got, want)
		}
	}

	func TestByteaOutputFormats(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		if getServerVersion(t, db) < 90000 {
			// skip
			return
		}

		testByteaOutputFormat := func(f string) {
			expectedData := []byte("\x5c\x78\x00\xff\x61\x62\x63\x01\x08")
			sqlQuery := "SELECT decode('5c7800ff6162630108', 'hex')"

			var data []byte

			// use a txn to avoid relying on getting the same connection
			txn, err := db.Begin()
			if err != nil {
				t.Fatal(err)
			}
			defer txn.Rollback()

			_, err = txn.Exec("SET LOCAL bytea_output TO " + f)
			if err != nil {
				t.Fatal(err)
			}
			// use Query; QueryRow would hide the actual error
			rows, err := txn.Query(sqlQuery)
			if err != nil {
				t.Fatal(err)
			}
			if !rows.Next() {
				if rows.Err() != nil {
					t.Fatal(rows.Err())
				}
				t.Fatal("shouldn't happen")
			}
			err = rows.Scan(&data)
			if err != nil {
				t.Fatal(err)
			}
			err = rows.Close()
			if err != nil {
				t.Fatal(err)
			}
			if !bytes.Equal(data, expectedData) {
				t.Errorf("unexpected bytea value %v for format %s; expected %v", data, f, expectedData)
			}
		}

		testByteaOutputFormat("hex")
		testByteaOutputFormat("escape")
	}

	func TestAppendEncodedText(t *testing.T) {
		var buf []byte

		buf = appendEncodedText(&parameterStatus{serverVersion: 90000}, buf, int64(10))
		buf = append(buf, '\t')
		buf = appendEncodedText(&parameterStatus{serverVersion: 90000}, buf, float32(42.0000000001))
		buf = append(buf, '\t')
		buf = appendEncodedText(&parameterStatus{serverVersion: 90000}, buf, 42.0000000001)
		buf = append(buf, '\t')
		buf = appendEncodedText(&parameterStatus{serverVersion: 90000}, buf, "hello\tworld")
		buf = append(buf, '\t')
		buf = appendEncodedText(&parameterStatus{serverVersion: 90000}, buf, []byte{0, 128, 255})

		if string(buf) != "10\t42\t42.0000000001\thello\\tworld\t\\\\x0080ff" {
			t.Fatal(string(buf))
		}
	}

	func TestAppendEscapedText(t *testing.T) {
		if esc := appendEscapedText(nil, "hallo\tescape"); string(esc) != "hallo\\tescape" {
			t.Fatal(string(esc))
		}
		if esc := appendEscapedText(nil, "hallo\\tescape\n"); string(esc) != "hallo\\\\tescape\\n" {
			t.Fatal(string(esc))
		}
		if esc := appendEscapedText(nil, "\n\r\t\f"); string(esc) != "\\n\\r\\t\f" {
			t.Fatal(string(esc))
		}
	}

	func TestAppendEscapedTextExistingBuffer(t *testing.T) {
		var buf []byte
		buf = []byte("123\t")
		if esc := appendEscapedText(buf, "hallo\tescape"); string(esc) != "123\thallo\\tescape" {
			t.Fatal(string(esc))
		}
		buf = []byte("123\t")
		if esc := appendEscapedText(buf, "hallo\\tescape\n"); string(esc) != "123\thallo\\\\tescape\\n" {
			t.Fatal(string(esc))
		}
		buf = []byte("123\t")
		if esc := appendEscapedText(buf, "\n\r\t\f"); string(esc) != "123\t\\n\\r\\t\f" {
			t.Fatal(string(esc))
		}
	}

	func BenchmarkAppendEscapedText(b *testing.B) {
		longString := ""
		for i := 0; i < 100; i++ {
			longString += "123456789\n"
		}
		for i := 0; i < b.N; i++ {
			appendEscapedText(nil, longString)
		}
	}

	func BenchmarkAppendEscapedTextNoEscape(b *testing.B) {
		longString := ""
		for i := 0; i < 100; i++ {
			longString += "1234567890"
		}
		for i := 0; i < b.N; i++ {
			appendEscapedText(nil, longString)
		}
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_error
	package pq

	import (
		"database/sql/driver"
		"fmt"
		"io"
		"net"
		"runtime"
	)

	// Error severities
	const (
		Efatal   = "FATAL"
		Epanic   = "PANIC"
		Ewarning = "WARNING"
		Enotice  = "NOTICE"
		Edebug   = "DEBUG"
		Einfo    = "INFO"
		Elog     = "LOG"
	)

	// Error represents an error communicating with the server.
	//
	// See http://www.postgresql.org/docs/current/static/protocol-error-fields.html for details of the fields
	type Error struct {
		Severity         string
		Code             ErrorCode
		Message          string
		Detail           string
		Hint             string
		Position         string
		InternalPosition string
		InternalQuery    string
		Where            string
		Schema           string
		Table            string
		Column           string
		DataTypeName     string
		Constraint       string
		File             string
		Line             string
		Routine          string
	}

	// ErrorCode is a five-character error code.
	type ErrorCode string

	// Name returns a more human friendly rendering of the error code, namely the
	// "condition name".
	//
	// See http://www.postgresql.org/docs/9.3/static/errcodes-appendix.html for
	// details.
	func (ec ErrorCode) Name() string {
		return errorCodeNames[ec]
	}

	// ErrorClass is only the class part of an error code.
	type ErrorClass string

	// Name returns the condition name of an error class.  It is equivalent to the
	// condition name of the "standard" error code (i.e. the one having the last
	// three characters "000").
	func (ec ErrorClass) Name() string {
		return errorCodeNames[ErrorCode(ec+"000")]
	}

	// Class returns the error class, e.g. "28".
	//
	// See http://www.postgresql.org/docs/9.3/static/errcodes-appendix.html for
	// details.
	func (ec ErrorCode) Class() ErrorClass {
		return ErrorClass(ec[0:2])
	}

	// errorCodeNames is a mapping between the five-character error codes and the
	// human readable "condition names". It is derived from the list at
	// http://www.postgresql.org/docs/9.3/static/errcodes-appendix.html
	var errorCodeNames = map[ErrorCode]string{
		// Class 00 - Successful Completion
		"00000": "successful_completion",
		// Class 01 - Warning
		"01000": "warning",
		"0100C": "dynamic_result_sets_returned",
		"01008": "implicit_zero_bit_padding",
		"01003": "null_value_eliminated_in_set_function",
		"01007": "privilege_not_granted",
		"01006": "privilege_not_revoked",
		"01004": "string_data_right_truncation",
		"01P01": "deprecated_feature",
		// Class 02 - No Data (this is also a warning class per the SQL standard)
		"02000": "no_data",
		"02001": "no_additional_dynamic_result_sets_returned",
		// Class 03 - SQL Statement Not Yet Complete
		"03000": "sql_statement_not_yet_complete",
		// Class 08 - Connection Exception
		"08000": "connection_exception",
		"08003": "connection_does_not_exist",
		"08006": "connection_failure",
		"08001": "sqlclient_unable_to_establish_sqlconnection",
		"08004": "sqlserver_rejected_establishment_of_sqlconnection",
		"08007": "transaction_resolution_unknown",
		"08P01": "protocol_violation",
		// Class 09 - Triggered Action Exception
		"09000": "triggered_action_exception",
		// Class 0A - Feature Not Supported
		"0A000": "feature_not_supported",
		// Class 0B - Invalid Transaction Initiation
		"0B000": "invalid_transaction_initiation",
		// Class 0F - Locator Exception
		"0F000": "locator_exception",
		"0F001": "invalid_locator_specification",
		// Class 0L - Invalid Grantor
		"0L000": "invalid_grantor",
		"0LP01": "invalid_grant_operation",
		// Class 0P - Invalid Role Specification
		"0P000": "invalid_role_specification",
		// Class 0Z - Diagnostics Exception
		"0Z000": "diagnostics_exception",
		"0Z002": "stacked_diagnostics_accessed_without_active_handler",
		// Class 20 - Case Not Found
		"20000": "case_not_found",
		// Class 21 - Cardinality Violation
		"21000": "cardinality_violation",
		// Class 22 - Data Exception
		"22000": "data_exception",
		"2202E": "array_subscript_error",
		"22021": "character_not_in_repertoire",
		"22008": "datetime_field_overflow",
		"22012": "division_by_zero",
		"22005": "error_in_assignment",
		"2200B": "escape_character_conflict",
		"22022": "indicator_overflow",
		"22015": "interval_field_overflow",
		"2201E": "invalid_argument_for_logarithm",
		"22014": "invalid_argument_for_ntile_function",
		"22016": "invalid_argument_for_nth_value_function",
		"2201F": "invalid_argument_for_power_function",
		"2201G": "invalid_argument_for_width_bucket_function",
		"22018": "invalid_character_value_for_cast",
		"22007": "invalid_datetime_format",
		"22019": "invalid_escape_character",
		"2200D": "invalid_escape_octet",
		"22025": "invalid_escape_sequence",
		"22P06": "nonstandard_use_of_escape_character",
		"22010": "invalid_indicator_parameter_value",
		"22023": "invalid_parameter_value",
		"2201B": "invalid_regular_expression",
		"2201W": "invalid_row_count_in_limit_clause",
		"2201X": "invalid_row_count_in_result_offset_clause",
		"22009": "invalid_time_zone_displacement_value",
		"2200C": "invalid_use_of_escape_character",
		"2200G": "most_specific_type_mismatch",
		"22004": "null_value_not_allowed",
		"22002": "null_value_no_indicator_parameter",
		"22003": "numeric_value_out_of_range",
		"22026": "string_data_length_mismatch",
		"22001": "string_data_right_truncation",
		"22011": "substring_error",
		"22027": "trim_error",
		"22024": "unterminated_c_string",
		"2200F": "zero_length_character_string",
		"22P01": "floating_point_exception",
		"22P02": "invalid_text_representation",
		"22P03": "invalid_binary_representation",
		"22P04": "bad_copy_file_format",
		"22P05": "untranslatable_character",
		"2200L": "not_an_xml_document",
		"2200M": "invalid_xml_document",
		"2200N": "invalid_xml_content",
		"2200S": "invalid_xml_comment",
		"2200T": "invalid_xml_processing_instruction",
		// Class 23 - Integrity Constraint Violation
		"23000": "integrity_constraint_violation",
		"23001": "restrict_violation",
		"23502": "not_null_violation",
		"23503": "foreign_key_violation",
		"23505": "unique_violation",
		"23514": "check_violation",
		"23P01": "exclusion_violation",
		// Class 24 - Invalid Cursor State
		"24000": "invalid_cursor_state",
		// Class 25 - Invalid Transaction State
		"25000": "invalid_transaction_state",
		"25001": "active_sql_transaction",
		"25002": "branch_transaction_already_active",
		"25008": "held_cursor_requires_same_isolation_level",
		"25003": "inappropriate_access_mode_for_branch_transaction",
		"25004": "inappropriate_isolation_level_for_branch_transaction",
		"25005": "no_active_sql_transaction_for_branch_transaction",
		"25006": "read_only_sql_transaction",
		"25007": "schema_and_data_statement_mixing_not_supported",
		"25P01": "no_active_sql_transaction",
		"25P02": "in_failed_sql_transaction",
		// Class 26 - Invalid SQL Statement Name
		"26000": "invalid_sql_statement_name",
		// Class 27 - Triggered Data Change Violation
		"27000": "triggered_data_change_violation",
		// Class 28 - Invalid Authorization Specification
		"28000": "invalid_authorization_specification",
		"28P01": "invalid_password",
		// Class 2B - Dependent Privilege Descriptors Still Exist
		"2B000": "dependent_privilege_descriptors_still_exist",
		"2BP01": "dependent_objects_still_exist",
		// Class 2D - Invalid Transaction Termination
		"2D000": "invalid_transaction_termination",
		// Class 2F - SQL Routine Exception
		"2F000": "sql_routine_exception",
		"2F005": "function_executed_no_return_statement",
		"2F002": "modifying_sql_data_not_permitted",
		"2F003": "prohibited_sql_statement_attempted",
		"2F004": "reading_sql_data_not_permitted",
		// Class 34 - Invalid Cursor Name
		"34000": "invalid_cursor_name",
		// Class 38 - External Routine Exception
		"38000": "external_routine_exception",
		"38001": "containing_sql_not_permitted",
		"38002": "modifying_sql_data_not_permitted",
		"38003": "prohibited_sql_statement_attempted",
		"38004": "reading_sql_data_not_permitted",
		// Class 39 - External Routine Invocation Exception
		"39000": "external_routine_invocation_exception",
		"39001": "invalid_sqlstate_returned",
		"39004": "null_value_not_allowed",
		"39P01": "trigger_protocol_violated",
		"39P02": "srf_protocol_violated",
		// Class 3B - Savepoint Exception
		"3B000": "savepoint_exception",
		"3B001": "invalid_savepoint_specification",
		// Class 3D - Invalid Catalog Name
		"3D000": "invalid_catalog_name",
		// Class 3F - Invalid Schema Name
		"3F000": "invalid_schema_name",
		// Class 40 - Transaction Rollback
		"40000": "transaction_rollback",
		"40002": "transaction_integrity_constraint_violation",
		"40001": "serialization_failure",
		"40003": "statement_completion_unknown",
		"40P01": "deadlock_detected",
		// Class 42 - Syntax Error or Access Rule Violation
		"42000": "syntax_error_or_access_rule_violation",
		"42601": "syntax_error",
		"42501": "insufficient_privilege",
		"42846": "cannot_coerce",
		"42803": "grouping_error",
		"42P20": "windowing_error",
		"42P19": "invalid_recursion",
		"42830": "invalid_foreign_key",
		"42602": "invalid_name",
		"42622": "name_too_long",
		"42939": "reserved_name",
		"42804": "datatype_mismatch",
		"42P18": "indeterminate_datatype",
		"42P21": "collation_mismatch",
		"42P22": "indeterminate_collation",
		"42809": "wrong_object_type",
		"42703": "undefined_column",
		"42883": "undefined_function",
		"42P01": "undefined_table",
		"42P02": "undefined_parameter",
		"42704": "undefined_object",
		"42701": "duplicate_column",
		"42P03": "duplicate_cursor",
		"42P04": "duplicate_database",
		"42723": "duplicate_function",
		"42P05": "duplicate_prepared_statement",
		"42P06": "duplicate_schema",
		"42P07": "duplicate_table",
		"42712": "duplicate_alias",
		"42710": "duplicate_object",
		"42702": "ambiguous_column",
		"42725": "ambiguous_function",
		"42P08": "ambiguous_parameter",
		"42P09": "ambiguous_alias",
		"42P10": "invalid_column_reference",
		"42611": "invalid_column_definition",
		"42P11": "invalid_cursor_definition",
		"42P12": "invalid_database_definition",
		"42P13": "invalid_function_definition",
		"42P14": "invalid_prepared_statement_definition",
		"42P15": "invalid_schema_definition",
		"42P16": "invalid_table_definition",
		"42P17": "invalid_object_definition",
		// Class 44 - WITH CHECK OPTION Violation
		"44000": "with_check_option_violation",
		// Class 53 - Insufficient Resources
		"53000": "insufficient_resources",
		"53100": "disk_full",
		"53200": "out_of_memory",
		"53300": "too_many_connections",
		"53400": "configuration_limit_exceeded",
		// Class 54 - Program Limit Exceeded
		"54000": "program_limit_exceeded",
		"54001": "statement_too_complex",
		"54011": "too_many_columns",
		"54023": "too_many_arguments",
		// Class 55 - Object Not In Prerequisite State
		"55000": "object_not_in_prerequisite_state",
		"55006": "object_in_use",
		"55P02": "cant_change_runtime_param",
		"55P03": "lock_not_available",
		// Class 57 - Operator Intervention
		"57000": "operator_intervention",
		"57014": "query_canceled",
		"57P01": "admin_shutdown",
		"57P02": "crash_shutdown",
		"57P03": "cannot_connect_now",
		"57P04": "database_dropped",
		// Class 58 - System Error (errors external to PostgreSQL itself)
		"58000": "system_error",
		"58030": "io_error",
		"58P01": "undefined_file",
		"58P02": "duplicate_file",
		// Class F0 - Configuration File Error
		"F0000": "config_file_error",
		"F0001": "lock_file_exists",
		// Class HV - Foreign Data Wrapper Error (SQL/MED)
		"HV000": "fdw_error",
		"HV005": "fdw_column_name_not_found",
		"HV002": "fdw_dynamic_parameter_value_needed",
		"HV010": "fdw_function_sequence_error",
		"HV021": "fdw_inconsistent_descriptor_information",
		"HV024": "fdw_invalid_attribute_value",
		"HV007": "fdw_invalid_column_name",
		"HV008": "fdw_invalid_column_number",
		"HV004": "fdw_invalid_data_type",
		"HV006": "fdw_invalid_data_type_descriptors",
		"HV091": "fdw_invalid_descriptor_field_identifier",
		"HV00B": "fdw_invalid_handle",
		"HV00C": "fdw_invalid_option_index",
		"HV00D": "fdw_invalid_option_name",
		"HV090": "fdw_invalid_string_length_or_buffer_length",
		"HV00A": "fdw_invalid_string_format",
		"HV009": "fdw_invalid_use_of_null_pointer",
		"HV014": "fdw_too_many_handles",
		"HV001": "fdw_out_of_memory",
		"HV00P": "fdw_no_schemas",
		"HV00J": "fdw_option_name_not_found",
		"HV00K": "fdw_reply_handle",
		"HV00Q": "fdw_schema_not_found",
		"HV00R": "fdw_table_not_found",
		"HV00L": "fdw_unable_to_create_execution",
		"HV00M": "fdw_unable_to_create_reply",
		"HV00N": "fdw_unable_to_establish_connection",
		// Class P0 - PL/pgSQL Error
		"P0000": "plpgsql_error",
		"P0001": "raise_exception",
		"P0002": "no_data_found",
		"P0003": "too_many_rows",
		// Class XX - Internal Error
		"XX000": "internal_error",
		"XX001": "data_corrupted",
		"XX002": "index_corrupted",
	}

	func parseError(r *readBuf) *Error {
		err := new(Error)
		for t := r.byte(); t != 0; t = r.byte() {
			msg := r.string()
			switch t {
			case 'S':
				err.Severity = msg
			case 'C':
				err.Code = ErrorCode(msg)
			case 'M':
				err.Message = msg
			case 'D':
				err.Detail = msg
			case 'H':
				err.Hint = msg
			case 'P':
				err.Position = msg
			case 'p':
				err.InternalPosition = msg
			case 'q':
				err.InternalQuery = msg
			case 'W':
				err.Where = msg
			case 's':
				err.Schema = msg
			case 't':
				err.Table = msg
			case 'c':
				err.Column = msg
			case 'd':
				err.DataTypeName = msg
			case 'n':
				err.Constraint = msg
			case 'F':
				err.File = msg
			case 'L':
				err.Line = msg
			case 'R':
				err.Routine = msg
			}
		}
		return err
	}

	// Fatal returns true if the Error Severity is fatal.
	func (err *Error) Fatal() bool {
		return err.Severity == Efatal
	}

	// Get implements the legacy PGError interface. New code should use the fields
	// of the Error struct directly.
	func (err *Error) Get(k byte) (v string) {
		switch k {
		case 'S':
			return err.Severity
		case 'C':
			return string(err.Code)
		case 'M':
			return err.Message
		case 'D':
			return err.Detail
		case 'H':
			return err.Hint
		case 'P':
			return err.Position
		case 'p':
			return err.InternalPosition
		case 'q':
			return err.InternalQuery
		case 'W':
			return err.Where
		case 's':
			return err.Schema
		case 't':
			return err.Table
		case 'c':
			return err.Column
		case 'd':
			return err.DataTypeName
		case 'n':
			return err.Constraint
		case 'F':
			return err.File
		case 'L':
			return err.Line
		case 'R':
			return err.Routine
		}
		return ""
	}

	func (err Error) Error() string {
		return "pq: " + err.Message
	}

	// PGError is an interface used by previous versions of pq. It is provided
	// only to support legacy code. New code should use the Error type.
	type PGError interface {
		Error() string
		Fatal() bool
		Get(k byte) (v string)
	}

	func errorf(s string, args ...interface{}) {
		panic(fmt.Errorf("pq: %s", fmt.Sprintf(s, args...)))
	}

	func (c *conn) errRecover(err *error) {
		e := recover()
		switch v := e.(type) {
		case nil:
			// Do nothing
		case runtime.Error:
			c.bad = true
			panic(v)
		case *Error:
			if v.Fatal() {
				*err = driver.ErrBadConn
			} else {
				*err = v
			}
		case *net.OpError:
			*err = driver.ErrBadConn
		case error:
			if v == io.EOF || v.(error).Error() == "remote error: handshake failure" {
				*err = driver.ErrBadConn
			} else {
				*err = v
			}

		default:
			c.bad = true
			panic(fmt.Sprintf("unknown error: %#v", e))
		}

		// Any time we return ErrBadConn, we need to remember it since *Tx doesn't
		// mark the connection bad in database/sql.
		if *err == driver.ErrBadConn {
			c.bad = true
		}
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_hstore_hstore
	package hstore

	import (
		"database/sql"
		"database/sql/driver"
		"strings"
	)

	// A wrapper for transferring Hstore values back and forth easily.
	type Hstore struct {
		Map map[string]sql.NullString
	}

	// escapes and quotes hstore keys/values
	// s should be a sql.NullString or string
	func hQuote(s interface{}) string {
		var str string
		switch v := s.(type) {
		case sql.NullString:
			if !v.Valid {
				return "NULL"
			}
			str = v.String
		case string:
			str = v
		default:
			panic("not a string or sql.NullString")
		}

		str = strings.Replace(str, "\\", "\\\\", -1)
		return `"` + strings.Replace(str, "\"", "\\\"", -1) + `"`
	}

	// Scan implements the Scanner interface.
	//
	// Note h.Map is reallocated before the scan to clear existing values. If the
	// hstore column's database value is NULL, then h.Map is set to nil instead.
	func (h *Hstore) Scan(value interface{}) error {
		if value == nil {
			h.Map = nil
			return nil
		}
		h.Map = make(map[string]sql.NullString)
		var b byte
		pair := [][]byte{{}, {}}
		pi := 0
		inQuote := false
		didQuote := false
		sawSlash := false
		bindex := 0
		for bindex, b = range value.([]byte) {
			if sawSlash {
				pair[pi] = append(pair[pi], b)
				sawSlash = false
				continue
			}

			switch b {
			case '\\':
				sawSlash = true
				continue
			case '"':
				inQuote = !inQuote
				if !didQuote {
					didQuote = true
				}
				continue
			default:
				if !inQuote {
					switch b {
					case ' ', '\t', '\n', '\r':
						continue
					case '=':
						continue
					case '>':
						pi = 1
						didQuote = false
						continue
					case ',':
						s := string(pair[1])
						if !didQuote && len(s) == 4 && strings.ToLower(s) == "null" {
							h.Map[string(pair[0])] = sql.NullString{String: "", Valid: false}
						} else {
							h.Map[string(pair[0])] = sql.NullString{String: string(pair[1]), Valid: true}
						}
						pair[0] = []byte{}
						pair[1] = []byte{}
						pi = 0
						continue
					}
				}
			}
			pair[pi] = append(pair[pi], b)
		}
		if bindex > 0 {
			s := string(pair[1])
			if !didQuote && len(s) == 4 && strings.ToLower(s) == "null" {
				h.Map[string(pair[0])] = sql.NullString{String: "", Valid: false}
			} else {
				h.Map[string(pair[0])] = sql.NullString{String: string(pair[1]), Valid: true}
			}
		}
		return nil
	}

	// Value implements the driver Valuer interface. Note if h.Map is nil, the
	// database column value will be set to NULL.
	func (h Hstore) Value() (driver.Value, error) {
		if h.Map == nil {
			return nil, nil
		}
		parts := []string{}
		for key, val := range h.Map {
			thispart := hQuote(key) + "=>" + hQuote(val)
			parts = append(parts, thispart)
		}
		return []byte(strings.Join(parts, ",")), nil
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_hstore_hstore_test
	package hstore

	import (
		"database/sql"
		"os"
		"testing"

		_ "github.com/lib/pq"
	)

	type Fatalistic interface {
		Fatal(args ...interface{})
	}

	func openTestConn(t Fatalistic) *sql.DB {
		datname := os.Getenv("PGDATABASE")
		sslmode := os.Getenv("PGSSLMODE")

		if datname == "" {
			os.Setenv("PGDATABASE", "pqgotest")
		}

		if sslmode == "" {
			os.Setenv("PGSSLMODE", "disable")
		}

		conn, err := sql.Open("postgres", "")
		if err != nil {
			t.Fatal(err)
		}

		return conn
	}

	func TestHstore(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		// quitely create hstore if it doesn't exist
		_, err := db.Exec("CREATE EXTENSION IF NOT EXISTS hstore")
		if err != nil {
			t.Skipf("Skipping hstore tests - hstore extension create failed: %s", err.Error())
		}

		hs := Hstore{}

		// test for null-valued hstores
		err = db.QueryRow("SELECT NULL::hstore").Scan(&hs)
		if err != nil {
			t.Fatal(err)
		}
		if hs.Map != nil {
			t.Fatalf("expected null map")
		}

		err = db.QueryRow("SELECT $1::hstore", hs).Scan(&hs)
		if err != nil {
			t.Fatalf("re-query null map failed: %s", err.Error())
		}
		if hs.Map != nil {
			t.Fatalf("expected null map")
		}

		// test for empty hstores
		err = db.QueryRow("SELECT ''::hstore").Scan(&hs)
		if err != nil {
			t.Fatal(err)
		}
		if hs.Map == nil {
			t.Fatalf("expected empty map, got null map")
		}
		if len(hs.Map) != 0 {
			t.Fatalf("expected empty map, got len(map)=%d", len(hs.Map))
		}

		err = db.QueryRow("SELECT $1::hstore", hs).Scan(&hs)
		if err != nil {
			t.Fatalf("re-query empty map failed: %s", err.Error())
		}
		if hs.Map == nil {
			t.Fatalf("expected empty map, got null map")
		}
		if len(hs.Map) != 0 {
			t.Fatalf("expected empty map, got len(map)=%d", len(hs.Map))
		}

		// a few example maps to test out
		hsOnePair := Hstore{
			Map: map[string]sql.NullString{
				"key1": {"value1", true},
			},
		}

		hsThreePairs := Hstore{
			Map: map[string]sql.NullString{
				"key1": {"value1", true},
				"key2": {"value2", true},
				"key3": {"value3", true},
			},
		}

		hsSmorgasbord := Hstore{
			Map: map[string]sql.NullString{
				"nullstring":             {"NULL", true},
				"actuallynull":           {"", false},
				"NULL":                   {"NULL string key", true},
				"withbracket":            {"value>42", true},
				"withequal":              {"value=42", true},
				`"withquotes1"`:          {`this "should" be fine`, true},
				`"withquotes"2"`:         {`this "should\" also be fine`, true},
				"embedded1":              {"value1=>x1", true},
				"embedded2":              {`"value2"=>x2`, true},
				"withnewlines":           {"\n\nvalue\t=>2", true},
				"<<all sorts of crazy>>": {`this, "should,\" also, => be fine`, true},
			},
		}

		// test encoding in query params, then decoding during Scan
		testBidirectional := func(h Hstore) {
			err = db.QueryRow("SELECT $1::hstore", h).Scan(&hs)
			if err != nil {
				t.Fatalf("re-query %d-pair map failed: %s", len(h.Map), err.Error())
			}
			if hs.Map == nil {
				t.Fatalf("expected %d-pair map, got null map", len(h.Map))
			}
			if len(hs.Map) != len(h.Map) {
				t.Fatalf("expected %d-pair map, got len(map)=%d", len(h.Map), len(hs.Map))
			}

			for key, val := range hs.Map {
				otherval, found := h.Map[key]
				if !found {
					t.Fatalf("  key '%v' not found in %d-pair map", key, len(h.Map))
				}
				if otherval.Valid != val.Valid {
					t.Fatalf("  value %v <> %v in %d-pair map", otherval, val, len(h.Map))
				}
				if otherval.String != val.String {
					t.Fatalf("  value '%v' <> '%v' in %d-pair map", otherval.String, val.String, len(h.Map))
				}
			}
		}

		testBidirectional(hsOnePair)
		testBidirectional(hsThreePairs)
		testBidirectional(hsSmorgasbord)
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_listen_example_doc
	/*

	Below you will find a self-contained Go program which uses the LISTEN / NOTIFY
	mechanism to avoid polling the database while waiting for more work to arrive.

		//
		// You can see the program in action by defining a function similar to
		// the following:
		//
		// CREATE OR REPLACE FUNCTION public.get_work()
		//   RETURNS bigint
		//   LANGUAGE sql
		//   AS $$
		//     SELECT CASE WHEN random() >= 0.2 THEN int8 '1' END
		//   $$
		// ;

		package main

		import (
			"database/sql"
			"fmt"
			"time"

			"github.com/lib/pq"
		)

		func doWork(db *sql.DB, work int64) {
			// work here
		}

		func getWork(db *sql.DB) {
			for {
				// get work from the database here
				var work sql.NullInt64
				err := db.QueryRow("SELECT get_work()").Scan(&work)
				if err != nil {
					fmt.Println("call to get_work() failed: ", err)
					time.Sleep(10 * time.Second)
					continue
				}
				if !work.Valid {
					// no more work to do
					fmt.Println("ran out of work")
					return
				}

				fmt.Println("starting work on ", work.Int64)
				go doWork(db, work.Int64)
			}
		}

		func waitForNotification(l *pq.Listener) {
			for {
				select {
					case <-l.Notify:
						fmt.Println("received notification, new work available")
						return
					case <-time.After(90 * time.Second):
						go func() {
							l.Ping()
						}()
						// Check if there's more work available, just in case it takes
						// a while for the Listener to notice connection loss and
						// reconnect.
						fmt.Println("received no work for 90 seconds, checking for new work")
						return
				}
			}
		}

		func main() {
			var conninfo string = ""

			db, err := sql.Open("postgres", conninfo)
			if err != nil {
				panic(err)
			}

			reportProblem := func(ev pq.ListenerEventType, err error) {
				if err != nil {
					fmt.Println(err.Error())
				}
			}

			listener := pq.NewListener(conninfo, 10 * time.Second, time.Minute, reportProblem)
			err = listener.Listen("getwork")
			if err != nil {
				panic(err)
			}

			fmt.Println("entering main loop")
			for {
				// process all available work before waiting for notifications
				getWork(db)
				waitForNotification(listener)
			}
		}


	*/
	package listen_example


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_notify
	package pq

	// Package pq is a pure Go Postgres driver for the database/sql package.
	// This module contains support for Postgres LISTEN/NOTIFY.

	import (
		"errors"
		"fmt"
		"io"
		"sync"
		"sync/atomic"
		"time"
	)

	// Notification represents a single notification from the database.
	type Notification struct {
		// Process ID (PID) of the notifying postgres backend.
		BePid int
		// Name of the channel the notification was sent on.
		Channel string
		// Payload, or the empty string if unspecified.
		Extra string
	}

	func recvNotification(r *readBuf) *Notification {
		bePid := r.int32()
		channel := r.string()
		extra := r.string()

		return &Notification{bePid, channel, extra}
	}

	const (
		connStateIdle int32 = iota
		connStateExpectResponse
		connStateExpectReadyForQuery
	)

	type message struct {
		typ byte
		err error
	}

	var errListenerConnClosed = errors.New("pq: ListenerConn has been closed")

	// ListenerConn is a low-level interface for waiting for notifications.  You
	// should use Listener instead.
	type ListenerConn struct {
		// guards cn and err
		connectionLock sync.Mutex
		cn             *conn
		err            error

		connState int32

		// the sending goroutine will be holding this lock
		senderLock sync.Mutex

		notificationChan chan<- *Notification

		replyChan chan message
	}

	// Creates a new ListenerConn.  Use NewListener instead.
	func NewListenerConn(name string, notificationChan chan<- *Notification) (*ListenerConn, error) {
		cn, err := Open(name)
		if err != nil {
			return nil, err
		}

		l := &ListenerConn{
			cn:               cn.(*conn),
			notificationChan: notificationChan,
			connState:        connStateIdle,
			replyChan:        make(chan message, 2),
		}

		go l.listenerConnMain()

		return l, nil
	}

	// We can only allow one goroutine at a time to be running a query on the
	// connection for various reasons, so the goroutine sending on the connection
	// must be holding senderLock.
	//
	// Returns an error if an unrecoverable error has occurred and the ListenerConn
	// should be abandoned.
	func (l *ListenerConn) acquireSenderLock() error {
		l.connectionLock.Lock()
		defer l.connectionLock.Unlock()
		if l.err != nil {
			return l.err
		}
		l.senderLock.Lock()
		return nil
	}

	func (l *ListenerConn) releaseSenderLock() {
		l.senderLock.Unlock()
	}

	// setState advances the protocol state to newState.  Returns false if moving
	// to that state from the current state is not allowed.
	func (l *ListenerConn) setState(newState int32) bool {
		var expectedState int32

		switch newState {
		case connStateIdle:
			expectedState = connStateExpectReadyForQuery
		case connStateExpectResponse:
			expectedState = connStateIdle
		case connStateExpectReadyForQuery:
			expectedState = connStateExpectResponse
		default:
			panic(fmt.Sprintf("unexpected listenerConnState %d", newState))
		}

		return atomic.CompareAndSwapInt32(&l.connState, expectedState, newState)
	}

	// Main logic is here: receive messages from the postgres backend, forward
	// notifications and query replies and keep the internal state in sync with the
	// protocol state.  Returns when the connection has been lost, is about to go
	// away or should be discarded because we couldn't agree on the state with the
	// server backend.
	func (l *ListenerConn) listenerConnLoop() (err error) {
		defer l.cn.errRecover(&err)

		r := &readBuf{}
		for {
			t, err := l.cn.recvMessage(r)
			if err != nil {
				return err
			}

			switch t {
			case 'A':
				// recvNotification copies all the data so we don't need to worry
				// about the scratch buffer being overwritten.
				l.notificationChan <- recvNotification(r)

			case 'E':
				// We might receive an ErrorResponse even when not in a query; it
				// is expected that the server will close the connection after
				// that, but we should make sure that the error we display is the
				// one from the stray ErrorResponse, not io.ErrUnexpectedEOF.
				if !l.setState(connStateExpectReadyForQuery) {
					return parseError(r)
				}
				l.replyChan <- message{t, parseError(r)}

			case 'C', 'I':
				if !l.setState(connStateExpectReadyForQuery) {
					// protocol out of sync
					return fmt.Errorf("unexpected CommandComplete")
				}
				// ExecSimpleQuery doesn't need to know about this message

			case 'Z':
				if !l.setState(connStateIdle) {
					// protocol out of sync
					return fmt.Errorf("unexpected ReadyForQuery")
				}
				l.replyChan <- message{t, nil}

			case 'N', 'S':
				// ignore
			default:
				return fmt.Errorf("unexpected message %q from server in listenerConnLoop", t)
			}
		}
	}

	// This is the main routine for the goroutine receiving on the database
	// connection.  Most of the main logic is in listenerConnLoop.
	func (l *ListenerConn) listenerConnMain() {
		err := l.listenerConnLoop()

		// listenerConnLoop terminated; we're done, but we still have to clean up.
		// Make sure nobody tries to start any new queries by making sure the err
		// pointer is set.  It is important that we do not overwrite its value; a
		// connection could be closed by either this goroutine or one sending on
		// the connection -- whoever closes the connection is assumed to have the
		// more meaningful error message (as the other one will probably get
		// net.errClosed), so that goroutine sets the error we expose while the
		// other error is discarded.  If the connection is lost while two
		// goroutines are operating on the socket, it probably doesn't matter which
		// error we expose so we don't try to do anything more complex.
		l.connectionLock.Lock()
		if l.err == nil {
			l.err = err
		}
		l.cn.Close()
		l.connectionLock.Unlock()

		// There might be a query in-flight; make sure nobody's waiting for a
		// response to it, since there's not going to be one.
		close(l.replyChan)

		// let the listener know we're done
		close(l.notificationChan)

		// this ListenerConn is done
	}

	// Send a LISTEN query to the server.  See ExecSimpleQuery.
	func (l *ListenerConn) Listen(channel string) (bool, error) {
		return l.ExecSimpleQuery("LISTEN " + QuoteIdentifier(channel))
	}

	// Send an UNLISTEN query to the server.  See ExecSimpleQuery.
	func (l *ListenerConn) Unlisten(channel string) (bool, error) {
		return l.ExecSimpleQuery("UNLISTEN " + QuoteIdentifier(channel))
	}

	// Send `UNLISTEN *` to the server.  See ExecSimpleQuery.
	func (l *ListenerConn) UnlistenAll() (bool, error) {
		return l.ExecSimpleQuery("UNLISTEN *")
	}

	// Ping the remote server to make sure it's alive.  Non-nil error means the
	// connection has failed and should be abandoned.
	func (l *ListenerConn) Ping() error {
		sent, err := l.ExecSimpleQuery("")
		if !sent {
			return err
		}
		if err != nil {
			// shouldn't happen
			panic(err)
		}
		return nil
	}

	// Attempt to send a query on the connection.  Returns an error if sending the
	// query failed, and the caller should initiate closure of this connection.
	// The caller must be holding senderLock (see acquireSenderLock and
	// releaseSenderLock).
	func (l *ListenerConn) sendSimpleQuery(q string) (err error) {
		defer l.cn.errRecover(&err)

		// must set connection state before sending the query
		if !l.setState(connStateExpectResponse) {
			panic("two queries running at the same time")
		}

		// Can't use l.cn.writeBuf here because it uses the scratch buffer which
		// might get overwritten by listenerConnLoop.
		data := writeBuf([]byte("Q\x00\x00\x00\x00"))
		b := &data
		b.string(q)
		l.cn.send(b)

		return nil
	}

	// Execute a "simple query" (i.e. one with no bindable parameters) on the
	// connection.  The possible return values are:
	//   1) "executed" is true; the query was executed to completion on the
	//      database server.  If the query failed, err will be set to the error
	//      returned by the database, otherwise err will be nil.
	//   2) If "executed" is false, the query could not be executed on the remote
	//      server.  err will be non-nil.
	//
	// After a call to ExecSimpleQuery has returned an executed=false value, the
	// connection has either been closed or will be closed shortly thereafter, and
	// all subsequently executed queries will return an error.
	func (l *ListenerConn) ExecSimpleQuery(q string) (executed bool, err error) {
		if err = l.acquireSenderLock(); err != nil {
			return false, err
		}
		defer l.releaseSenderLock()

		err = l.sendSimpleQuery(q)
		if err != nil {
			// We can't know what state the protocol is in, so we need to abandon
			// this connection.
			l.connectionLock.Lock()
			defer l.connectionLock.Unlock()
			// Set the error pointer if it hasn't been set already; see
			// listenerConnMain.
			if l.err == nil {
				l.err = err
			}
			l.cn.Close()
			return false, err
		}

		// now we just wait for a reply..
		for {
			m, ok := <-l.replyChan
			if !ok {
				// We lost the connection to server, don't bother waiting for a
				// a response.
				return false, io.EOF
			}
			switch m.typ {
			case 'Z':
				// sanity check
				if m.err != nil {
					panic("m.err != nil")
				}
				// done; err might or might not be set
				return true, err

			case 'E':
				// sanity check
				if m.err == nil {
					panic("m.err == nil")
				}
				// server responded with an error; ReadyForQuery to follow
				err = m.err

			default:
				return false, fmt.Errorf("unknown response for simple query: %q", m.typ)
			}
		}
	}

	func (l *ListenerConn) Close() error {
		l.connectionLock.Lock()
		defer l.connectionLock.Unlock()
		if l.err != nil {
			return errListenerConnClosed
		}
		l.err = errListenerConnClosed
		return l.cn.Close()
	}

	// Err() returns the reason the connection was closed.  It is not safe to call
	// this function until l.Notify has been closed.
	func (l *ListenerConn) Err() error {
		return l.err
	}

	var errListenerClosed = errors.New("pq: Listener has been closed")

	var ErrChannelAlreadyOpen = errors.New("pq: channel is already open")
	var ErrChannelNotOpen = errors.New("pq: channel is not open")

	type ListenerEventType int

	const (
		// Emitted only when the database connection has been initially
		// initialized.  err will always be nil.
		ListenerEventConnected ListenerEventType = iota

		// Emitted after a database connection has been lost, either because of an
		// error or because Close has been called.  err will be set to the reason
		// the database connection was lost.
		ListenerEventDisconnected

		// Emitted after a database connection has been re-established after
		// connection loss.  err will always be nil.  After this event has been
		// emitted, a nil pq.Notification is sent on the Listener.Notify channel.
		ListenerEventReconnected

		// Emitted after a connection to the database was attempted, but failed.
		// err will be set to an error describing why the connection attempt did
		// not succeed.
		ListenerEventConnectionAttemptFailed
	)

	type EventCallbackType func(event ListenerEventType, err error)

	// Listener provides an interface for listening to notifications from a
	// PostgreSQL database.  For general usage information, see section
	// "Notifications".
	//
	// Listener can safely be used from concurrently running goroutines.
	type Listener struct {
		// Channel for receiving notifications from the database.  In some cases a
		// nil value will be sent.  See section "Notifications" above.
		Notify chan *Notification

		name                 string
		minReconnectInterval time.Duration
		maxReconnectInterval time.Duration
		eventCallback        EventCallbackType

		lock                 sync.Mutex
		isClosed             bool
		reconnectCond        *sync.Cond
		cn                   *ListenerConn
		connNotificationChan <-chan *Notification
		channels             map[string]struct{}
	}

	// NewListener creates a new database connection dedicated to LISTEN / NOTIFY.
	//
	// name should be set to a connection string to be used to establish the
	// database connection (see section "Connection String Parameters" above).
	//
	// minReconnectInterval controls the duration to wait before trying to
	// re-establish the database connection after connection loss.  After each
	// consecutive failure this interval is doubled, until maxReconnectInterval is
	// reached.  Successfully completing the connection establishment procedure
	// resets the interval back to minReconnectInterval.
	//
	// The last parameter eventCallback can be set to a function which will be
	// called by the Listener when the state of the underlying database connection
	// changes.  This callback will be called by the goroutine which dispatches the
	// notifications over the Notify channel, so you should try to avoid doing
	// potentially time-consuming operations from the callback.
	func NewListener(name string,
		minReconnectInterval time.Duration,
		maxReconnectInterval time.Duration,
		eventCallback EventCallbackType) *Listener {
		l := &Listener{
			name:                 name,
			minReconnectInterval: minReconnectInterval,
			maxReconnectInterval: maxReconnectInterval,
			eventCallback:        eventCallback,

			channels: make(map[string]struct{}),

			Notify: make(chan *Notification, 32),
		}
		l.reconnectCond = sync.NewCond(&l.lock)

		go l.listenerMain()

		return l
	}

	// Returns the notification channel for this listener.  This is the same
	// channel as Notify, and will not be recreated during the life time of the
	// Listener.
	func (l *Listener) NotificationChannel() <-chan *Notification {
		return l.Notify
	}

	// Listen starts listening for notifications on a channel.  Calls to this
	// function will block until an acknowledgement has been received from the
	// server.  Note that Listener automatically re-establishes the connection
	// after connection loss, so this function may block indefinitely if the
	// connection can not be re-established.
	//
	// Listen will only fail in three conditions:
	//   1) The channel is already open.  The returned error will be
	//      ErrChannelAlreadyOpen.
	//   2) The query was executed on the remote server, but PostgreSQL returned an
	//      error message in response to the query.  The returned error will be a
	//      pq.Error containing the information the server supplied.
	//   3) Close is called on the Listener before the request could be completed.
	//
	// The channel name is case-sensitive.
	func (l *Listener) Listen(channel string) error {
		l.lock.Lock()
		defer l.lock.Unlock()

		if l.isClosed {
			return errListenerClosed
		}

		// The server allows you to issue a LISTEN on a channel which is already
		// open, but it seems useful to be able to detect this case to spot for
		// mistakes in application logic.  If the application genuinely does't
		// care, it can check the exported error and ignore it.
		_, exists := l.channels[channel]
		if exists {
			return ErrChannelAlreadyOpen
		}

		if l.cn != nil {
			// If gotResponse is true but error is set, the query was executed on
			// the remote server, but resulted in an error.  This should be
			// relatively rare, so it's fine if we just pass the error to our
			// caller.  However, if gotResponse is false, we could not complete the
			// query on the remote server and our underlying connection is about
			// to go away, so we only add relname to l.channels, and wait for
			// resync() to take care of the rest.
			gotResponse, err := l.cn.Listen(channel)
			if gotResponse && err != nil {
				return err
			}
		}

		l.channels[channel] = struct{}{}
		for l.cn == nil {
			l.reconnectCond.Wait()
			// we let go of the mutex for a while
			if l.isClosed {
				return errListenerClosed
			}
		}

		return nil
	}

	// Unlisten removes a channel from the Listener's channel list.  Returns
	// ErrChannelNotOpen if the Listener is not listening on the specified channel.
	// Returns immediately with no error if there is no connection.  Note that you
	// might still get notifications for this channel even after Unlisten has
	// returned.
	//
	// The channel name is case-sensitive.
	func (l *Listener) Unlisten(channel string) error {
		l.lock.Lock()
		defer l.lock.Unlock()

		if l.isClosed {
			return errListenerClosed
		}

		// Similarly to LISTEN, this is not an error in Postgres, but it seems
		// useful to distinguish from the normal conditions.
		_, exists := l.channels[channel]
		if !exists {
			return ErrChannelNotOpen
		}

		if l.cn != nil {
			// Similarly to Listen (see comment in that function), the caller
			// should only be bothered with an error if it came from the backend as
			// a response to our query.
			gotResponse, err := l.cn.Unlisten(channel)
			if gotResponse && err != nil {
				return err
			}
		}

		// Don't bother waiting for resync if there's no connection.
		delete(l.channels, channel)
		return nil
	}

	// UnlistenAll removes all channels from the Listener's channel list.  Returns
	// immediately with no error if there is no connection.  Note that you might
	// still get notifications for any of the deleted channels even after
	// UnlistenAll has returned.
	func (l *Listener) UnlistenAll() error {
		l.lock.Lock()
		defer l.lock.Unlock()

		if l.isClosed {
			return errListenerClosed
		}

		if l.cn != nil {
			// Similarly to Listen (see comment in that function), the caller
			// should only be bothered with an error if it came from the backend as
			// a response to our query.
			gotResponse, err := l.cn.UnlistenAll()
			if gotResponse && err != nil {
				return err
			}
		}

		// Don't bother waiting for resync if there's no connection.
		l.channels = make(map[string]struct{})
		return nil
	}

	// Ping the remote server to make sure it's alive.  Non-nil return value means
	// that there is no active connection.
	func (l *Listener) Ping() error {
		l.lock.Lock()
		defer l.lock.Unlock()

		if l.isClosed {
			return errListenerClosed
		}
		if l.cn == nil {
			return errors.New("no connection")
		}

		return l.cn.Ping()
	}

	// Clean up after losing the server connection.  Returns l.cn.Err(), which
	// should have the reason the connection was lost.
	func (l *Listener) disconnectCleanup() error {
		l.lock.Lock()
		defer l.lock.Unlock()

		// sanity check; can't look at Err() until the channel has been closed
		select {
		case _, ok := <-l.connNotificationChan:
			if ok {
				panic("connNotificationChan not closed")
			}
		default:
			panic("connNotificationChan not closed")
		}

		err := l.cn.Err()
		l.cn.Close()
		l.cn = nil
		return err
	}

	// Synchronize the list of channels we want to be listening on with the server
	// after the connection has been established.
	func (l *Listener) resync(cn *ListenerConn, notificationChan <-chan *Notification) error {
		doneChan := make(chan error)
		go func() {
			for channel := range l.channels {
				// If we got a response, return that error to our caller as it's
				// going to be more descriptive than cn.Err().
				gotResponse, err := cn.Listen(channel)
				if gotResponse && err != nil {
					doneChan <- err
					return
				}

				// If we couldn't reach the server, wait for notificationChan to
				// close and then return the error message from the connection, as
				// per ListenerConn's interface.
				if err != nil {
					for _ = range notificationChan {
					}
					doneChan <- cn.Err()
					return
				}
			}
			doneChan <- nil
		}()

		// Ignore notifications while synchronization is going on to avoid
		// deadlocks.  We have to send a nil notification over Notify anyway as
		// we can't possibly know which notifications (if any) were lost while
		// the connection was down, so there's no reason to try and process
		// these messages at all.
		for {
			select {
			case _, ok := <-notificationChan:
				if !ok {
					notificationChan = nil
				}

			case err := <-doneChan:
				return err
			}
		}
	}

	// caller should NOT be holding l.lock
	func (l *Listener) closed() bool {
		l.lock.Lock()
		defer l.lock.Unlock()

		return l.isClosed
	}

	func (l *Listener) connect() error {
		notificationChan := make(chan *Notification, 32)
		cn, err := NewListenerConn(l.name, notificationChan)
		if err != nil {
			return err
		}

		l.lock.Lock()
		defer l.lock.Unlock()

		err = l.resync(cn, notificationChan)
		if err != nil {
			cn.Close()
			return err
		}

		l.cn = cn
		l.connNotificationChan = notificationChan
		l.reconnectCond.Broadcast()

		return nil
	}

	// Close disconnects the Listener from the database and shuts it down.
	// Subsequent calls to its methods will return an error.  Close returns an
	// error if the connection has already been closed.
	func (l *Listener) Close() error {
		l.lock.Lock()
		defer l.lock.Unlock()

		if l.isClosed {
			return errListenerClosed
		}

		if l.cn != nil {
			l.cn.Close()
		}
		l.isClosed = true

		return nil
	}

	func (l *Listener) emitEvent(event ListenerEventType, err error) {
		if l.eventCallback != nil {
			l.eventCallback(event, err)
		}
	}

	// Main logic here: maintain a connection to the server when possible, wait
	// for notifications and emit events.
	func (l *Listener) listenerConnLoop() {
		var nextReconnect time.Time

		reconnectInterval := l.minReconnectInterval
		for {
			for {
				err := l.connect()
				if err == nil {
					break
				}

				if l.closed() {
					return
				}
				l.emitEvent(ListenerEventConnectionAttemptFailed, err)

				time.Sleep(reconnectInterval)
				reconnectInterval *= 2
				if reconnectInterval > l.maxReconnectInterval {
					reconnectInterval = l.maxReconnectInterval
				}
			}

			if nextReconnect.IsZero() {
				l.emitEvent(ListenerEventConnected, nil)
			} else {
				l.emitEvent(ListenerEventReconnected, nil)
				l.Notify <- nil
			}

			reconnectInterval = l.minReconnectInterval
			nextReconnect = time.Now().Add(reconnectInterval)

			for {
				notification, ok := <-l.connNotificationChan
				if !ok {
					// lost connection, loop again
					break
				}
				l.Notify <- notification
			}

			err := l.disconnectCleanup()
			if l.closed() {
				return
			}
			l.emitEvent(ListenerEventDisconnected, err)

			time.Sleep(nextReconnect.Sub(time.Now()))
		}
	}

	func (l *Listener) listenerMain() {
		l.listenerConnLoop()
		close(l.Notify)
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_notify_test
	package pq

	import (
		"errors"
		"fmt"
		"io"
		"os"
		"testing"
		"time"
	)

	var errNilNotification = errors.New("nil notification")

	func expectNotification(t *testing.T, ch <-chan *Notification, relname string, extra string) error {
		select {
		case n := <-ch:
			if n == nil {
				return errNilNotification
			}
			if n.Channel != relname || n.Extra != extra {
				return fmt.Errorf("unexpected notification %v", n)
			}
			return nil
		case <-time.After(1500 * time.Millisecond):
			return fmt.Errorf("timeout")
		}
	}

	func expectNoNotification(t *testing.T, ch <-chan *Notification) error {
		select {
		case n := <-ch:
			return fmt.Errorf("unexpected notification %v", n)
		case <-time.After(100 * time.Millisecond):
			return nil
		}
	}

	func expectEvent(t *testing.T, eventch <-chan ListenerEventType, et ListenerEventType) error {
		select {
		case e := <-eventch:
			if e != et {
				return fmt.Errorf("unexpected event %v", e)
			}
			return nil
		case <-time.After(1500 * time.Millisecond):
			panic("expectEvent timeout")
		}
	}

	func expectNoEvent(t *testing.T, eventch <-chan ListenerEventType) error {
		select {
		case e := <-eventch:
			return fmt.Errorf("unexpected event %v", e)
		case <-time.After(100 * time.Millisecond):
			return nil
		}
	}

	func newTestListenerConn(t *testing.T) (*ListenerConn, <-chan *Notification) {
		datname := os.Getenv("PGDATABASE")
		sslmode := os.Getenv("PGSSLMODE")

		if datname == "" {
			os.Setenv("PGDATABASE", "pqgotest")
		}

		if sslmode == "" {
			os.Setenv("PGSSLMODE", "disable")
		}

		notificationChan := make(chan *Notification)
		l, err := NewListenerConn("", notificationChan)
		if err != nil {
			t.Fatal(err)
		}

		return l, notificationChan
	}

	func TestNewListenerConn(t *testing.T) {
		l, _ := newTestListenerConn(t)

		defer l.Close()
	}

	func TestConnListen(t *testing.T) {
		l, channel := newTestListenerConn(t)

		defer l.Close()

		db := openTestConn(t)
		defer db.Close()

		ok, err := l.Listen("notify_test")
		if !ok || err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("NOTIFY notify_test")
		if err != nil {
			t.Fatal(err)
		}

		err = expectNotification(t, channel, "notify_test", "")
		if err != nil {
			t.Fatal(err)
		}
	}

	func TestConnUnlisten(t *testing.T) {
		l, channel := newTestListenerConn(t)

		defer l.Close()

		db := openTestConn(t)
		defer db.Close()

		ok, err := l.Listen("notify_test")
		if !ok || err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("NOTIFY notify_test")

		err = expectNotification(t, channel, "notify_test", "")
		if err != nil {
			t.Fatal(err)
		}

		ok, err = l.Unlisten("notify_test")
		if !ok || err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("NOTIFY notify_test")
		if err != nil {
			t.Fatal(err)
		}

		err = expectNoNotification(t, channel)
		if err != nil {
			t.Fatal(err)
		}
	}

	func TestConnUnlistenAll(t *testing.T) {
		l, channel := newTestListenerConn(t)

		defer l.Close()

		db := openTestConn(t)
		defer db.Close()

		ok, err := l.Listen("notify_test")
		if !ok || err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("NOTIFY notify_test")

		err = expectNotification(t, channel, "notify_test", "")
		if err != nil {
			t.Fatal(err)
		}

		ok, err = l.UnlistenAll()
		if !ok || err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("NOTIFY notify_test")
		if err != nil {
			t.Fatal(err)
		}

		err = expectNoNotification(t, channel)
		if err != nil {
			t.Fatal(err)
		}
	}

	func TestConnClose(t *testing.T) {
		l, _ := newTestListenerConn(t)
		defer l.Close()

		err := l.Close()
		if err != nil {
			t.Fatal(err)
		}
		err = l.Close()
		if err != errListenerConnClosed {
			t.Fatalf("expected errListenerConnClosed; got %v", err)
		}
	}

	func TestConnPing(t *testing.T) {
		l, _ := newTestListenerConn(t)
		defer l.Close()
		err := l.Ping()
		if err != nil {
			t.Fatal(err)
		}
		err = l.Close()
		if err != nil {
			t.Fatal(err)
		}
		err = l.Ping()
		if err != errListenerConnClosed {
			t.Fatalf("expected errListenerConnClosed; got %v", err)
		}
	}

	func TestNotifyExtra(t *testing.T) {
		db := openTestConn(t)
		defer db.Close()

		if getServerVersion(t, db) < 90000 {
			t.Skip("skipping NOTIFY payload test since the server does not appear to support it")
		}

		l, channel := newTestListenerConn(t)
		defer l.Close()

		ok, err := l.Listen("notify_test")
		if !ok || err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("NOTIFY notify_test, 'something'")
		if err != nil {
			t.Fatal(err)
		}

		err = expectNotification(t, channel, "notify_test", "something")
		if err != nil {
			t.Fatal(err)
		}
	}

	// create a new test listener and also set the timeouts
	func newTestListenerTimeout(t *testing.T, min time.Duration, max time.Duration) (*Listener, <-chan ListenerEventType) {
		datname := os.Getenv("PGDATABASE")
		sslmode := os.Getenv("PGSSLMODE")

		if datname == "" {
			os.Setenv("PGDATABASE", "pqgotest")
		}

		if sslmode == "" {
			os.Setenv("PGSSLMODE", "disable")
		}

		eventch := make(chan ListenerEventType, 16)
		l := NewListener("", min, max, func(t ListenerEventType, err error) { eventch <- t })
		err := expectEvent(t, eventch, ListenerEventConnected)
		if err != nil {
			t.Fatal(err)
		}
		return l, eventch
	}

	func newTestListener(t *testing.T) (*Listener, <-chan ListenerEventType) {
		return newTestListenerTimeout(t, time.Hour, time.Hour)
	}

	func TestListenerListen(t *testing.T) {
		l, _ := newTestListener(t)
		defer l.Close()

		db := openTestConn(t)
		defer db.Close()

		err := l.Listen("notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("NOTIFY notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		err = expectNotification(t, l.Notify, "notify_listen_test", "")
		if err != nil {
			t.Fatal(err)
		}
	}

	func TestListenerUnlisten(t *testing.T) {
		l, _ := newTestListener(t)
		defer l.Close()

		db := openTestConn(t)
		defer db.Close()

		err := l.Listen("notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("NOTIFY notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		err = l.Unlisten("notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		err = expectNotification(t, l.Notify, "notify_listen_test", "")
		if err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("NOTIFY notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		err = expectNoNotification(t, l.Notify)
		if err != nil {
			t.Fatal(err)
		}
	}

	func TestListenerUnlistenAll(t *testing.T) {
		l, _ := newTestListener(t)
		defer l.Close()

		db := openTestConn(t)
		defer db.Close()

		err := l.Listen("notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("NOTIFY notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		err = l.UnlistenAll()
		if err != nil {
			t.Fatal(err)
		}

		err = expectNotification(t, l.Notify, "notify_listen_test", "")
		if err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("NOTIFY notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		err = expectNoNotification(t, l.Notify)
		if err != nil {
			t.Fatal(err)
		}
	}

	func TestListenerFailedQuery(t *testing.T) {
		l, eventch := newTestListener(t)
		defer l.Close()

		db := openTestConn(t)
		defer db.Close()

		err := l.Listen("notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("NOTIFY notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		err = expectNotification(t, l.Notify, "notify_listen_test", "")
		if err != nil {
			t.Fatal(err)
		}

		// shouldn't cause a disconnect
		ok, err := l.cn.ExecSimpleQuery("SELECT error")
		if !ok {
			t.Fatalf("could not send query to server: %v", err)
		}
		_, ok = err.(PGError)
		if !ok {
			t.Fatalf("unexpected error %v", err)
		}
		err = expectNoEvent(t, eventch)
		if err != nil {
			t.Fatal(err)
		}

		// should still work
		_, err = db.Exec("NOTIFY notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		err = expectNotification(t, l.Notify, "notify_listen_test", "")
		if err != nil {
			t.Fatal(err)
		}
	}

	func TestListenerReconnect(t *testing.T) {
		l, eventch := newTestListenerTimeout(t, 20*time.Millisecond, time.Hour)
		defer l.Close()

		db := openTestConn(t)
		defer db.Close()

		err := l.Listen("notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		_, err = db.Exec("NOTIFY notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		err = expectNotification(t, l.Notify, "notify_listen_test", "")
		if err != nil {
			t.Fatal(err)
		}

		// kill the connection and make sure it comes back up
		ok, err := l.cn.ExecSimpleQuery("SELECT pg_terminate_backend(pg_backend_pid())")
		if ok {
			t.Fatalf("could not kill the connection: %v", err)
		}
		if err != io.EOF {
			t.Fatalf("unexpected error %v", err)
		}
		err = expectEvent(t, eventch, ListenerEventDisconnected)
		if err != nil {
			t.Fatal(err)
		}
		err = expectEvent(t, eventch, ListenerEventReconnected)
		if err != nil {
			t.Fatal(err)
		}

		// should still work
		_, err = db.Exec("NOTIFY notify_listen_test")
		if err != nil {
			t.Fatal(err)
		}

		// should get nil after Reconnected
		err = expectNotification(t, l.Notify, "", "")
		if err != errNilNotification {
			t.Fatal(err)
		}

		err = expectNotification(t, l.Notify, "notify_listen_test", "")
		if err != nil {
			t.Fatal(err)
		}
	}

	func TestListenerClose(t *testing.T) {
		l, _ := newTestListenerTimeout(t, 20*time.Millisecond, time.Hour)
		defer l.Close()

		err := l.Close()
		if err != nil {
			t.Fatal(err)
		}
		err = l.Close()
		if err != errListenerClosed {
			t.Fatalf("expected errListenerClosed; got %v", err)
		}
	}

	func TestListenerPing(t *testing.T) {
		l, _ := newTestListenerTimeout(t, 20*time.Millisecond, time.Hour)
		defer l.Close()

		err := l.Ping()
		if err != nil {
			t.Fatal(err)
		}

		err = l.Close()
		if err != nil {
			t.Fatal(err)
		}

		err = l.Ping()
		if err != errListenerClosed {
			t.Fatalf("expected errListenerClosed; got %v", err)
		}
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_oid_doc
	// Package oid contains OID constants
	// as defined by the Postgres server.
	package oid

	// Oid is a Postgres Object ID.
	type Oid uint32


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_oid_gen
	// +build ignore

	// Generate the table of OID values
	// Run with 'go run gen.go'.
	package main

	import (
		"database/sql"
		"fmt"
		"log"
		"os"
		"os/exec"

		_ "github.com/lib/pq"
	)

	func main() {
		datname := os.Getenv("PGDATABASE")
		sslmode := os.Getenv("PGSSLMODE")

		if datname == "" {
			os.Setenv("PGDATABASE", "pqgotest")
		}

		if sslmode == "" {
			os.Setenv("PGSSLMODE", "disable")
		}

		db, err := sql.Open("postgres", "")
		if err != nil {
			log.Fatal(err)
		}
		cmd := exec.Command("gofmt")
		cmd.Stderr = os.Stderr
		w, err := cmd.StdinPipe()
		if err != nil {
			log.Fatal(err)
		}
		f, err := os.Create("types.go")
		if err != nil {
			log.Fatal(err)
		}
		cmd.Stdout = f
		err = cmd.Start()
		if err != nil {
			log.Fatal(err)
		}
		fmt.Fprintln(w, "// generated by 'go run gen.go'; do not edit")
		fmt.Fprintln(w, "\npackage oid")
		fmt.Fprintln(w, "const (")
		rows, err := db.Query(`
			SELECT typname, oid
			FROM pg_type WHERE oid < 10000
			ORDER BY oid;
		`)
		if err != nil {
			log.Fatal(err)
		}
		var name string
		var oid int
		for rows.Next() {
			err = rows.Scan(&name, &oid)
			if err != nil {
				log.Fatal(err)
			}
			fmt.Fprintf(w, "T_%s Oid = %d\n", name, oid)
		}
		if err = rows.Err(); err != nil {
			log.Fatal(err)
		}
		fmt.Fprintln(w, ")")
		w.Close()
		cmd.Wait()
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_oid_types
	// generated by 'go run gen.go'; do not edit

	package oid

	const (
		T_bool             Oid = 16
		T_bytea            Oid = 17
		T_char             Oid = 18
		T_name             Oid = 19
		T_int8             Oid = 20
		T_int2             Oid = 21
		T_int2vector       Oid = 22
		T_int4             Oid = 23
		T_regproc          Oid = 24
		T_text             Oid = 25
		T_oid              Oid = 26
		T_tid              Oid = 27
		T_xid              Oid = 28
		T_cid              Oid = 29
		T_oidvector        Oid = 30
		T_pg_type          Oid = 71
		T_pg_attribute     Oid = 75
		T_pg_proc          Oid = 81
		T_pg_class         Oid = 83
		T_json             Oid = 114
		T_xml              Oid = 142
		T__xml             Oid = 143
		T_pg_node_tree     Oid = 194
		T__json            Oid = 199
		T_smgr             Oid = 210
		T_point            Oid = 600
		T_lseg             Oid = 601
		T_path             Oid = 602
		T_box              Oid = 603
		T_polygon          Oid = 604
		T_line             Oid = 628
		T__line            Oid = 629
		T_cidr             Oid = 650
		T__cidr            Oid = 651
		T_float4           Oid = 700
		T_float8           Oid = 701
		T_abstime          Oid = 702
		T_reltime          Oid = 703
		T_tinterval        Oid = 704
		T_unknown          Oid = 705
		T_circle           Oid = 718
		T__circle          Oid = 719
		T_money            Oid = 790
		T__money           Oid = 791
		T_macaddr          Oid = 829
		T_inet             Oid = 869
		T__bool            Oid = 1000
		T__bytea           Oid = 1001
		T__char            Oid = 1002
		T__name            Oid = 1003
		T__int2            Oid = 1005
		T__int2vector      Oid = 1006
		T__int4            Oid = 1007
		T__regproc         Oid = 1008
		T__text            Oid = 1009
		T__tid             Oid = 1010
		T__xid             Oid = 1011
		T__cid             Oid = 1012
		T__oidvector       Oid = 1013
		T__bpchar          Oid = 1014
		T__varchar         Oid = 1015
		T__int8            Oid = 1016
		T__point           Oid = 1017
		T__lseg            Oid = 1018
		T__path            Oid = 1019
		T__box             Oid = 1020
		T__float4          Oid = 1021
		T__float8          Oid = 1022
		T__abstime         Oid = 1023
		T__reltime         Oid = 1024
		T__tinterval       Oid = 1025
		T__polygon         Oid = 1027
		T__oid             Oid = 1028
		T_aclitem          Oid = 1033
		T__aclitem         Oid = 1034
		T__macaddr         Oid = 1040
		T__inet            Oid = 1041
		T_bpchar           Oid = 1042
		T_varchar          Oid = 1043
		T_date             Oid = 1082
		T_time             Oid = 1083
		T_timestamp        Oid = 1114
		T__timestamp       Oid = 1115
		T__date            Oid = 1182
		T__time            Oid = 1183
		T_timestamptz      Oid = 1184
		T__timestamptz     Oid = 1185
		T_interval         Oid = 1186
		T__interval        Oid = 1187
		T__numeric         Oid = 1231
		T_pg_database      Oid = 1248
		T__cstring         Oid = 1263
		T_timetz           Oid = 1266
		T__timetz          Oid = 1270
		T_bit              Oid = 1560
		T__bit             Oid = 1561
		T_varbit           Oid = 1562
		T__varbit          Oid = 1563
		T_numeric          Oid = 1700
		T_refcursor        Oid = 1790
		T__refcursor       Oid = 2201
		T_regprocedure     Oid = 2202
		T_regoper          Oid = 2203
		T_regoperator      Oid = 2204
		T_regclass         Oid = 2205
		T_regtype          Oid = 2206
		T__regprocedure    Oid = 2207
		T__regoper         Oid = 2208
		T__regoperator     Oid = 2209
		T__regclass        Oid = 2210
		T__regtype         Oid = 2211
		T_record           Oid = 2249
		T_cstring          Oid = 2275
		T_any              Oid = 2276
		T_anyarray         Oid = 2277
		T_void             Oid = 2278
		T_trigger          Oid = 2279
		T_language_handler Oid = 2280
		T_internal         Oid = 2281
		T_opaque           Oid = 2282
		T_anyelement       Oid = 2283
		T__record          Oid = 2287
		T_anynonarray      Oid = 2776
		T_pg_authid        Oid = 2842
		T_pg_auth_members  Oid = 2843
		T__txid_snapshot   Oid = 2949
		T_uuid             Oid = 2950
		T__uuid            Oid = 2951
		T_txid_snapshot    Oid = 2970
		T_fdw_handler      Oid = 3115
		T_anyenum          Oid = 3500
		T_tsvector         Oid = 3614
		T_tsquery          Oid = 3615
		T_gtsvector        Oid = 3642
		T__tsvector        Oid = 3643
		T__gtsvector       Oid = 3644
		T__tsquery         Oid = 3645
		T_regconfig        Oid = 3734
		T__regconfig       Oid = 3735
		T_regdictionary    Oid = 3769
		T__regdictionary   Oid = 3770
		T_anyrange         Oid = 3831
		T_event_trigger    Oid = 3838
		T_int4range        Oid = 3904
		T__int4range       Oid = 3905
		T_numrange         Oid = 3906
		T__numrange        Oid = 3907
		T_tsrange          Oid = 3908
		T__tsrange         Oid = 3909
		T_tstzrange        Oid = 3910
		T__tstzrange       Oid = 3911
		T_daterange        Oid = 3912
		T__daterange       Oid = 3913
		T_int8range        Oid = 3926
		T__int8range       Oid = 3927
	)


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_ssl_test
	package pq

	// This file contains SSL tests

	import (
		_ "crypto/sha256"
		"crypto/x509"
		"database/sql"
		"fmt"
		"os"
		"path/filepath"
		"testing"
	)

	func maybeSkipSSLTests(t *testing.T) {
		// Require some special variables for testing certificates
		if os.Getenv("PQSSLCERTTEST_PATH") == "" {
			t.Skip("PQSSLCERTTEST_PATH not set, skipping SSL tests")
		}

		value := os.Getenv("PQGOSSLTESTS")
		if value == "" || value == "0" {
			t.Skip("PQGOSSLTESTS not enabled, skipping SSL tests")
		} else if value != "1" {
			t.Fatalf("unexpected value %q for PQGOSSLTESTS", value)
		}
	}

	func openSSLConn(t *testing.T, conninfo string) (*sql.DB, error) {
		db, err := openTestConnConninfo(conninfo)
		if err != nil {
			// should never fail
			t.Fatal(err)
		}
		// Do something with the connection to see whether it's working or not.
		tx, err := db.Begin()
		if err == nil {
			return db, tx.Rollback()
		}
		_ = db.Close()
		return nil, err
	}

	func checkSSLSetup(t *testing.T, conninfo string) {
		db, err := openSSLConn(t, conninfo)
		if err == nil {
			db.Close()
			t.Fatalf("expected error with conninfo=%q", conninfo)
		}
	}

	// Connect over SSL and run a simple query to test the basics
	func TestSSLConnection(t *testing.T) {
		maybeSkipSSLTests(t)
		// Environment sanity check: should fail without SSL
		checkSSLSetup(t, "sslmode=disable user=pqgossltest")

		db, err := openSSLConn(t, "sslmode=require user=pqgossltest")
		if err != nil {
			t.Fatal(err)
		}
		rows, err := db.Query("SELECT 1")
		if err != nil {
			t.Fatal(err)
		}
		rows.Close()
	}

	// Test sslmode=verify-full
	func TestSSLVerifyFull(t *testing.T) {
		maybeSkipSSLTests(t)
		// Environment sanity check: should fail without SSL
		checkSSLSetup(t, "sslmode=disable user=pqgossltest")

		// Not OK according to the system CA
		_, err := openSSLConn(t, "host=postgres sslmode=verify-full user=pqgossltest")
		if err == nil {
			t.Fatal("expected error")
		}
		_, ok := err.(x509.UnknownAuthorityError)
		if !ok {
			t.Fatalf("expected x509.UnknownAuthorityError, got %#+v", err)
		}

		rootCertPath := filepath.Join(os.Getenv("PQSSLCERTTEST_PATH"), "root.crt")
		rootCert := "sslrootcert=" + rootCertPath + " "
		// No match on Common Name
		_, err = openSSLConn(t, rootCert+"host=127.0.0.1 sslmode=verify-full user=pqgossltest")
		if err == nil {
			t.Fatal("expected error")
		}
		_, ok = err.(x509.HostnameError)
		if !ok {
			t.Fatalf("expected x509.HostnameError, got %#+v", err)
		}
		// OK
		_, err = openSSLConn(t, rootCert+"host=postgres sslmode=verify-full user=pqgossltest")
		if err != nil {
			t.Fatal(err)
		}
	}

	// Test sslmode=verify-ca
	func TestSSLVerifyCA(t *testing.T) {
		maybeSkipSSLTests(t)
		// Environment sanity check: should fail without SSL
		checkSSLSetup(t, "sslmode=disable user=pqgossltest")

		// Not OK according to the system CA
		_, err := openSSLConn(t, "host=postgres sslmode=verify-ca user=pqgossltest")
		if err == nil {
			t.Fatal("expected error")
		}
		_, ok := err.(x509.UnknownAuthorityError)
		if !ok {
			t.Fatalf("expected x509.UnknownAuthorityError, got %#+v", err)
		}

		rootCertPath := filepath.Join(os.Getenv("PQSSLCERTTEST_PATH"), "root.crt")
		rootCert := "sslrootcert=" + rootCertPath + " "
		// No match on Common Name, but that's OK
		_, err = openSSLConn(t, rootCert+"host=127.0.0.1 sslmode=verify-ca user=pqgossltest")
		if err != nil {
			t.Fatal(err)
		}
		// Everything OK
		_, err = openSSLConn(t, rootCert+"host=postgres sslmode=verify-ca user=pqgossltest")
		if err != nil {
			t.Fatal(err)
		}
	}

	func getCertConninfo(t *testing.T, source string) string {
		var sslkey string
		var sslcert string

		certpath := os.Getenv("PQSSLCERTTEST_PATH")

		switch source {
		case "missingkey":
			sslkey = "/tmp/filedoesnotexist"
			sslcert = filepath.Join(certpath, "postgresql.crt")
		case "missingcert":
			sslkey = filepath.Join(certpath, "postgresql.key")
			sslcert = "/tmp/filedoesnotexist"
		case "certtwice":
			sslkey = filepath.Join(certpath, "postgresql.crt")
			sslcert = filepath.Join(certpath, "postgresql.crt")
		case "valid":
			sslkey = filepath.Join(certpath, "postgresql.key")
			sslcert = filepath.Join(certpath, "postgresql.crt")
		default:
			t.Fatalf("invalid source %q", source)
		}
		return fmt.Sprintf("sslmode=require user=pqgosslcert sslkey=%s sslcert=%s", sslkey, sslcert)
	}

	// Authenticate over SSL using client certificates
	func TestSSLClientCertificates(t *testing.T) {
		maybeSkipSSLTests(t)
		// Environment sanity check: should fail without SSL
		checkSSLSetup(t, "sslmode=disable user=pqgossltest")

		// Should also fail without a valid certificate
		db, err := openSSLConn(t, "sslmode=require user=pqgosslcert")
		if err == nil {
			db.Close()
			t.Fatal("expected error")
		}
		pge, ok := err.(*Error)
		if !ok {
			t.Fatal("expected pq.Error")
		}
		if pge.Code.Name() != "invalid_authorization_specification" {
			t.Fatalf("unexpected error code %q", pge.Code.Name())
		}

		// Should work
		db, err = openSSLConn(t, getCertConninfo(t, "valid"))
		if err != nil {
			t.Fatal(err)
		}
		rows, err := db.Query("SELECT 1")
		if err != nil {
			t.Fatal(err)
		}
		rows.Close()
	}

	// Test errors with ssl certificates
	func TestSSLClientCertificatesMissingFiles(t *testing.T) {
		maybeSkipSSLTests(t)
		// Environment sanity check: should fail without SSL
		checkSSLSetup(t, "sslmode=disable user=pqgossltest")

		// Key missing, should fail
		_, err := openSSLConn(t, getCertConninfo(t, "missingkey"))
		if err == nil {
			t.Fatal("expected error")
		}
		// should be a PathError
		_, ok := err.(*os.PathError)
		if !ok {
			t.Fatalf("expected PathError, got %#+v", err)
		}

		// Cert missing, should fail
		_, err = openSSLConn(t, getCertConninfo(t, "missingcert"))
		if err == nil {
			t.Fatal("expected error")
		}
		// should be a PathError
		_, ok = err.(*os.PathError)
		if !ok {
			t.Fatalf("expected PathError, got %#+v", err)
		}

		// Key has wrong permissions, should fail
		_, err = openSSLConn(t, getCertConninfo(t, "certtwice"))
		if err == nil {
			t.Fatal("expected error")
		}
		if err != ErrSSLKeyHasWorldPermissions {
			t.Fatalf("expected ErrSSLKeyHasWorldPermissions, got %#+v", err)
		}
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_url
	package pq

	import (
		"fmt"
		nurl "net/url"
		"sort"
		"strings"
	)

	// ParseURL no longer needs to be used by clients of this library since supplying a URL as a
	// connection string to sql.Open() is now supported:
	//
	//	sql.Open("postgres", "postgres://bob:secret@1.2.3.4:5432/mydb?sslmode=verify-full")
	//
	// It remains exported here for backwards-compatibility.
	//
	// ParseURL converts a url to a connection string for driver.Open.
	// Example:
	//
	//	"postgres://bob:secret@1.2.3.4:5432/mydb?sslmode=verify-full"
	//
	// converts to:
	//
	//	"user=bob password=secret host=1.2.3.4 port=5432 dbname=mydb sslmode=verify-full"
	//
	// A minimal example:
	//
	//	"postgres://"
	//
	// This will be blank, causing driver.Open to use all of the defaults
	func ParseURL(url string) (string, error) {
		u, err := nurl.Parse(url)
		if err != nil {
			return "", err
		}

		if u.Scheme != "postgres" {
			return "", fmt.Errorf("invalid connection protocol: %s", u.Scheme)
		}

		var kvs []string
		escaper := strings.NewReplacer(` `, `\ `, `'`, `\'`, `\`, `\\`)
		accrue := func(k, v string) {
			if v != "" {
				kvs = append(kvs, k+"="+escaper.Replace(v))
			}
		}

		if u.User != nil {
			v := u.User.Username()
			accrue("user", v)

			v, _ = u.User.Password()
			accrue("password", v)
		}

		i := strings.Index(u.Host, ":")
		if i < 0 {
			accrue("host", u.Host)
		} else {
			accrue("host", u.Host[:i])
			accrue("port", u.Host[i+1:])
		}

		if u.Path != "" {
			accrue("dbname", u.Path[1:])
		}

		q := u.Query()
		for k := range q {
			accrue(k, q.Get(k))
		}

		sort.Strings(kvs) // Makes testing easier (not a performance concern)
		return strings.Join(kvs, " "), nil
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_url_test
	package pq

	import (
		"testing"
	)

	func TestSimpleParseURL(t *testing.T) {
		expected := "host=hostname.remote"
		str, err := ParseURL("postgres://hostname.remote")
		if err != nil {
			t.Fatal(err)
		}

		if str != expected {
			t.Fatalf("unexpected result from ParseURL:\n+ %v\n- %v", str, expected)
		}
	}

	func TestFullParseURL(t *testing.T) {
		expected := `dbname=database host=hostname.remote password=top\ secret port=1234 user=username`
		str, err := ParseURL("postgres://username:top%20secret@hostname.remote:1234/database")
		if err != nil {
			t.Fatal(err)
		}

		if str != expected {
			t.Fatalf("unexpected result from ParseURL:\n+ %s\n- %s", str, expected)
		}
	}

	func TestInvalidProtocolParseURL(t *testing.T) {
		_, err := ParseURL("http://hostname.remote")
		switch err {
		case nil:
			t.Fatal("Expected an error from parsing invalid protocol")
		default:
			msg := "invalid connection protocol: http"
			if err.Error() != msg {
				t.Fatalf("Unexpected error message:\n+ %s\n- %s",
					err.Error(), msg)
			}
		}
	}

	func TestMinimalURL(t *testing.T) {
		cs, err := ParseURL("postgres://")
		if err != nil {
			t.Fatal(err)
		}

		if cs != "" {
			t.Fatalf("expected blank connection string, got: %q", cs)
		}
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_user_posix
	// Package pq is a pure Go Postgres driver for the database/sql package.

	// +build darwin dragonfly freebsd linux nacl netbsd openbsd solaris

	package pq

	import (
		"os"
		"os/user"
	)

	func userCurrent() (string, error) {
		u, err := user.Current()
		if err == nil {
			return u.Username, nil
		}

		name := os.Getenv("USER")
		if name != "" {
			return name, nil
		}

		return "", ErrCouldNotDetectUsername
	}


snippet Deploying_Go_ws_h_Godeps__workspace_src_github.com_lib_pq_user_windows
	// Package pq is a pure Go Postgres driver for the database/sql package.
	package pq

	import (
		"path/filepath"
		"syscall"
	)

	// Perform Windows user name lookup identically to libpq.
	//
	// The PostgreSQL code makes use of the legacy Win32 function
	// GetUserName, and that function has not been imported into stock Go.
	// GetUserNameEx is available though, the difference being that a
	// wider range of names are available.  To get the output to be the
	// same as GetUserName, only the base (or last) component of the
	// result is returned.
	func userCurrent() (string, error) {
		pw_name := make([]uint16, 128)
		pwname_size := uint32(len(pw_name)) - 1
		err := syscall.GetUserNameEx(syscall.NameSamCompatible, &pw_name[0], &pwname_size)
		if err != nil {
			return "", ErrCouldNotDetectUsername
		}
		s := syscall.UTF16ToString(pw_name)
		u := filepath.Base(s)
		return u, nil
	}


snippet Deploying_Go_ws_h_server
	package main

	import (
		"encoding/json"
		"net/http"
		"path"
		"strconv"
		"os"
	)

	type Post struct {
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	func main() {
		server := http.Server{
			Addr: ":" + os.Getenv("PORT"),
		}
		http.HandleFunc("/post/", handlePost)
		server.ListenAndServe()
	}

	// main handler function
	func handlePost(w http.ResponseWriter, r *http.Request) {
		var err error
		switch r.Method {
		case "GET":
			err = getPost(w, r)
		case "POST":
			err = postPost(w, r)
		case "PUT":
			err = putPost(w, r)
		case "DELETE":
			err = deletePost(w, r)
		}
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	// Retrieve a post
	// GET /post/1
	func getPost(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrievePost(id)
		if err != nil {
			return
		}
		output, err := json.MarshalIndent(&post, "", "\t\t")
		if err != nil {
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Write(output)
		return
	}

	// Create a post
	// POST /post/
	func postPost(w http.ResponseWriter, r *http.Request) (err error) {
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		var post Post
		json.Unmarshal(body, &post)
		err = post.create()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Update a post
	// PUT /post/1
	func putPost(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrievePost(id)
		if err != nil {
			return
		}
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, &post)
		err = post.update()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Delete a post
	// DELETE /post/1
	func deletePost(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrievePost(id)
		if err != nil {
			return
		}
		err = post.delete()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}


snippet Deploying_Go_ws_s_data
	package main

	import (
		"database/sql"
		_ "github.com/lib/pq"
	)

	var Db *sql.DB

	// connect to the Db
	func init() {
		var err error
		Db, err = sql.Open("postgres", "host=babar.elephantsql.com user=qjnqlnxs dbname=qjnqlnxs password=VSIjUweR1jWi3lf33R9EmlYVppgFJrwu sslmode=disable")
		if err != nil {
			panic(err)
		}
	}

	// Get a single post
	func retrievePost(id int) (post Post, err error) {
		post = Post{}
		err = Db.QueryRow("select id, content, author from posts where id = $1", id).Scan(&post.Id, &post.Content, &post.Author)
		return
	}

	// Create a new post
	func (post *Post) create() (err error) {
		statement := "insert into posts (content, author) values ($1, $2) returning id"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		err = stmt.QueryRow(post.Content, post.Author).Scan(&post.Id)
		return
	}

	// Update a post
	func (post *Post) update() (err error) {
		_, err = Db.Exec("update posts set content = $2, author = $3 where id = $1", post.Id, post.Content, post.Author)
		return
	}

	// Delete a post
	func (post *Post) delete() (err error) {
		_, err = Db.Exec("delete from posts where id = $1", post.Id)
		return
	}


snippet Deploying_Go_ws_s_server
	package main

	import (
		"encoding/json"
		"net/http"
		"path"
		"strconv"
	)

	type Post struct {
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	func main() {
		server := http.Server{
			Addr: ":8080",
		}
		http.HandleFunc("/post/", handlePost)
		server.ListenAndServe()
	}

	// main handler function
	func handlePost(w http.ResponseWriter, r *http.Request) {
		var err error
		switch r.Method {
		case "GET":
			err = getPost(w, r)
		case "POST":
			err = postPost(w, r)
		case "PUT":
			err = putPost(w, r)
		case "DELETE":
			err = deletePost(w, r)
		}
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	// Retrieve a post
	// GET /post/1
	func getPost(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrievePost(id)
		if err != nil {
			return
		}
		output, err := json.MarshalIndent(&post, "", "\t\t")
		if err != nil {
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Write(output)
		return
	}

	// Create a post
	// POST /post/
	func postPost(w http.ResponseWriter, r *http.Request) (err error) {
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		var post Post
		json.Unmarshal(body, &post)
		err = post.create()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Update a post
	// PUT /post/1
	func putPost(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrievePost(id)
		if err != nil {
			return
		}
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, &post)
		err = post.update()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Delete a post
	// DELETE /post/1
	func deletePost(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrievePost(id)
		if err != nil {
			return
		}
		err = post.delete()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}


snippet Go_And_Web_Applications_first_webapp_server
	package main

	import (
		"fmt"
		"net/http"
	)

	func handler(writer http.ResponseWriter, request *http.Request) {
		fmt.Fprintf(writer, "Hello World, %s!", request.URL.Path[1:])
	}

	func main() {
		http.HandleFunc("/", handler)
		http.ListenAndServe(":8080", nil)
	}


snippet Go_ChitChat_chitchat_data_data
	package data

	import (
		"crypto/rand"
		"crypto/sha1"
		"database/sql"
		"fmt"
		_ "github.com/lib/pq"
		"log"
	)

	var Db *sql.DB

	func init() {
		var err error
		Db, err = sql.Open("postgres", "dbname=chitchat sslmode=disable")
		if err != nil {
			log.Fatal(err)
		}
		return
	}

	// create a random UUID with from RFC 4122
	// adapted from http://github.com/nu7hatch/gouuid
	func createUUID() (uuid string) {
		u := new([16]byte)
		_, err := rand.Read(u[:])
		if err != nil {
			log.Fatalln("Cannot generate UUID", err)
		}

		// 0x40 is reserved variant from RFC 4122
		u[8] = (u[8] | 0x40) & 0x7F
		// Set the four most significant bits (bits 12 through 15) of the
		// time_hi_and_version field to the 4-bit version number.
		u[6] = (u[6] & 0xF) | (0x4 << 4)
		uuid = fmt.Sprintf("%x-%x-%x-%x-%x", u[0:4], u[4:6], u[6:8], u[8:10], u[10:])
		return
	}

	// hash plaintext with SHA-1
	func Encrypt(plaintext string) (cryptext string) {
		cryptext = fmt.Sprintf("%x", sha1.Sum([]byte(plaintext)))
		return
	}


snippet Go_ChitChat_chitchat_data_data_test
	package data

	// test data
	var users = []User{
		{
			Name:     "Peter Jones",
			Email:    "peter@gmail.com",
			Password: "peter_pass",
		},
		{
			Name:     "John Smith",
			Email:    "john@gmail.com",
			Password: "john_pass",
		},
	}

	func setup() {
		ThreadDeleteAll()
		SessionDeleteAll()
		UserDeleteAll()
	}


snippet Go_ChitChat_chitchat_data_thread
	package data

	import (
		"time"
	)

	type Thread struct {
		Id        int
		Uuid      string
		Topic     string
		UserId    int
		CreatedAt time.Time
	}

	type Post struct {
		Id        int
		Uuid      string
		Body      string
		UserId    int
		ThreadId  int
		CreatedAt time.Time
	}

	// format the CreatedAt date to display nicely on the screen
	func (thread *Thread) CreatedAtDate() string {
		return thread.CreatedAt.Format("Jan 2, 2006 at 3:04pm")
	}

	func (post *Post) CreatedAtDate() string {
		return post.CreatedAt.Format("Jan 2, 2006 at 3:04pm")
	}

	// get the number of posts in a thread
	func (thread *Thread) NumReplies() (count int) {
		rows, err := Db.Query("SELECT count(*) FROM posts where thread_id = $1", thread.Id)
		if err != nil {
			return
		}
		for rows.Next() {
			if err = rows.Scan(&count); err != nil {
				return
			}
		}
		rows.Close()
		return
	}

	// get posts to a thread
	func (thread *Thread) Posts() (posts []Post, err error) {
		rows, err := Db.Query("SELECT id, uuid, body, user_id, thread_id, created_at FROM posts where thread_id = $1", thread.Id)
		if err != nil {
			return
		}
		for rows.Next() {
			post := Post{}
			if err = rows.Scan(&post.Id, &post.Uuid, &post.Body, &post.UserId, &post.ThreadId, &post.CreatedAt); err != nil {
				return
			}
			posts = append(posts, post)
		}
		rows.Close()
		return
	}

	// Create a new thread
	func (user *User) CreateThread(topic string) (conv Thread, err error) {
		statement := "insert into threads (uuid, topic, user_id, created_at) values ($1, $2, $3, $4) returning id, uuid, topic, user_id, created_at"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		// use QueryRow to return a row and scan the returned id into the Session struct
		err = stmt.QueryRow(createUUID(), topic, user.Id, time.Now()).Scan(&conv.Id, &conv.Uuid, &conv.Topic, &conv.UserId, &conv.CreatedAt)
		return
	}

	// Create a new post to a thread
	func (user *User) CreatePost(conv Thread, body string) (post Post, err error) {
		statement := "insert into posts (uuid, body, user_id, thread_id, created_at) values ($1, $2, $3, $4, $5) returning id, uuid, body, user_id, thread_id, created_at"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		// use QueryRow to return a row and scan the returned id into the Session struct
		err = stmt.QueryRow(createUUID(), body, user.Id, conv.Id, time.Now()).Scan(&post.Id, &post.Uuid, &post.Body, &post.UserId, &post.ThreadId, &post.CreatedAt)
		return
	}

	// Get all threads in the database and returns it
	func Threads() (threads []Thread, err error) {
		rows, err := Db.Query("SELECT id, uuid, topic, user_id, created_at FROM threads ORDER BY created_at DESC")
		if err != nil {
			return
		}
		for rows.Next() {
			conv := Thread{}
			if err = rows.Scan(&conv.Id, &conv.Uuid, &conv.Topic, &conv.UserId, &conv.CreatedAt); err != nil {
				return
			}
			threads = append(threads, conv)
		}
		rows.Close()
		return
	}

	// Get a thread by the UUID
	func ThreadByUUID(uuid string) (conv Thread, err error) {
		conv = Thread{}
		err = Db.QueryRow("SELECT id, uuid, topic, user_id, created_at FROM threads WHERE uuid = $1", uuid).
			Scan(&conv.Id, &conv.Uuid, &conv.Topic, &conv.UserId, &conv.CreatedAt)
		return
	}

	// Get the user who started this thread
	func (thread *Thread) User() (user User) {
		user = User{}
		Db.QueryRow("SELECT id, uuid, name, email, created_at FROM users WHERE id = $1", thread.UserId).
			Scan(&user.Id, &user.Uuid, &user.Name, &user.Email, &user.CreatedAt)
		return
	}

	// Get the user who wrote the post
	func (post *Post) User() (user User) {
		user = User{}
		Db.QueryRow("SELECT id, uuid, name, email, created_at FROM users WHERE id = $1", post.UserId).
			Scan(&user.Id, &user.Uuid, &user.Name, &user.Email, &user.CreatedAt)
		return
	}


snippet Go_ChitChat_chitchat_data_thread_test
	package data

	//
	import (
		"testing"
	)

	// Delete all threads from database
	func ThreadDeleteAll() (err error) {
		db := db()
		defer db.Close()
		statement := "delete from threads"
		_, err = db.Exec(statement)
		if err != nil {
			return
		}
		return
	}

	func Test_CreateThread(t *testing.T) {
		setup()
		if err := users[0].Create(); err != nil {
			t.Error(err, "Cannot create user.")
		}
		conv, err := users[0].CreateThread("My first thread")
		if err != nil {
			t.Error(err, "Cannot create thread")
		}
		if conv.UserId != users[0].Id {
			t.Error("User not linked with thread")
		}
	}


snippet Go_ChitChat_chitchat_data_user
	package data

	import (
		"time"
	)

	type User struct {
		Id        int
		Uuid      string
		Name      string
		Email     string
		Password  string
		CreatedAt time.Time
	}

	type Session struct {
		Id        int
		Uuid      string
		Email     string
		UserId    int
		CreatedAt time.Time
	}

	// Create a new session for an existing user
	func (user *User) CreateSession() (session Session, err error) {
		statement := "insert into sessions (uuid, email, user_id, created_at) values ($1, $2, $3, $4) returning id, uuid, email, user_id, created_at"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		// use QueryRow to return a row and scan the returned id into the Session struct
		err = stmt.QueryRow(createUUID(), user.Email, user.Id, time.Now()).Scan(&session.Id, &session.Uuid, &session.Email, &session.UserId, &session.CreatedAt)
		return
	}

	// Get the session for an existing user
	func (user *User) Session() (session Session, err error) {
		session = Session{}
		err = Db.QueryRow("SELECT id, uuid, email, user_id, created_at FROM sessions WHERE user_id = $1", user.Id).
			Scan(&session.Id, &session.Uuid, &session.Email, &session.UserId, &session.CreatedAt)
		return
	}

	// Check if session is valid in the database
	func (session *Session) Check() (valid bool, err error) {
		err = Db.QueryRow("SELECT id, uuid, email, user_id, created_at FROM sessions WHERE uuid = $1", session.Uuid).
			Scan(&session.Id, &session.Uuid, &session.Email, &session.UserId, &session.CreatedAt)
		if err != nil {
			valid = false
			return
		}
		if session.Id != 0 {
			valid = true
		}
		return
	}

	// Delete session from database
	func (session *Session) DeleteByUUID() (err error) {
		statement := "delete from sessions where uuid = $1"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()

		_, err = stmt.Exec(session.Uuid)
		return
	}

	// Get the user from the session
	func (session *Session) User() (user User, err error) {
		user = User{}
		err = Db.QueryRow("SELECT id, uuid, name, email, created_at FROM users WHERE id = $1", session.UserId).
			Scan(&user.Id, &user.Uuid, &user.Name, &user.Email, &user.CreatedAt)
		return
	}

	// Delete all sessions from database
	func SessionDeleteAll() (err error) {
		statement := "delete from sessions"
		_, err = Db.Exec(statement)
		return
	}

	// Create a new user, save user info into the database
	func (user *User) Create() (err error) {
		// Postgres does not automatically return the last insert id, because it would be wrong to assume
		// you're always using a sequence.You need to use the RETURNING keyword in your insert to get this
		// information from postgres.
		statement := "insert into users (uuid, name, email, password, created_at) values ($1, $2, $3, $4, $5) returning id, uuid, created_at"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()

		// use QueryRow to return a row and scan the returned id into the User struct
		err = stmt.QueryRow(createUUID(), user.Name, user.Email, Encrypt(user.Password), time.Now()).Scan(&user.Id, &user.Uuid, &user.CreatedAt)
		return
	}

	// Delete user from database
	func (user *User) Delete() (err error) {
		statement := "delete from users where id = $1"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()

		_, err = stmt.Exec(user.Id)
		return
	}

	// Update user information in the database
	func (user *User) Update() (err error) {
		statement := "update users set name = $2, email = $3 where id = $1"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()

		_, err = stmt.Exec(user.Id, user.Name, user.Email)
		return
	}

	// Delete all users from database
	func UserDeleteAll() (err error) {
		statement := "delete from users"
		_, err = Db.Exec(statement)
		return
	}

	// Get all users in the database and returns it
	func Users() (users []User, err error) {
		rows, err := Db.Query("SELECT id, uuid, name, email, password, created_at FROM users")
		if err != nil {
			return
		}
		for rows.Next() {
			user := User{}
			if err = rows.Scan(&user.Id, &user.Uuid, &user.Name, &user.Email, &user.Password, &user.CreatedAt); err != nil {
				return
			}
			users = append(users, user)
		}
		rows.Close()
		return
	}

	// Get a single user given the email
	func UserByEmail(email string) (user User, err error) {
		user = User{}
		err = Db.QueryRow("SELECT id, uuid, name, email, password, created_at FROM users WHERE email = $1", email).
			Scan(&user.Id, &user.Uuid, &user.Name, &user.Email, &user.Password, &user.CreatedAt)
		return
	}

	// Get a single user given the UUID
	func UserByUUID(uuid string) (user User, err error) {
		user = User{}
		err = Db.QueryRow("SELECT id, uuid, name, email, password, created_at FROM users WHERE uuid = $1", uuid).
			Scan(&user.Id, &user.Uuid, &user.Name, &user.Email, &user.Password, &user.CreatedAt)
		return
	}


snippet Go_ChitChat_chitchat_data_user_test
	package data

	import (
		"database/sql"
		"testing"
	)

	func Test_UserCreate(t *testing.T) {
		setup()
		if err := users[0].Create(); err != nil {
			t.Error(err, "Cannot create user.")
		}
		if users[0].Id == 0 {
			t.Errorf("No id or created_at in user")
		}
		u, err := UserByEmail(users[0].Email)
		if err != nil {
			t.Error(err, "User not created.")
		}
		if users[0].Email != u.Email {
			t.Errorf("User retrieved is not the same as the one created.")
		}
	}

	func Test_UserDelete(t *testing.T) {
		setup()
		if err := users[0].Create(); err != nil {
			t.Error(err, "Cannot create user.")
		}
		if err := users[0].Delete(); err != nil {
			t.Error(err, "- Cannot delete user")
		}
		_, err := UserByEmail(users[0].Email)
		if err != sql.ErrNoRows {
			t.Error(err, "- User not deleted.")
		}
	}

	func Test_UserUpdate(t *testing.T) {
		setup()
		if err := users[0].Create(); err != nil {
			t.Error(err, "Cannot create user.")
		}
		users[0].Name = "Random User"
		if err := users[0].Update(); err != nil {
			t.Error(err, "- Cannot update user")
		}
		u, err := UserByEmail(users[0].Email)
		if err != nil {
			t.Error(err, "- Cannot get user")
		}
		if u.Name != "Random User" {
			t.Error(err, "- User not updated")
		}
	}

	func Test_UserByUUID(t *testing.T) {
		setup()
		if err := users[0].Create(); err != nil {
			t.Error(err, "Cannot create user.")
		}
		u, err := UserByUUID(users[0].Uuid)
		if err != nil {
			t.Error(err, "User not created.")
		}
		if users[0].Email != u.Email {
			t.Errorf("User retrieved is not the same as the one created.")
		}
	}

	func Test_Users(t *testing.T) {
		setup()
		for _, user := range users {
			if err := user.Create(); err != nil {
				t.Error(err, "Cannot create user.")
			}
		}
		u, err := Users()
		if err != nil {
			t.Error(err, "Cannot retrieve users.")
		}
		if len(u) != 2 {
			t.Error(err, "Wrong number of users retrieved")
		}
		if u[0].Email != users[0].Email {
			t.Error(u[0], users[0], "Wrong user retrieved")
		}
	}

	func Test_CreateSession(t *testing.T) {
		setup()
		if err := users[0].Create(); err != nil {
			t.Error(err, "Cannot create user.")
		}
		session, err := users[0].CreateSession()
		if err != nil {
			t.Error(err, "Cannot create session")
		}
		if session.UserId != users[0].Id {
			t.Error("User not linked with session")
		}
	}

	func Test_GetSession(t *testing.T) {
		setup()
		if err := users[0].Create(); err != nil {
			t.Error(err, "Cannot create user.")
		}
		session, err := users[0].CreateSession()
		if err != nil {
			t.Error(err, "Cannot create session")
		}

		s, err := users[0].Session()
		if err != nil {
			t.Error(err, "Cannot get session")
		}
		if s.Id == 0 {
			t.Error("No session retrieved")
		}
		if s.Id != session.Id {
			t.Error("Different session retrieved")
		}
	}

	func Test_checkValidSession(t *testing.T) {
		setup()
		if err := users[0].Create(); err != nil {
			t.Error(err, "Cannot create user.")
		}
		session, err := users[0].CreateSession()
		if err != nil {
			t.Error(err, "Cannot create session")
		}

		uuid := session.Uuid

		s := Session{Uuid: uuid}
		valid, err := s.Check()
		if err != nil {
			t.Error(err, "Cannot check session")
		}
		if valid != true {
			t.Error(err, "Session is not valid")
		}

	}

	func Test_checkInvalidSession(t *testing.T) {
		setup()
		s := Session{Uuid: "123"}
		valid, err := s.Check()
		if err == nil {
			t.Error(err, "Session is not valid but is validated")
		}
		if valid == true {
			t.Error(err, "Session is valid")
		}

	}

	func Test_DeleteSession(t *testing.T) {
		setup()
		if err := users[0].Create(); err != nil {
			t.Error(err, "Cannot create user.")
		}
		session, err := users[0].CreateSession()
		if err != nil {
			t.Error(err, "Cannot create session")
		}

		err = session.DeleteByUUID()
		if err != nil {
			t.Error(err, "Cannot delete session")
		}
		s := Session{Uuid: session.Uuid}
		valid, err := s.Check()
		if err == nil {
			t.Error(err, "Session is valid even though deleted")
		}
		if valid == true {
			t.Error(err, "Session is not deleted")
		}
	}


snippet Go_ChitChat_chitchat_main
	package main

	import (
		"net/http"
		"time"
	)

	func main() {
		p("ChitChat", version(), "started at", config.Address)

		// handle static assets
		mux := http.NewServeMux()
		files := http.FileServer(http.Dir(config.Static))
		mux.Handle("/static/", http.StripPrefix("/static/", files))

		//
		// all route patterns matched here
		// route handler functions defined in other files
		//

		// index
		mux.HandleFunc("/", index)
		// error
		mux.HandleFunc("/err", err)

snippet __ defined in route_auth
		mux.HandleFunc("/login", login)
		mux.HandleFunc("/logout", logout)
		mux.HandleFunc("/signup", signup)
		mux.HandleFunc("/signup_account", signupAccount)
		mux.HandleFunc("/authenticate", authenticate)

snippet __ defined in route_thread
		mux.HandleFunc("/thread/new", newThread)
		mux.HandleFunc("/thread/create", createThread)
		mux.HandleFunc("/thread/post", postThread)
		mux.HandleFunc("/thread/read", readThread)

		// starting up the server
		server := &http.Server{
			Addr:           config.Address,
			Handler:        mux,
			ReadTimeout:    time.Duration(config.ReadTimeout * int64(time.Second)),
			WriteTimeout:   time.Duration(config.WriteTimeout * int64(time.Second)),
			MaxHeaderBytes: 1 << 20,
		}
		server.ListenAndServe()
	}


snippet Go_ChitChat_chitchat_route_auth
	package main

	import (
		"net/http"

		"github.com/sausheong/gwp/Chapter_2_Go_ChitChat/chitchat/data"
	)

	// GET /login
	// Show the login page
	func login(writer http.ResponseWriter, request *http.Request) {
		t := parseTemplateFiles("login.layout", "public.navbar", "login")
		t.Execute(writer, nil)
	}

	// GET /signup
	// Show the signup page
	func signup(writer http.ResponseWriter, request *http.Request) {
		generateHTML(writer, nil, "login.layout", "public.navbar", "signup")
	}

	// POST /signup
	// Create the user account
	func signupAccount(writer http.ResponseWriter, request *http.Request) {
		err := request.ParseForm()
		if err != nil {
			danger(err, "Cannot parse form")
		}
		user := data.User{
			Name:     request.PostFormValue("name"),
			Email:    request.PostFormValue("email"),
			Password: request.PostFormValue("password"),
		}
		if err := user.Create(); err != nil {
			danger(err, "Cannot create user")
		}
		http.Redirect(writer, request, "/login", 302)
	}

	// POST /authenticate
	// Authenticate the user given the email and password
	func authenticate(writer http.ResponseWriter, request *http.Request) {
		err := request.ParseForm()
		user, err := data.UserByEmail(request.PostFormValue("email"))
		if err != nil {
			danger(err, "Cannot find user")
		}
		if user.Password == data.Encrypt(request.PostFormValue("password")) {
			session, err := user.CreateSession()
			if err != nil {
				danger(err, "Cannot create session")
			}
			cookie := http.Cookie{
				Name:     "_cookie",
				Value:    session.Uuid,
				HttpOnly: true,
			}
			http.SetCookie(writer, &cookie)
			http.Redirect(writer, request, "/", 302)
		} else {
			http.Redirect(writer, request, "/login", 302)
		}

	}

	// GET /logout
	// Logs the user out
	func logout(writer http.ResponseWriter, request *http.Request) {
		cookie, err := request.Cookie("_cookie")
		if err != http.ErrNoCookie {
			warning(err, "Failed to get cookie")
			session := data.Session{Uuid: cookie.Value}
			session.DeleteByUUID()
		}
		http.Redirect(writer, request, "/", 302)
	}


snippet Go_ChitChat_chitchat_route_auth_test
	package main

	import (
		"net/http"
		"net/http/httptest"
		"strings"
		"testing"
	)

	func Test_Get_Login(t *testing.T) {
		mux := http.NewServeMux()
		mux.HandleFunc("/login", login)

		writer := httptest.NewRecorder()
		request, _ := http.NewRequest("GET", "/login", nil)
		mux.ServeHTTP(writer, request)

		if writer.Code != 200 {
			t.Errorf("Response code is %v", writer.Code)
		}
		body := writer.Body.String()
		if strings.Contains(body, "Sign in") == false {
			t.Errorf("Body does not contain Sign in")
		}

	}


snippet Go_ChitChat_chitchat_route_main
	package main

	import (
		"github.com/sausheong/gwp/Chapter_2_Go_ChitChat/chitchat/data"
		"net/http"
	)

	// GET /err?msg=
	// shows the error message page
	func err(writer http.ResponseWriter, request *http.Request) {
		vals := request.URL.Query()
		_, err := session(writer, request)
		if err != nil {
			generateHTML(writer, vals.Get("msg"), "layout", "public.navbar", "error")
		} else {
			generateHTML(writer, vals.Get("msg"), "layout", "private.navbar", "error")
		}
	}

	func index(writer http.ResponseWriter, request *http.Request) {
		threads, err := data.Threads()
		if err != nil {
			error_message(writer, request, "Cannot get threads")
		} else {
			_, err := session(writer, request)
			if err != nil {
				generateHTML(writer, threads, "layout", "public.navbar", "index")
			} else {
				generateHTML(writer, threads, "layout", "private.navbar", "index")
			}
		}
	}

snippet session_parseForm_postformvalue
	// POST /signup
	// Create the user account
	func ${1:funcName}(writer http.ResponseWriter, request *http.Request) {
		sess, err := session(writer, request)
		if err != nil {
			http.Redirect(writer, request, "${2:/login}", 304)
		} else {
			err = request.ParseForm()
			if err != nil {
				danger(err, "Cannot parse form")
			}
			topic := request.PostFormValue("topic")
			${3:CodeHere}
		}
	}
	${0}

snippet session_do_if_not_error
	// POST /signup
	// Create the user account
	func ${1:funcName}(writer http.ResponseWriter, request *http.Request) {
		sess, err := session(writer, request)
		if err != nil {
			http.Redirect(writer, request, "${2:/login}", 304)
		} else {
			${3:CodeHere}
		}
	}
	${0}


snippet Go_ChitChat_chitchat_route_thread
	package main

	import (
		"fmt"
		"github.com/sausheong/gwp/Chapter_2_Go_ChitChat/chitchat/data"
		"net/http"
	)

	// GET /threads/new
	// Show the new thread form page
	func newThread(writer http.ResponseWriter, request *http.Request) {
		_, err := session(writer, request)
		if err != nil {
			http.Redirect(writer, request, "/login", 302)
		} else {
			generateHTML(writer, nil, "layout", "private.navbar", "new.thread")
		}
	}

	// POST /signup
	// Create the user account
	func createThread(writer http.ResponseWriter, request *http.Request) {
		sess, err := session(writer, request)
		if err != nil {
			http.Redirect(writer, request, "/login", 304)
		} else {
			err = request.ParseForm()
			if err != nil {
				danger(err, "Cannot parse form")
			}
			user, err := sess.User()
			if err != nil {
				danger(err, "Cannot get user from session")
			}
			topic := request.PostFormValue("topic")
			if _, err := user.CreateThread(topic); err != nil {
				danger(err, "Cannot create thread")
			}
			http.Redirect(writer, request, "/", 304)
		}
	}

	// GET /thread/read
	// Show the details of the thread, including the posts and the form to write a post
	func readThread(writer http.ResponseWriter, request *http.Request) {
		vals := request.URL.Query()
		uuid := vals.Get("id")
		thread, err := data.ThreadByUUID(uuid)
		if err != nil {
			error_message(writer, request, "Cannot read thread")
		} else {
			_, err := session(writer, request)
			if err != nil {
				generateHTML(writer, &thread, "layout", "public.navbar", "public.thread")
			} else {
				generateHTML(writer, &thread, "layout", "private.navbar", "private.thread")
			}
		}
	}

	// POST /thread/post
	// Create the post
	func postThread(writer http.ResponseWriter, request *http.Request) {
		sess, err := session(writer, request)
		if err != nil {
			http.Redirect(writer, request, "/login", 302)
		} else {
			err = request.ParseForm()
			if err != nil {
				danger(err, "Cannot parse form")
			}
			user, err := sess.User()
			if err != nil {
				danger(err, "Cannot get user from session")
			}
			body := request.PostFormValue("body")
			uuid := request.PostFormValue("uuid")
			thread, err := data.ThreadByUUID(uuid)
			if err != nil {
				error_message(writer, request, "Cannot read thread")
			}
			if _, err := user.CreatePost(thread, body); err != nil {
				danger(err, "Cannot create post")
			}
			url := fmt.Sprint("/thread/read?id=", uuid)
			http.Redirect(writer, request, url, 302)
		}
	}


snippet Go_ChitChat_chitchat_utils
	package main

	import (
		"encoding/json"
		"errors"
		"fmt"
		"github.com/sausheong/gwp/Chapter_2_Go_ChitChat/chitchat/data"
		"html/template"
		"log"
		"net/http"
		"os"
		"strings"
	)

	type Configuration struct {
		Address      string
		ReadTimeout  int64
		WriteTimeout int64
		Static       string
	}

	var config Configuration
	var logger *log.Logger

	// Convenience function for printing to stdout
	func p(a ...interface{}) {
		fmt.Println(a)
	}

	func init() {
		loadConfig()
		file, err := os.OpenFile("chitchat.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
		if err != nil {
			log.Fatalln("Failed to open log file", err)
		}
		logger = log.New(file, "INFO ", log.Ldate|log.Ltime|log.Lshortfile)
	}

	func loadConfig() {
		file, err := os.Open("config.json")
		if err != nil {
			log.Fatalln("Cannot open config file", err)
		}
		decoder := json.NewDecoder(file)
		config = Configuration{}
		err = decoder.Decode(&config)
		if err != nil {
			log.Fatalln("Cannot get configuration from file", err)
		}
	}

	// Convenience function to redirect to the error message page
	func error_message(writer http.ResponseWriter, request *http.Request, msg string) {
		url := []string{"/err?msg=", msg}
		http.Redirect(writer, request, strings.Join(url, ""), 302)
	}

	// Checks if the user is logged in and has a session, if not err is not nil
	func session(writer http.ResponseWriter, request *http.Request) (sess data.Session, err error) {
		cookie, err := request.Cookie("_cookie")
		if err == nil {
			sess = data.Session{Uuid: cookie.Value}
			if ok, _ := sess.Check(); !ok {
				err = errors.New("Invalid session")
			}
		}
		return
	}

	// parse HTML templates
	// pass in a list of file names, and get a template
	func parseTemplateFiles(filenames ...string) (t *template.Template) {
		var files []string
		t = template.New("layout")
		for _, file := range filenames {
			files = append(files, fmt.Sprintf("templates/%s.html", file))
		}
		t = template.Must(t.ParseFiles(files...))
		return
	}

	func generateHTML(writer http.ResponseWriter, data interface{}, filenames ...string) {
		var files []string
		for _, file := range filenames {
			files = append(files, fmt.Sprintf("templates/%s.html", file))
		}

		templates := template.Must(template.ParseFiles(files...))
		templates.ExecuteTemplate(writer, "layout", data)
	}

	// for logging
	func info(args ...interface{}) {
		logger.SetPrefix("INFO ")
		logger.Println(args...)
	}

	func danger(args ...interface{}) {
		logger.SetPrefix("ERROR ")
		logger.Println(args...)
	}

	func warning(args ...interface{}) {
		logger.SetPrefix("WARNING ")
		logger.Println(args...)
	}

	// version
	func version() string {
		return "0.1"
	}


snippet Handling_Requests_chain_handler_server
	package main

	import (
		"fmt"
		"net/http"
	)

	type HelloHandler struct{}

	func (h HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Hello!")
	}

	func log(h http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			fmt.Printf("Handler called - %T\n", h)
			h.ServeHTTP(w, r)
		})
	}

	func protect(h http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// some code to make sure the user is authorized
			h.ServeHTTP(w, r)
		})
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		hello := HelloHandler{}
		http.Handle("/hello", protect(log(hello)))
		server.ListenAndServe()
	}


snippet Handling_Requests_chain_handlerfunc_server
	package main

	import (
		"fmt"
		"net/http"
		"reflect"
		"runtime"
	)

	func hello(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Hello!")
	}

	func log(h http.HandlerFunc) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			name := runtime.FuncForPC(reflect.ValueOf(h).Pointer()).Name()
			fmt.Println("Handler function called - " + name)
			h(w, r)
		}
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/hello", log(hello))
		server.ListenAndServe()
	}


snippet Handling_Requests_configurable_server
	package main

	import (
		"net/http"
	)

	func main() {
		server := http.Server{
			Addr:    "127.0.0.1:8080",
			Handler: nil,
		}
		server.ListenAndServe()
	}


snippet Handling_Requests_gencert_gencert
	package main

	import (
		"crypto/rand"
		"crypto/rsa"
		"crypto/x509"
		"crypto/x509/pkix"
		"encoding/pem"
		"math/big"
		"net"
		"os"
		"time"
	)

	func main() {
		max := new(big.Int).Lsh(big.NewInt(1), 128)
		serialNumber, _ := rand.Int(rand.Reader, max)
		subject := pkix.Name{
			Organization:       []string{"Manning Publications Co."},
			OrganizationalUnit: []string{"Books"},
			CommonName:         "Go Web Programming",
		}

		template := x509.Certificate{
			SerialNumber: serialNumber,
			Subject:      subject,
			NotBefore:    time.Now(),
			NotAfter:     time.Now().Add(365 * 24 * time.Hour),
			KeyUsage:     x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
			ExtKeyUsage:  []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
			IPAddresses:  []net.IP{net.ParseIP("127.0.0.1")},
		}

		pk, _ := rsa.GenerateKey(rand.Reader, 2048)

		derBytes, _ := x509.CreateCertificate(rand.Reader, &template, &template, &pk.PublicKey, pk)
		certOut, _ := os.Create("cert.pem")
		pem.Encode(certOut, &pem.Block{Type: "CERTIFICATE", Bytes: derBytes})
		certOut.Close()

		keyOut, _ := os.Create("key.pem")
		pem.Encode(keyOut, &pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(pk)})
		keyOut.Close()
	}


snippet Handling_Requests_handler_server
	package main

	import (
		"fmt"
		"net/http"
	)

	type MyHandler struct{}

	func (h *MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Hello World!")
	}

	func main() {
		handler := MyHandler{}
		server := http.Server{
			Addr:    "127.0.0.1:8080",
			Handler: &handler,
		}
		server.ListenAndServe()
	}


snippet Handling_Requests_handlerfunc_server
	package main

	import (
		"fmt"
		"net/http"
	)

	func hello(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Hello!")
	}

	func world(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "World!")
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/hello", hello)
		http.HandleFunc("/world", world)

		server.ListenAndServe()
	}


snippet Handling_Requests_http2_server
	package main

	import (
		"fmt"
		"golang.org/x/net/http2"
		"net/http"
	)

	type MyHandler struct{}

	func (h *MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Hello World!")
	}

	func main() {
		handler := MyHandler{}
		server := http.Server{
			Addr:    "127.0.0.1:8080",
			Handler: &handler,
		}
		http2.ConfigureServer(&server, &http2.Server{})
		server.ListenAndServeTLS("cert.pem", "key.pem")
	}


snippet Handling_Requests_httprouter_server
	package main

	import (
		"fmt"
		"github.com/julienschmidt/httprouter"
		"net/http"
	)

	func hello(w http.ResponseWriter, r *http.Request, p httprouter.Params) {
		fmt.Fprintf(w, "hello, %s!\n", p.ByName("name"))
	}

	func main() {
		mux := httprouter.New()
		mux.GET("/hello/:name", hello)

		server := http.Server{
			Addr:    "127.0.0.1:8080",
			Handler: mux,
		}
		server.ListenAndServe()
	}


snippet Handling_Requests_https_server
	package main

	import (
		"net/http"
	)

	func main() {
		server := http.Server{
			Addr:    "127.0.0.1:8080",
			Handler: nil,
		}
		server.ListenAndServeTLS("cert.pem", "key.pem")
	}


snippet Handling_Requests_multihandler_server
	package main

	import (
		"fmt"
		"net/http"
	)

	type HelloHandler struct{}

	func (h *HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Hello!")
	}

	type WorldHandler struct{}

	func (h *WorldHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "World!")
	}

	func main() {
		hello := HelloHandler{}
		world := WorldHandler{}

		server := http.Server{
			Addr: "127.0.0.1:8080",
		}

		http.Handle("/hello", &hello)
		http.Handle("/world", &world)

		server.ListenAndServe()
	}


snippet Handling_Requests_simplest_server
	package main

	import (
		"net/http"
	)

	func main() {
		http.ListenAndServe("", nil)
	}


snippet Processing_Requests_body_server
	package main

	import (
		"fmt"
		"net/http"
	)

	func body(w http.ResponseWriter, r *http.Request) {
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		fmt.Fprintln(w, string(body))
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/body", body)
		server.ListenAndServe()
	}


snippet Processing_Requests_cookie_server
	package main

	import (
		"fmt"
		"net/http"
	)

	func setCookie(w http.ResponseWriter, r *http.Request) {
		c1 := http.Cookie{
			Name:     "first_cookie",
			Value:    "Go Web Programming",
			HttpOnly: true,
		}
		c2 := http.Cookie{
			Name:     "second_cookie",
			Value:    "Manning Publications Co",
			HttpOnly: true,
		}
		http.SetCookie(w, &c1)
		http.SetCookie(w, &c2)
	}

	func getCookie(w http.ResponseWriter, r *http.Request) {
		c1, err := r.Cookie("first_cookie")
		if err != nil {
			fmt.Fprintln(w, "Cannot get the first cookie")
		}
		cs := r.Cookies()
		fmt.Fprintln(w, c1)
		fmt.Fprintln(w, cs)
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/set_cookie", setCookie)
		http.HandleFunc("/get_cookie", getCookie)
		server.ListenAndServe()
	}


snippet Processing_Requests_cookie_flash_server
	package main

	import (
		"encoding/base64"
		"fmt"
		"net/http"
		"time"
	)

	func setMessage(w http.ResponseWriter, r *http.Request) {
		msg := []byte("Hello World!")
		c := http.Cookie{
			Name:  "flash",
			Value: base64.URLEncoding.EncodeToString(msg),
		}
		http.SetCookie(w, &c)
	}

	func showMessage(w http.ResponseWriter, r *http.Request) {
		c, err := r.Cookie("flash")
		if err != nil {
			if err == http.ErrNoCookie {
				fmt.Fprintln(w, "No message found")
			}
		} else {
			rc := http.Cookie{
				Name:    "flash",
				MaxAge:  -1,
				Expires: time.Unix(1, 0),
			}
			http.SetCookie(w, &rc)
			val, _ := base64.URLEncoding.DecodeString(c.Value)
			fmt.Fprintln(w, string(val))
		}
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/set_message", setMessage)
		http.HandleFunc("/show_message", showMessage)
		server.ListenAndServe()
	}


snippet Processing_Requests_fileupload_server
	package main

	import (
		"fmt"
		"io/ioutil"
		"net/http"
	)

	func process(w http.ResponseWriter, r *http.Request) {
		r.ParseMultipartForm(1024)
		fileHeader := r.MultipartForm.File["uploaded"][0]
		file, err := fileHeader.Open()
		if err == nil {
			data, err := ioutil.ReadAll(file)
			if err == nil {
				fmt.Fprintln(w, string(data))
			}
		}
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/process", process)
		server.ListenAndServe()
	}


snippet Processing_Requests_form_server
	package main

	import (
		"fmt"
		"net/http"
	)

	func process(w http.ResponseWriter, r *http.Request) {
		r.ParseForm()
		fmt.Fprintln(w, r.Form)
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/process", process)
		server.ListenAndServe()
	}


snippet Processing_Requests_formfile_server
	package main

	import (
		"fmt"
		"io/ioutil"
		"net/http"
	)

	func process(w http.ResponseWriter, r *http.Request) {
		file, _, err := r.FormFile("uploaded")
		if err == nil {
			data, err := ioutil.ReadAll(file)
			if err == nil {
				fmt.Fprintln(w, string(data))
			}
		}
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/process", process)
		server.ListenAndServe()
	}


snippet Processing_Requests_header_server
	package main

	import (
		"fmt"
		"net/http"
	)

	func headers(w http.ResponseWriter, r *http.Request) {
		h := r.Header
		fmt.Fprintln(w, h)
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/headers", headers)
		server.ListenAndServe()
	}


snippet Processing_Requests_write_server
	package main

	import (
		"fmt"
		"encoding/json"
		"net/http"
	)

	type Post struct {
		User    string
		Threads []string
	}

	func writeExample(w http.ResponseWriter, r *http.Request) {
		str := `<html>
	<head><title>Go Web Programming</title></head>
	<body><h1>Hello World</h1></body>
	</html>`
		w.Write([]byte(str))
	}

	func writeHeaderExample(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(501)
		fmt.Fprintln(w, "No such service, try next door")
	}

	func headerExample(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Location", "http://google.com")
		w.WriteHeader(302)
	}

	func jsonExample(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		post := &Post{
			User:    "Sau Sheong",
			Threads: []string{"first", "second", "third"},
		}
		json, _ := json.Marshal(post)
		w.Write(json)
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/write", writeExample)
		http.HandleFunc("/writeheader", writeHeaderExample)
		http.HandleFunc("/redirect", headerExample)
		http.HandleFunc("/json", jsonExample)
		server.ListenAndServe()
	}


snippet Displaying_Content_context_aware_server
	package main

	import (
		"html/template"
		"net/http"
	)

	func process(w http.ResponseWriter, r *http.Request) {
		t, _ := template.ParseFiles("tmpl.html")
		content := `I asked: <i>"What's up?"</i>`
		t.Execute(w, content)
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/process", process)
		server.ListenAndServe()
	}


snippet Displaying_Content_custom_function_server
	package main

	import (
		"html/template"
		"net/http"
		"time"
	)

	func formatDate(t time.Time) string {
		layout := "2006-01-02"
		return t.Format(layout)
	}

	func process(w http.ResponseWriter, r *http.Request) {
		funcMap := template.FuncMap{"fdate": formatDate}
		t := template.New("tmpl.html").Funcs(funcMap)
		t, _ = t.ParseFiles("tmpl.html")
		t.Execute(w, time.Now())
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/process", process)
		server.ListenAndServe()
	}


snippet Displaying_Content_include_server
	package main

	import (
		"html/template"
		"net/http"
	)

	func process(w http.ResponseWriter, r *http.Request) {
		t, _ := template.ParseFiles("t1.html", "t2.html")
		t.Execute(w, "Hello World!")
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/process", process)
		server.ListenAndServe()
	}


snippet Displaying_Content_iterator_server
	package main

	import (
		"html/template"
		"net/http"
	)

	func process(w http.ResponseWriter, r *http.Request) {
		t, _ := template.ParseFiles("tmpl.html")
		daysOfWeek := []string{"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"}
		t.Execute(w, daysOfWeek)
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/process", process)
		server.ListenAndServe()
	}


snippet Displaying_Content_nested1_server
	package main

	import (
		"html/template"
		"net/http"
	)

	func process(w http.ResponseWriter, r *http.Request) {
		t, _ := template.ParseFiles("layout.html")
		t.ExecuteTemplate(w, "layout", "")
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/process", process)
		server.ListenAndServe()
	}


snippet Displaying_Content_nested2_server
	package main

	import (
		"html/template"
		"math/rand"
		"net/http"
		"time"
	)

	func process(w http.ResponseWriter, r *http.Request) {
		rand.Seed(time.Now().Unix())
		var t *template.Template
		if rand.Intn(10) > 5 {
			t, _ = template.ParseFiles("layout.html", "red_hello.html")
		} else {
			t, _ = template.ParseFiles("layout.html", "blue_hello.html")
		}
		t.ExecuteTemplate(w, "layout", "")
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/process", process)
		server.ListenAndServe()
	}


snippet Displaying_Content_nested3_server
	package main

	import (
		"html/template"
		"math/rand"
		"net/http"
		"time"
	)

	func process(w http.ResponseWriter, r *http.Request) {
		rand.Seed(time.Now().Unix())
		var t *template.Template
		if rand.Intn(10) > 5 {
			t, _ = template.ParseFiles("layout.html", "red_hello.html")
		} else {
			t, _ = template.ParseFiles("layout.html")
		}
		t.ExecuteTemplate(w, "layout", "")
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/process", process)
		server.ListenAndServe()
	}


snippet Displaying_Content_random_number_server
	package main

	import (
		"html/template"
		"math/rand"
		"net/http"
		"time"
	)

	func process(w http.ResponseWriter, r *http.Request) {
		t, _ := template.ParseFiles("tmpl.html")
		rand.Seed(time.Now().Unix())
		t.Execute(w, rand.Intn(10) > 5)
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/process", process)
		server.ListenAndServe()
	}


snippet Displaying_Content_set_dot_server
	package main

	import (
		"html/template"
		"net/http"
	)

	func process(w http.ResponseWriter, r *http.Request) {
		t, _ := template.ParseFiles("tmpl.html")
		t.Execute(w, "hello")
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/process", process)
		server.ListenAndServe()
	}


snippet Displaying_Content_trigger_template_server
	package main

	import (
		"html/template"
		"net/http"
	)

	func process(w http.ResponseWriter, r *http.Request) {
		t, _ := template.ParseFiles("tmpl.html")
		t.Execute(w, "Hello World!")
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/process", process)
		server.ListenAndServe()
	}


snippet Displaying_Content_xss_server
	package main

	import (
	  "net/http"
	  "html/template"
	)

	func process(w http.ResponseWriter, r *http.Request) {  
	  w.Header().Set("X-XSS-Protection", "0")
	  t, _ := template.ParseFiles("tmpl.html")  
	  t.Execute(w, r.FormValue("comment"))
	  t.Execute(w, template.HTML(r.FormValue("comment")))
	}

	func form(w http.ResponseWriter, r *http.Request) {  
	  t, _ := template.ParseFiles("form.html")  
	  t.Execute(w, nil)  
	}

	func main() {
	  server := http.Server{
		Addr: "127.0.0.1:8080",
	  }
	  http.HandleFunc("/process", process)
	  http.HandleFunc("/", form)
	  server.ListenAndServe()
	}


snippet Storing_Data_csv_store_store
	package main

	import (
		"encoding/csv"
		"fmt"
		"os"
		"strconv"
	)

	type Post struct {
		Id      int
		Content string
		Author  string
	}

	func main() {
		// creating a CSV file
		csvFile, err := os.Create("posts.csv")
		if err != nil {
			panic(err)
		}
		defer csvFile.Close()

		allPosts := []Post{
			Post{Id: 1, Content: "Hello World!", Author: "Sau Sheong"},
			Post{Id: 2, Content: "Bonjour Monde!", Author: "Pierre"},
			Post{Id: 3, Content: "Hola Mundo!", Author: "Pedro"},
			Post{Id: 4, Content: "Greetings Earthlings!", Author: "Sau Sheong"},
		}

		writer := csv.NewWriter(csvFile)
		for _, post := range allPosts {
			line := []string{strconv.Itoa(post.Id), post.Content, post.Author}
			err := writer.Write(line)
			if err != nil {
				panic(err)
			}
		}
		writer.Flush()

		// reading a CSV file
		file, err := os.Open("posts.csv")
		if err != nil {
			panic(err)
		}
		defer file.Close()

		reader := csv.NewReader(file)
		reader.FieldsPerRecord = -1
		record, err := reader.ReadAll()
		if err != nil {
			panic(err)
		}

		var posts []Post
		for _, item := range record {
			id, _ := strconv.ParseInt(item[0], 0, 0)
			post := Post{Id: int(id), Content: item[1], Author: item[2]}
			posts = append(posts, post)
		}
		fmt.Println(posts[0].Id)
		fmt.Println(posts[0].Content)
		fmt.Println(posts[0].Author)
	}


snippet Storing_Data_gob_store_store
	package main

	import (
		"bytes"
		"encoding/gob"
		"fmt"
		"io/ioutil"
	)

	type Post struct {
		Id      int
		Content string
		Author  string
	}

	// store data
	func store(data interface{}, filename string) {
		buffer := new(bytes.Buffer)
		encoder := gob.NewEncoder(buffer)
		err := encoder.Encode(data)
		if err != nil {
			panic(err)
		}
		err = ioutil.WriteFile(filename, buffer.Bytes(), 0600)
		if err != nil {
			panic(err)
		}
	}

	// load the data
	func load(data interface{}, filename string) {
		raw, err := ioutil.ReadFile(filename)
		if err != nil {
			panic(err)
		}
		buffer := bytes.NewBuffer(raw)
		dec := gob.NewDecoder(buffer)
		err = dec.Decode(data)
		if err != nil {
			panic(err)
		}
	}

	func main() {
		post := Post{Id: 1, Content: "Hello World!", Author: "Sau Sheong"}
		store(post, "post1")
		var postRead Post
		load(&postRead, "post1")
		fmt.Println(postRead)
	}


snippet Storing_Data_gorm_store_store
	package main

	import (
	  "fmt"
		"github.com/jinzhu/gorm"
		_ "github.com/lib/pq"
		"time"
	)

	type Post struct {
		Id        int
		Content   string
		Author    string `sql:"not null"`
		Comments  []Comment
		CreatedAt time.Time
	}

	type Comment struct {
		Id        int
		Content   string
		Author    string `sql:"not null"`
		PostId    int    
		CreatedAt time.Time
	}

	var Db gorm.DB

	// connect to the Db
	func init() {
		var err error
		Db, err = gorm.Open("postgres", "user=gwp dbname=gwp password=gwp sslmode=disable")
		if err != nil {
			panic(err)
		}
		Db.AutoMigrate(&Post{}, &Comment{})
	}

	func main() {
		post := Post{Content: "Hello World!", Author: "Sau Sheong"}
	  fmt.Println(post) // {0 Hello World! Sau Sheong [] 0001-01-01 00:00:00 +0000 UTC}

		// Create a post
		Db.Create(&post)
	  fmt.Println(post) // {1 Hello World! Sau Sheong [] 2015-04-13 11:38:50.91815604 +0800 SGT}

	  // Add a comment
		comment := Comment{Content: "Good post!", Author: "Joe"}
		Db.Model(&post).Association("Comments").Append(comment)

	  // Get comments from a post
		var readPost Post  
		Db.Where("author = $1", "Sau Sheong").First(&readPost)
	  var comments []Comment
	  Db.Model(&readPost).Related(&comments)
	  fmt.Println(comments[0]) // {1 Good post! Joe 1 2015-04-13 11:38:50.920377 +0800 SGT}
	}


snippet Storing_Data_map_store_store
	package main

	import (
		"fmt"
	)

	type Post struct {
		Id      int
		Content string
		Author  string
	}

	var PostById map[int]*Post
	var PostsByAuthor map[string][]*Post

	func store(post Post) {
		PostById[post.Id] = &post
		PostsByAuthor[post.Author] = append(PostsByAuthor[post.Author], &post)
	}

	func main() {

		PostById = make(map[int]*Post)
		PostsByAuthor = make(map[string][]*Post)

		post1 := Post{Id: 1, Content: "Hello World!", Author: "Sau Sheong"}
		post2 := Post{Id: 2, Content: "Bonjour Monde!", Author: "Pierre"}
		post3 := Post{Id: 3, Content: "Hola Mundo!", Author: "Pedro"}
		post4 := Post{Id: 4, Content: "Greetings Earthlings!", Author: "Sau Sheong"}

		store(post1)
		store(post2)
		store(post3)
		store(post4)

		fmt.Println(PostById[1])
		fmt.Println(PostById[2])

		for _, post := range PostsByAuthor["Sau Sheong"] {
			fmt.Println(post)
		}
		for _, post := range PostsByAuthor["Pedro"] {
			fmt.Println(post)
		}
	}


snippet Storing_Data_read_write_files_store
	package main

	import (
		"fmt"
		"io/ioutil"
		"os"
	)

	func main() {
		data := []byte("Hello World!\n")

		// write to file and read from file using WriteFile and ReadFile
		err := ioutil.WriteFile("data1", data, 0644)
		if err != nil {
			panic(err)
		}
		read1, _ := ioutil.ReadFile("data1")
		fmt.Print(string(read1))

		// write to file and read from file using the File struct
		file1, _ := os.Create("data2")
		defer file1.Close()

		bytes, _ := file1.Write(data)
		fmt.Printf("Wrote %d bytes to file\n", bytes)

		file2, _ := os.Open("data2")
		defer file2.Close()

		read2 := make([]byte, len(data))
		bytes, _ = file2.Read(read2)
		fmt.Printf("Read %d bytes from file\n", bytes)
		fmt.Println(string(read2))
	}


snippet Storing_Data_sql_store1_store
	package main

	import (
		"database/sql"
		"fmt"
		_ "github.com/lib/pq"
	)

	type Post struct {
		Id      int
		Content string
		Author  string
	}

	var Db *sql.DB

	// connect to the Db
	func init() {
		var err error
		Db, err = sql.Open("postgres", "user=gwp dbname=gwp password=gwp sslmode=disable")
		if err != nil {
			panic(err)
		}
	}

	// get all posts
	func Posts(limit int) (posts []Post, err error) {
		rows, err := Db.Query("select id, content, author from posts limit $1", limit)
		if err != nil {
			return
		}
		for rows.Next() {
			post := Post{}
			err = rows.Scan(&post.Id, &post.Content, &post.Author)
			if err != nil {
				return
			}
			posts = append(posts, post)
		}
		rows.Close()
		return
	}

	// Get a single post
	func GetPost(id int) (post Post, err error) {
		post = Post{}
		err = Db.QueryRow("select id, content, author from posts where id = $1", id).Scan(&post.Id, &post.Content, &post.Author)
		return
	}

	// Create a new post
	func (post *Post) Create() (err error) {
		statement := "insert into posts (content, author) values ($1, $2) returning id"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		err = stmt.QueryRow(post.Content, post.Author).Scan(&post.Id)
		return
	}

	// Update a post
	func (post *Post) Update() (err error) {
		_, err = Db.Exec("update posts set content = $2, author = $3 where id = $1", post.Id, post.Content, post.Author)
		return
	}

	// Delete a post
	func (post *Post) Delete() (err error) {
		_, err = Db.Exec("delete from posts where id = $1", post.Id)
		return
	}

	// Delete all posts
	func DeleteAll() (err error) {
		_, err = Db.Exec("delete from posts")
		return
	}

	func main() {
		post := Post{Content: "Hello World!", Author: "Sau Sheong"}

		// Create a post
		fmt.Println(post) // {0 Hello World! Sau Sheong}
		post.Create()
		fmt.Println(post) // {1 Hello World! Sau Sheong}

		// Get one post
		readPost, _ := GetPost(post.Id)
		fmt.Println(readPost) // {1 Hello World! Sau Sheong}

		// Update the post
		readPost.Content = "Bonjour Monde!"
		readPost.Author = "Pierre"
		readPost.Update()

		// Get all posts
		posts, _ := Posts(10)
		fmt.Println(posts) // [{1 Bonjour Monde! Pierre}]

		// Delete the post
		readPost.Delete()

		// Get all posts
		posts, _ = Posts(10)
		fmt.Println(posts) // []

		// Delete all posts
	  // DeleteAll()
	}


snippet Storing_Data_sql_store2_store
	package main

	import (
		"database/sql"
		"errors"
		"fmt"
		_ "github.com/lib/pq"
	)

	type Post struct {
		Id       int
		Content  string
		Author   string
		Comments []Comment
	}

	type Comment struct {
		Id      int
		Content string
		Author  string
		Post    *Post
	}

	var Db *sql.DB

	// connect to the Db
	func init() {
		var err error
		Db, err = sql.Open("postgres", "user=gwp dbname=gwp password=gwp sslmode=disable")
		if err != nil {
			panic(err)
		}
	}

	func (comment *Comment) Create() (err error) {
		if comment.Post == nil {
			err = errors.New("Post not found")
			return
		}
		err = Db.QueryRow("insert into comments (content, author, post_id) values ($1, $2, $3) returning id", comment.Content, comment.Author, comment.Post.Id).Scan(&comment.Id)
		return
	}

	// Get a single post
	func GetPost(id int) (post Post, err error) {
		post = Post{}
		post.Comments = []Comment{}
		err = Db.QueryRow("select id, content, author from posts where id = $1", id).Scan(&post.Id, &post.Content, &post.Author)

		rows, err := Db.Query("select id, content, author from comments where post_id = $1", id)
		if err != nil {
			return
		}
		for rows.Next() {
			comment := Comment{Post: &post}
			err = rows.Scan(&comment.Id, &comment.Content, &comment.Author)
			if err != nil {
				return
			}
			post.Comments = append(post.Comments, comment)
		}
		rows.Close()
		return
	}

	// Create a new post
	func (post *Post) Create() (err error) {
		err = Db.QueryRow("insert into posts (content, author) values ($1, $2) returning id", post.Content, post.Author).Scan(&post.Id)
		return
	}

	func main() {
		post := Post{Content: "Hello World!", Author: "Sau Sheong"}
		post.Create()

		// Add a comment
		comment := Comment{Content: "Good post!", Author: "Joe", Post: &post}
		comment.Create()
		readPost, _ := GetPost(post.Id)

		fmt.Println(readPost)                  // {1 Hello World! Sau Sheong [{1 Good post! Joe 0xc20802a1c0}]}
		fmt.Println(readPost.Comments)         // [{1 Good post! Joe 0xc20802a1c0}]
		fmt.Println(readPost.Comments[0].Post) // &{1 Hello World! Sau Sheong [{1 Good post! Joe 0xc20802a1c0}]}
	}


snippet Storing_Data_sqlx_store_store
	package main

	import (
		"fmt"
		"github.com/jmoiron/sqlx"
		_ "github.com/lib/pq"
	)

	type Post struct {
		Id         int
		Content    string
		AuthorName string `db: author`
	}

	var Db *sqlx.DB

	// connect to the Db
	func init() {
		var err error
		Db, err = sqlx.Open("postgres", "user=gwp dbname=gwp password=gwp sslmode=disable")
		if err != nil {
			panic(err)
		}
	}

	// Get a single post
	func GetPost(id int) (post Post, err error) {
		post = Post{}
		err = Db.QueryRowx("select id, content, author from posts where id = $1", id).StructScan(&post)
		if err != nil {
			return
		}
		return
	}

	// Create a new post
	func (post *Post) Create() (err error) {
		err = Db.QueryRow("insert into posts (content, author) values ($1, $2) returning id", post.Content, post.AuthorName).Scan(&post.Id)
		return
	}

	func main() {
		post := Post{Content: "Hello World!", AuthorName: "Sau Sheong"}
		post.Create()
		fmt.Println(post) // {1 Hello World! Sau Sheong}}
	}


snippet Creating_Web_Services_json_creating_encoder_json
	package main

	import (
		"encoding/json"
		"fmt"
		"io"
	  "os"
	)

	type Post struct {
		Id       int       `json:"id"`
		Content  string    `json:"content"`
		Author   Author    `json:"author"`
		Comments []Comment `json:"comments"`
	}

	type Author struct {
		Id   int    `json:"id"`
		Name string `json:"name"`
	}

	type Comment struct {
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	func main() {

		post := Post{
			Id:      1,
			Content: "Hello World!",
			Author: Author{
				Id:   2,
				Name: "Sau Sheong",
			},
			Comments: []Comment{
				Comment{
					Id:      1,
					Content: "Have a great day!",
					Author:  "Adam",
				},
				Comment{
					Id:      2,
					Content: "How are you today?",
					Author:  "Betty",
				},
			},
		}

		jsonFile, err := os.Create("post.json")
		if err != nil {
			fmt.Println("Error creating JSON file:", err)
			return
		}
		jsonWriter := io.Writer(jsonFile)
		encoder := json.NewEncoder(jsonWriter)  
		err = encoder.Encode(&post)
		if err != nil {
			fmt.Println("Error encoding JSON to file:", err)
			return
		}
	}


snippet Creating_Web_Services_json_creating_marshal_json
	package main

	import (
		"encoding/json"
		"fmt"
		"io/ioutil"
	)

	type Post struct {
		Id       int       `json:"id"`
		Content  string    `json:"content"`
		Author   Author    `json:"author"`
		Comments []Comment `json:"comments"`
	}

	type Author struct {
		Id   int    `json:"id"`
		Name string `json:"name"`
	}

	type Comment struct {
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	func main() {

		post := Post{
			Id:      1,
			Content: "Hello World!",
			Author: Author{
				Id:   2,
				Name: "Sau Sheong",
			},
			Comments: []Comment{
				Comment{
					Id:      1,
					Content: "Have a great day!",
					Author:  "Adam",
				},
				Comment{
					Id:      2,
					Content: "How are you today?",
					Author:  "Betty",
				},
			},
		}

		output, err := json.MarshalIndent(&post, "", "\t\t")
		if err != nil {
			fmt.Println("Error marshalling to JSON:", err)
			return
		}
		err = ioutil.WriteFile("post.json", output, 0644)
		if err != nil {
			fmt.Println("Error writing JSON to file:", err)
			return
		}
	}


snippet Creating_Web_Services_json_parsing_decoder_json
	package main

	import (
		"encoding/json"
		"fmt"
		"io"
		"os"
	)

	type Post struct {
		Id       int       `json:"id"`
		Content  string    `json:"content"`
		Author   Author    `json:"author"`
		Comments []Comment `json:"comments"`
	}

	type Author struct {
		Id   int    `json:"id"`
		Name string `json:"name"`
	}

	type Comment struct {
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	func main() {
		jsonFile, err := os.Open("post.json")
		if err != nil {
			fmt.Println("Error opening JSON file:", err)
			return
		}
		defer jsonFile.Close()

		decoder := json.NewDecoder(jsonFile)
		for {
			var post Post
			err := decoder.Decode(&post)
			if err == io.EOF {
				break
			}
			if err != nil {
				fmt.Println("Error decoding JSON:", err)
				return
			}
			fmt.Println(post)
		}
	}


snippet Creating_Web_Services_json_parsing_unmarshal_json
	package main

	import (
		"encoding/json"
		"fmt"
		"io/ioutil"
		"os"
	)

	type Post struct {
		Id       int       `json:"id"`
		Content  string    `json:"content"`
		Author   Author    `json:"author"`
		Comments []Comment `json:"comments"`
	}

	type Author struct {
		Id   int    `json:"id"`
		Name string `json:"name"`
	}

	type Comment struct {
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	func main() {
		jsonFile, err := os.Open("post.json")
		if err != nil {
			fmt.Println("Error opening JSON file:", err)
			return
		}
		defer jsonFile.Close()
		jsonData, err := ioutil.ReadAll(jsonFile)
		if err != nil {
			fmt.Println("Error reading JSON data:", err)
			return
		}

		fmt.Println(string(jsonData))
		var post Post
		json.Unmarshal(jsonData, &post)
		fmt.Println(post.Id)
		fmt.Println(post.Content)
		fmt.Println(post.Author.Id)
		fmt.Println(post.Author.Name)
		fmt.Println(post.Comments[0].Id)
		fmt.Println(post.Comments[0].Content)
		fmt.Println(post.Comments[0].Author)

	}


snippet Creating_Web_Services_web_service_data
	package main

	import (
		"database/sql"
		_ "github.com/lib/pq"
	)

	var Db *sql.DB

	// connect to the Db
	func init() {
		var err error
		Db, err = sql.Open("postgres", "user=gwp dbname=gwp password=gwp sslmode=disable")
		if err != nil {
			panic(err)
		}
	}

	// Get a single post
	func retrieve(id int) (post Post, err error) {
		post = Post{}
		err = Db.QueryRow("select id, content, author from posts where id = $1", id).Scan(&post.Id, &post.Content, &post.Author)
		return
	}

	// Create a new post
	func (post *Post) create() (err error) {
		statement := "insert into posts (content, author) values ($1, $2) returning id"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		err = stmt.QueryRow(post.Content, post.Author).Scan(&post.Id)
		return
	}

	// Update a post
	func (post *Post) update() (err error) {
		_, err = Db.Exec("update posts set content = $2, author = $3 where id = $1", post.Id, post.Content, post.Author)
		return
	}

	// Delete a post
	func (post *Post) delete() (err error) {
		_, err = Db.Exec("delete from posts where id = $1", post.Id)
		return
	}


snippet Creating_Web_Services_web_service_server
	package main

	import (
		"encoding/json"
		"net/http"
		"path"
		"strconv"
	)

	type Post struct {
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	func main() {
		server := http.Server{
			Addr: ":8080",
		}
		http.HandleFunc("/post/", handleRequest)
		server.ListenAndServe()
	}

	// main handler function
	func handleRequest(w http.ResponseWriter, r *http.Request) {
		var err error
		switch r.Method {
		case "GET":
			err = handleGet(w, r)
		case "POST":
			err = handlePost(w, r)
		case "PUT":
			err = handlePut(w, r)
		case "DELETE":
			err = handleDelete(w, r)
		}
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	// Retrieve a post
	// GET /post/1
	func handleGet(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrieve(id)
		if err != nil {
			return
		}
		output, err := json.MarshalIndent(&post, "", "\t\t")
		if err != nil {
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Write(output)
		return
	}

	// Create a post
	// POST /post/
	func handlePost(w http.ResponseWriter, r *http.Request) (err error) {
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		var post Post
		json.Unmarshal(body, &post)
		err = post.create()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Update a post
	// PUT /post/1
	func handlePut(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrieve(id)
		if err != nil {
			return
		}
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, &post)
		err = post.update()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Delete a post
	// DELETE /post/1
	func handleDelete(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrieve(id)
		if err != nil {
			return
		}
		err = post.delete()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}


snippet Creating_Web_Services_xml_creating_encoder_xml
	package main

	import (
		"encoding/xml"
		"fmt"
		"os"
	)

	type Post struct {
		XMLName xml.Name `xml:"post"`
		Id      string   `xml:"id,attr"`
		Content string   `xml:"content"`
		Author  Author   `xml:"author"`
	}

	type Author struct {
		Id   string `xml:"id,attr"`
		Name string `xml:",chardata"`
	}

	func main() {
		post := Post{
			Id:      "1",
			Content: "Hello World!",
			Author: Author{
				Id:   "2",
				Name: "Sau Sheong",
			},
		}

		xmlFile, err := os.Create("post.xml")
		if err != nil {
			fmt.Println("Error creating XML file:", err)
			return
		}
		encoder := xml.NewEncoder(xmlFile)
		encoder.Indent("", "\t")
		err = encoder.Encode(&post)
		if err != nil {
			fmt.Println("Error encoding XML to file:", err)
			return
		}

	}


snippet Creating_Web_Services_xml_creating_marshal_xml
	package main

	import (
		"encoding/xml"
		"fmt"
		"io/ioutil"
	)

	type Post struct {
		XMLName xml.Name `xml:"post"`
		Id      string   `xml:"id,attr"`
		Content string   `xml:"content"`
		Author  Author   `xml:"author"`
	}

	type Author struct {
		Id   string `xml:"id,attr"`
		Name string `xml:",chardata"`
	}

	func main() {
		post := Post{
			Id:      "1",
			Content: "Hello World!",
			Author: Author{
				Id:   "2",
				Name: "Sau Sheong",
			},
		}
	  // output, err := xml.Marshal(&post)
	  output, err := xml.MarshalIndent(&post, "", "\t\t")
		if err != nil {
			fmt.Println("Error marshalling to XML:", err)
			return
		}
		err = ioutil.WriteFile("post.xml", []byte(xml.Header + string(output)), 0644)
		if err != nil {
			fmt.Println("Error writing XML to file:", err)
			return
		}

	}


snippet Creating_Web_Services_xml_parsing_decoder_xml
	package main

	import (
		"encoding/xml"
		"fmt"
		"io"
		"os"
	)

	type Post struct {
		XMLName  xml.Name  `xml:"post"`
		Id       string    `xml:"id,attr"`
		Content  string    `xml:"content"`
		Author   Author    `xml:"author"`
		Xml      string    `xml:",innerxml"`
		Comments []Comment `xml:"comments>comment"`
	}

	type Author struct {
		Id   string `xml:"id,attr"`
		Name string `xml:",chardata"`
	}

	type Comment struct {
		Id      string `xml:"id,attr"`
		Content string `xml:"content"`
		Author  Author `xml:"author"`
	}

	func main() {
		xmlFile, err := os.Open("post.xml")
		if err != nil {
			fmt.Println("Error opening XML file:", err)
			return
		}
		defer xmlFile.Close()

		decoder := xml.NewDecoder(xmlFile)
		for {
			t, err := decoder.Token()
			if err == io.EOF {
				break
			}
			if err != nil {
				fmt.Println("Error decoding XML into tokens:", err)
				return
			}

			switch se := t.(type) {
			case xml.StartElement:
				if se.Name.Local == "comment" {
					var comment Comment
					decoder.DecodeElement(&comment, &se)
					fmt.Println(comment)
				}
			}
		}
	}


snippet Creating_Web_Services_xml_parsing_unmarshal_1_xml
	package main

	import (
		"encoding/xml"
		"fmt"
		"io/ioutil"
		"os"
	)

	type Post struct {
		XMLName xml.Name `xml:"post"`
		Id      string   `xml:"id,attr"`
		Content string   `xml:"content"`
		Author  Author   `xml:"author"`
		Xml     string   `xml:",innerxml"`
	}

	type Author struct {
		Id   string `xml:"id,attr"`
		Name string `xml:",chardata"`
	}

	func main() {
		xmlFile, err := os.Open("post.xml")
		if err != nil {
			fmt.Println("Error opening XML file:", err)
			return
		}
		defer xmlFile.Close()
		xmlData, err := ioutil.ReadAll(xmlFile)
		if err != nil {
			fmt.Println("Error reading XML data:", err)
			return
		}

		var post Post
		xml.Unmarshal(xmlData, &post)
		fmt.Println(post)
	}


snippet Creating_Web_Services_xml_parsing_unmarshal_2_xml
	package main

	import (
		"encoding/xml"
		"fmt"
		"io/ioutil"
		"os"
	)

	type Post struct {
		XMLName  xml.Name  `xml:"post"`
		Id       string    `xml:"id,attr"`
		Content  string    `xml:"content"`
		Author   Author    `xml:"author"`
		Xml      string    `xml:",innerxml"`
		Comments []Comment `xml:"comments>comment"`
	}

	type Author struct {
		Id   string `xml:"id,attr"`
		Name string `xml:",chardata"`
	}

	type Comment struct {
		Id      string `xml:"id,attr"`
		Content string `xml:"content"`
		Author  Author `xml:"author"`
	}

	func main() {
		xmlFile, err := os.Open("post.xml")
		if err != nil {
			fmt.Println("Error opening XML file:", err)
			return
		}
		defer xmlFile.Close()
		xmlData, err := ioutil.ReadAll(xmlFile)
		if err != nil {
			fmt.Println("Error reading XML data:", err)
			return
		}

		var post Post
		xml.Unmarshal(xmlData, &post)
		fmt.Println(post.XMLName.Local)
		fmt.Println(post.Id)
		fmt.Println(post.Content)
		fmt.Println(post.Author)
		fmt.Println(post.Xml)
		fmt.Println(post.Author.Id)
		fmt.Println(post.Author.Name)
		fmt.Println(post.Comments)
		fmt.Println(post.Comments[0].Id)
		fmt.Println(post.Comments[0].Content)
		fmt.Println(post.Comments[0].Author)
		fmt.Println(post.Comments[1].Id)
		fmt.Println(post.Comments[1].Content)
		fmt.Println(post.Comments[1].Author)
	}


snippet Testing_Web_Applications_convert_ginkgo_convert_ginkgo_suite_test
	package main_test

	import (
		. "github.com/onsi/ginkgo"
		. "github.com/onsi/gomega"

		"testing"
	)

	func TestConvertGinkgo(t *testing.T) {
		RegisterFailHandler(Fail)
		RunSpecs(t, "ConvertGinkgo Suite")
	}


snippet Testing_Web_Applications_convert_ginkgo_data
	package main

	import (
		"database/sql"
		_ "github.com/lib/pq"
	)

	type Post struct {
		Db      sql.DB
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	// Get a single post
	func (post *Post) retrieve(id int) (err error) {
		err = post.Db.QueryRow("select id, content, author from posts where id = $1", id).Scan(&post.Id, &post.Content, &post.Author)
		return
	}

	// Create a new post
	func (post *Post) create() (err error) {
		statement := "insert into posts (content, author) values ($1, $2) returning id"
		stmt, err := post.Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		err = stmt.QueryRow(post.Content, post.Author).Scan(&post.Id)
		return
	}

	// Update a post
	func (post *Post) update() (err error) {
		_, err = post.Db.Exec("update posts set content = $2, author = $3 where id = $1", post.Id, post.Content, post.Author)
		return
	}

	// Delete a post
	func (post *Post) delete() (err error) {
		_, err = post.Db.Exec("delete from posts where id = $1", post.Id)
		return
	}


snippet Testing_Web_Applications_convert_ginkgo_doubles
	package main

	type FakePost struct {
		Id      int
		Content string
		Author  string
	}

	func (post *FakePost) retrieve(id int) (err error) {
		post.Id = id
		return
	}

	func (post *FakePost) create() (err error) {
		return
	}

	func (post *FakePost) update() (err error) {
		return
	}

	func (post *FakePost) delete() (err error) {
		return
	}


snippet Testing_Web_Applications_convert_ginkgo_server
	package main

	import (
		"database/sql"
		"encoding/json"
		_ "github.com/lib/pq"
		"net/http"
		"path"
		"strconv"
	)

	func main() {
		// connect to the Db
		var err error
		db, err := sql.Open("postgres", "user=gwp dbname=gwp password=gwp sslmode=disable")
		if err != nil {
			panic(err)
		}

		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/post/", handlePost(&Post{Db: *db}))
		server.ListenAndServe()
	}

	type Text interface {
		retrieve(id int) (err error)
		create() (err error)
		update() (err error)
		delete() (err error)
	}

	// main handler function
	func handlePost(t Text) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			var err error
			switch r.Method {
			case "GET":
				err = getPost(w, r, t)
			case "POST":
				err = postPost(w, r, t)
			case "PUT":
				err = putPost(w, r, t)
			case "DELETE":
				err = deletePost(w, r, t)
			}
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
		}
	}

	// Retrieve a post
	// GET /post/1
	func getPost(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.retrieve(id)
		if err != nil {
			return
		}
		output, err := json.MarshalIndent(post, "", "\t\t")
		if err != nil {
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Write(output)
		return
	}

	// Create a post
	// POST /post/
	func postPost(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, post)
		err = post.create()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Update a post
	// PUT /post/1
	func putPost(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.retrieve(id)
		if err != nil {
			return
		}
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, post)
		err = post.update()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Delete a post
	// DELETE /post/1
	func deletePost(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.retrieve(id)
		if err != nil {
			return
		}
		err = post.delete()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}


snippet Testing_Web_Applications_convert_ginkgo_server_test
	package main

	import (
		"encoding/json"
		. "github.com/onsi/ginkgo"
		"net/http"
		"net/http/httptest"
		"strings"
	)

	var _ = Describe("Testing with Ginkgo", func() {
		It("get post", func() {

			mux := http.NewServeMux()
			mux.HandleFunc("/post/", handlePost(&FakePost{}))

			writer := httptest.NewRecorder()
			request, _ := http.NewRequest("GET", "/post/1", nil)
			mux.ServeHTTP(writer, request)

			if writer.Code != 200 {
				GinkgoT().Errorf("Response code is %v", writer.Code)
			}
			var post Post
			json.Unmarshal(writer.Body.Bytes(), &post)
			if post.Id != 1 {
				GinkgoT().Errorf("Cannot retrieve JSON post")
			}
		})
		It("put post", func() {

			mux := http.NewServeMux()
			post := &FakePost{}
			mux.HandleFunc("/post/", handlePost(post))

			writer := httptest.NewRecorder()
			json := strings.NewReader(`{"content":"Updated post","author":"Sau Sheong"}`)
			request, _ := http.NewRequest("PUT", "/post/1", json)
			mux.ServeHTTP(writer, request)

			if writer.Code != 200 {
				GinkgoT().Error("Response code is %v", writer.Code)
			}

			if post.Content != "Updated post" {
				GinkgoT().Error("Content is not correct", post.Content)
			}
		})
	})


snippet Testing_Web_Applications_dependency_injection_data
	package main

	import (
		"database/sql"
		_ "github.com/lib/pq"
	)

	type Text interface {
	  fetch(id int) (err error)
	  create() (err error)
	  update() (err error)
	  delete() (err error)
	}

	type Post struct {
		Db      *sql.DB
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	// Get a single post
	func (post *Post) fetch(id int) (err error) {
		err = post.Db.QueryRow("select id, content, author from posts where id = $1", id).Scan(&post.Id, &post.Content, &post.Author)
		return
	}

	// Create a new post
	func (post *Post) create() (err error) {
		statement := "insert into posts (content, author) values ($1, $2) returning id"
		stmt, err := post.Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		err = stmt.QueryRow(post.Content, post.Author).Scan(&post.Id)
		return
	}

	// Update a post
	func (post *Post) update() (err error) {
		_, err = post.Db.Exec("update posts set content = $2, author = $3 where id = $1", post.Id, post.Content, post.Author)
		return
	}

	// Delete a post
	func (post *Post) delete() (err error) {
		_, err = post.Db.Exec("delete from posts where id = $1", post.Id)
		return
	}


snippet Testing_Web_Applications_dependency_injection_doubles
	package main

	type FakePost struct {
		Id      int
		Content string
		Author  string
	}

	func (post *FakePost) fetch(id int) (err error) {
		post.Id = id
		return
	}

	func (post *FakePost) create() (err error) {
		return
	}

	func (post *FakePost) update() (err error) {
		return
	}

	func (post *FakePost) delete() (err error) {
		return
	}


snippet Testing_Web_Applications_dependency_injection_server
	package main

	import (
		"database/sql"
		"encoding/json"
		_ "github.com/lib/pq"
		"net/http"
		"path"
		"strconv"
	)

	func main() {
		// connect to the Db
		var err error
		db, err := sql.Open("postgres", "user=gwp dbname=gwp password=gwp sslmode=disable")
		if err != nil {
			panic(err)
		}

		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/post/", handleRequest(&Post{Db: db}))
		server.ListenAndServe()
	}


	// main handler function
	func handleRequest(t Text) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			var err error
			switch r.Method {
			case "GET":
				err = handleGet(w, r, t)
			case "POST":
				err = handlePost(w, r, t)
			case "PUT":
				err = handlePut(w, r, t)
			case "DELETE":
				err = handleDelete(w, r, t)
			}
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
		}
	}

	// Retrieve a post
	// GET /post/1
	func handleGet(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.fetch(id)
		if err != nil {
			return
		}
		output, err := json.MarshalIndent(post, "", "\t\t")
		if err != nil {
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Write(output)
		return
	}

	// Create a post
	// POST /post/
	func handlePost(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, post)
		err = post.create()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Update a post
	// PUT /post/1
	func handlePut(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.fetch(id)
		if err != nil {
			return
		}
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, post)
		err = post.update()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Delete a post
	// DELETE /post/1
	func handleDelete(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.fetch(id)
		if err != nil {
			return
		}
		err = post.delete()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}


snippet Testing_Web_Applications_dependency_injection_server_test
	package main

	import (
		"encoding/json"
		"net/http"
		"net/http/httptest"
		"testing"
	  "strings"
	)

	func TestGetPost(t *testing.T) {
		mux := http.NewServeMux()
		mux.HandleFunc("/post/", handleRequest(&FakePost{}))

		writer := httptest.NewRecorder()
		request, _ := http.NewRequest("GET", "/post/1", nil)
		mux.ServeHTTP(writer, request)

		if writer.Code != 200 {
			t.Errorf("Response code is %v", writer.Code)
		}
		var post Post
		json.Unmarshal(writer.Body.Bytes(), &post)
		if post.Id != 1 {
			t.Errorf("Cannot retrieve JSON post")
		}
	}

	func TestPutPost(t *testing.T) {
		mux := http.NewServeMux()
	  post := &FakePost{}
		mux.HandleFunc("/post/", handleRequest(post))

		writer := httptest.NewRecorder()
		json := strings.NewReader(`{"content":"Updated post","author":"Sau Sheong"}`)
		request, _ := http.NewRequest("PUT", "/post/1", json)
		mux.ServeHTTP(writer, request)

		if writer.Code != 200 {
			t.Error("Response code is %v", writer.Code)
		}

	  if post.Content != "Updated post" {
		t.Error("Content is not correct", post.Content)
	  }
	}



snippet Testing_Web_Applications_gocheck_1_data
	package main

	import (
		"database/sql"
		_ "github.com/lib/pq"
	)

	type Post struct {
		Db      sql.DB
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	// Get a single post
	func (post *Post) retrieve(id int) (err error) {
		err = post.Db.QueryRow("select id, content, author from posts where id = $1", id).Scan(&post.Id, &post.Content, &post.Author)
		return
	}

	// Create a new post
	func (post *Post) create() (err error) {
		statement := "insert into posts (content, author) values ($1, $2) returning id"
		stmt, err := post.Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		err = stmt.QueryRow(post.Content, post.Author).Scan(&post.Id)
		return
	}

	// Update a post
	func (post *Post) update() (err error) {
		_, err = post.Db.Exec("update posts set content = $2, author = $3 where id = $1", post.Id, post.Content, post.Author)
		return
	}

	// Delete a post
	func (post *Post) delete() (err error) {
		_, err = post.Db.Exec("delete from posts where id = $1", post.Id)
		return
	}


snippet Testing_Web_Applications_gocheck_1_doubles
	package main

	type FakePost struct {
		Id      int
		Content string
		Author  string
	}

	func (post *FakePost) retrieve(id int) (err error) {
		post.Id = id
		return
	}

	func (post *FakePost) create() (err error) {
		return
	}

	func (post *FakePost) update() (err error) {
		return
	}

	func (post *FakePost) delete() (err error) {
		return
	}


snippet Testing_Web_Applications_gocheck_1_server
	package main

	import (
		"database/sql"
		"encoding/json"
		_ "github.com/lib/pq"
		"net/http"
		"path"
		"strconv"
	)

	func main() {
		// connect to the Db
		var err error
		db, err := sql.Open("postgres", "user=gwp dbname=gwp password=gwp sslmode=disable")
		if err != nil {
			panic(err)
		}

		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/post/", handleRequest(&Post{Db: *db}))
		server.ListenAndServe()
	}

	type Text interface {
		retrieve(id int) (err error)
		create() (err error)
		update() (err error)
		delete() (err error)
	}

	// main handler function
	func handleRequest(t Text) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			var err error
			switch r.Method {
			case "GET":
				err = handleGet(w, r, t)
			case "POST":
				err = handlePost(w, r, t)
			case "PUT":
				err = handlePut(w, r, t)
			case "DELETE":
				err = handleDelete(w, r, t)
			}
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
		}
	}

	// Retrieve a post
	// GET /post/1
	func handleGet(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.retrieve(id)
		if err != nil {
			return
		}
		output, err := json.MarshalIndent(post, "", "\t\t")
		if err != nil {
			return
		}
	  w.Header().Set("Content-Type", "application/json")
	  w.Write(output)
	  http.NotFound(w, r)
		return
	}

	// Create a post
	// POST /post/
	func handlePost(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, post)
		err = post.create()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Update a post
	// PUT /post/1
	func handlePut(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.retrieve(id)
		if err != nil {
			return
		}
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, post)
		err = post.update()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Delete a post
	// DELETE /post/1
	func handleDelete(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.retrieve(id)
		if err != nil {
			return
		}
		err = post.delete()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}


snippet Testing_Web_Applications_gocheck_1_server_test
	package main

	import (
		"encoding/json"
		. "gopkg.in/check.v1"
		"net/http"
		"net/http/httptest"
		"testing"
	)

	type PostTestSuite struct {}

	func init() {
		Suite(&PostTestSuite{})
	}

	func Test(t *testing.T) { TestingT(t) }

	func (s *PostTestSuite) TestHandleGet(c *C) {
		mux := http.NewServeMux()
		mux.HandleFunc("/post/", handleRequest(&FakePost{}))
		writer := httptest.NewRecorder()
		request, _ := http.NewRequest("GET", "/post/1", nil)
		mux.ServeHTTP(writer, request)

		c.Check(writer.Code, Equals, 200)
		var post Post
		json.Unmarshal(writer.Body.Bytes(), &post)
		c.Check(post.Id, Equals, 1)
	}


snippet Testing_Web_Applications_gocheck_2_data
	package main

	import (
		"database/sql"
		_ "github.com/lib/pq"
	)

	type Post struct {
		Db      sql.DB
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	// Get a single post
	func (post *Post) retrieve(id int) (err error) {
		err = post.Db.QueryRow("select id, content, author from posts where id = $1", id).Scan(&post.Id, &post.Content, &post.Author)
		return
	}

	// Create a new post
	func (post *Post) create() (err error) {
		statement := "insert into posts (content, author) values ($1, $2) returning id"
		stmt, err := post.Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		err = stmt.QueryRow(post.Content, post.Author).Scan(&post.Id)
		return
	}

	// Update a post
	func (post *Post) update() (err error) {
		_, err = post.Db.Exec("update posts set content = $2, author = $3 where id = $1", post.Id, post.Content, post.Author)
		return
	}

	// Delete a post
	func (post *Post) delete() (err error) {
		_, err = post.Db.Exec("delete from posts where id = $1", post.Id)
		return
	}


snippet Testing_Web_Applications_gocheck_2_doubles
	package main

	type FakePost struct {
		Id      int
		Content string
		Author  string
	}

	func (post *FakePost) retrieve(id int) (err error) {
		post.Id = id
		return
	}

	func (post *FakePost) create() (err error) {
		return
	}

	func (post *FakePost) update() (err error) {
		return
	}

	func (post *FakePost) delete() (err error) {
		return
	}


snippet Testing_Web_Applications_gocheck_2_server
	package main

	import (
		"database/sql"
		"encoding/json"
		_ "github.com/lib/pq"
		"net/http"
		"path"
		"strconv"
	)

	func main() {
		// connect to the Db
		var err error
		db, err := sql.Open("postgres", "user=gwp dbname=gwp password=gwp sslmode=disable")
		if err != nil {
			panic(err)
		}

		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/post/", handleRequest(&Post{Db: *db}))
		server.ListenAndServe()
	}

	type Text interface {
		retrieve(id int) (err error)
		create() (err error)
		update() (err error)
		delete() (err error)
	}

	// main handler function
	func handleRequest(t Text) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			var err error
			switch r.Method {
			case "GET":
				err = handleGet(w, r, t)
			case "POST":
				err = handlePost(w, r, t)
			case "PUT":
				err = handlePut(w, r, t)
			case "DELETE":
				err = handleDelete(w, r, t)
			}
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
		}
	}

	// Retrieve a post
	// GET /post/1
	func handleGet(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.retrieve(id)
		if err != nil {
			return
		}
		output, err := json.MarshalIndent(post, "", "\t\t")
		if err != nil {
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Write(output)
		return
	}

	// Create a post
	// POST /post/
	func handlePost(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, post)
		err = post.create()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Update a post
	// PUT /post/1
	func handlePut(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.retrieve(id)
		if err != nil {
			return
		}
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, post)
		err = post.update()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Delete a post
	// DELETE /post/1
	func handleDelete(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.retrieve(id)
		if err != nil {
			return
		}
		err = post.delete()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}


snippet Testing_Web_Applications_gocheck_2_server_test
	package main

	import (
		"encoding/json"	
		"net/http"
		"net/http/httptest"	
		"testing"
	  "strings"
	  . "gopkg.in/check.v1"
	)

	type PostTestSuite struct {
		mux  *http.ServeMux
		post *FakePost
	  writer *httptest.ResponseRecorder
	}

	func init() {
		Suite(&PostTestSuite{})
	}

	func Test(t *testing.T) { TestingT(t) }

	func (s *PostTestSuite) SetUpTest(c *C) {
		s.post = &FakePost{}
		s.mux = http.NewServeMux()
		s.mux.HandleFunc("/post/", handleRequest(s.post))
	  s.writer = httptest.NewRecorder()
	}

	func (s *PostTestSuite) TearDownTest(c *C) {
	  c.Log("Finished test - ", c.TestName())
	}

	func (s *PostTestSuite) SetUpSuite(c *C) {
	  c.Log("Starting Post Test Suite")
	}

	func (s *PostTestSuite) TearDownSuite(c *C) {
	  c.Log("Finishing Post Test Suite")
	}


	func (s *PostTestSuite) TestHandleGet(c *C) {	
		request, _ := http.NewRequest("GET", "/post/1", nil)
		s.mux.ServeHTTP(s.writer, request)

		c.Check(s.writer.Code, Equals, 200)
		var post Post
		json.Unmarshal(s.writer.Body.Bytes(), &post)
		c.Check(post.Id, Equals, 1)
	}

	func (s *PostTestSuite) TestHandlePut(c *C) {
		json := strings.NewReader(`{"content":"Updated post","author":"Sau Sheong"}`)
		request, _ := http.NewRequest("PUT", "/post/1", json)
		s.mux.ServeHTTP(s.writer, request)

		c.Check(s.writer.Code, Equals, 200)
		c.Check(s.post.Id, Equals, 1)
		c.Check(s.post.Content, Equals, "Updated post")
	}


snippet Testing_Web_Applications_httptest_1_data
	package main

	import (
		"database/sql"
		_ "github.com/lib/pq"
	)

	var Db *sql.DB

	// connect to the Db
	func init() {
		var err error
		Db, err = sql.Open("postgres", "user=gwp dbname=gwp password=gwp sslmode=disable")
		if err != nil {
			panic(err)
		}
	}

	// Get a single post
	func retrieve(id int) (post Post, err error) {
		post = Post{}
		err = Db.QueryRow("select id, content, author from posts where id = $1", id).Scan(&post.Id, &post.Content, &post.Author)
		return
	}

	// Create a new post
	func (post *Post) create() (err error) {
		statement := "insert into posts (content, author) values ($1, $2) returning id"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		err = stmt.QueryRow(post.Content, post.Author).Scan(&post.Id)
		return
	}

	// Update a post
	func (post *Post) update() (err error) {
		_, err = Db.Exec("update posts set content = $2, author = $3 where id = $1", post.Id, post.Content, post.Author)
		return
	}

	// Delete a post
	func (post *Post) delete() (err error) {
		_, err = Db.Exec("delete from posts where id = $1", post.Id)
		return
	}


snippet Testing_Web_Applications_httptest_1_server
	package main

	import (
		"encoding/json"
		"net/http"
		"path"
		"strconv"
	)

	type Post struct {
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/post/", handleRequest)
		server.ListenAndServe()
	}

	// main handler function
	func handleRequest(w http.ResponseWriter, r *http.Request) {
		var err error
		switch r.Method {
		case "GET":
			err = handleGet(w, r)
		case "POST":
			err = handlePost(w, r)
		case "PUT":
			err = handlePut(w, r)
		case "DELETE":
			err = handleDelete(w, r)
		}
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	// Retrieve a post
	// GET /post/1
	func handleGet(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrieve(id)
		if err != nil {
			return
		}
		output, err := json.MarshalIndent(&post, "", "\t\t")
		if err != nil {
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Write(output)
		return
	}

	// Create a post
	// POST /post/
	func handlePost(w http.ResponseWriter, r *http.Request) (err error) {
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		var post Post
		json.Unmarshal(body, &post)
		err = post.create()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Update a post
	// PUT /post/1
	func handlePut(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrieve(id)
		if err != nil {
			return
		}
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, &post)
		err = post.update()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Delete a post
	// DELETE /post/1
	func handleDelete(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrieve(id)
		if err != nil {
			return
		}
		err = post.delete()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}


snippet Testing_Web_Applications_httptest_1_server_test
	package main

	import (
		"encoding/json"
		"net/http"
		"net/http/httptest"
		"strings"
		"testing"
	)

	func TestHandleGet(t *testing.T) {
		mux := http.NewServeMux()
		mux.HandleFunc("/post/", handleRequest)

		writer := httptest.NewRecorder()
		request, _ := http.NewRequest("GET", "/post/1", nil)
		mux.ServeHTTP(writer, request)

		if writer.Code != 200 {
			t.Errorf("Response code is %v", writer.Code)
		}
		var post Post
		json.Unmarshal(writer.Body.Bytes(), &post)
		if post.Id != 1 {
			t.Errorf("Cannot retrieve JSON post")
		}
	}

	func TestHandlePut(t *testing.T) {
		mux := http.NewServeMux()
		mux.HandleFunc("/post/", handleRequest)

		writer := httptest.NewRecorder()
		json := strings.NewReader(`{"content":"Updated post","author":"Sau Sheong"}`)
		request, _ := http.NewRequest("PUT", "/post/1", json)
		mux.ServeHTTP(writer, request)

		if writer.Code != 200 {
			t.Errorf("Response code is %v", writer.Code)
		}
	}


snippet Testing_Web_Applications_httptest_2_data
	package main

	import (
		"database/sql"
		_ "github.com/lib/pq"
	)

	var Db *sql.DB

	// connect to the Db
	func init() {
		var err error
		Db, err = sql.Open("postgres", "user=gwp dbname=gwp password=gwp sslmode=disable")
		if err != nil {
			panic(err)
		}
	}

	// Get a single post
	func retrieve(id int) (post Post, err error) {
		post = Post{}
		err = Db.QueryRow("select id, content, author from posts where id = $1", id).Scan(&post.Id, &post.Content, &post.Author)
		return
	}

	// Create a new post
	func (post *Post) create() (err error) {
		statement := "insert into posts (content, author) values ($1, $2) returning id"
		stmt, err := Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		err = stmt.QueryRow(post.Content, post.Author).Scan(&post.Id)
		return
	}

	// Update a post
	func (post *Post) update() (err error) {
		_, err = Db.Exec("update posts set content = $2, author = $3 where id = $1", post.Id, post.Content, post.Author)
		return
	}

	// Delete a post
	func (post *Post) delete() (err error) {
		_, err = Db.Exec("delete from posts where id = $1", post.Id)
		return
	}


snippet Testing_Web_Applications_httptest_2_server
	package main

	import (
		"encoding/json"
		"net/http"
		"path"
		"strconv"
	)

	type Post struct {
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	func main() {
		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/post/", handleRequest)
		server.ListenAndServe()
	}

	// main handler function
	func handleRequest(w http.ResponseWriter, r *http.Request) {
		var err error
		switch r.Method {
		case "GET":
			err = handleGet(w, r)
		case "POST":
			err = handlePost(w, r)
		case "PUT":
			err = handlePut(w, r)
		case "DELETE":
			err = handleDelete(w, r)
		}
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
	}

	// Retrieve a post
	// GET /post/1
	func handleGet(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrieve(id)
		if err != nil {
			return
		}
		output, err := json.MarshalIndent(&post, "", "\t\t")
		if err != nil {
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Write(output)
		return
	}

	// Create a post
	// POST /post/
	func handlePost(w http.ResponseWriter, r *http.Request) (err error) {
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		var post Post
		json.Unmarshal(body, &post)
		err = post.create()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Update a post
	// PUT /post/1
	func handlePut(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrieve(id)
		if err != nil {
			return
		}
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, &post)
		err = post.update()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Delete a post
	// DELETE /post/1
	func handleDelete(w http.ResponseWriter, r *http.Request) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		post, err := retrieve(id)
		if err != nil {
			return
		}
		err = post.delete()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}


snippet Testing_Web_Applications_httptest_2_server_test
	package main

	import (
		"encoding/json"
		"net/http"
		"net/http/httptest"
		"os"
		"strings"
		"testing"
	)

	var mux *http.ServeMux
	var writer *httptest.ResponseRecorder

	func TestMain(m *testing.M) {
		setUp()
		code := m.Run()
		tearDown()
		os.Exit(code)
	}

	func setUp() {
		mux = http.NewServeMux()
		mux.HandleFunc("/post/", handleRequest)
		writer = httptest.NewRecorder()
	}

	func tearDown() {
	}

	func TestHandleGet(t *testing.T) {
		request, _ := http.NewRequest("GET", "/post/1", nil)
		mux.ServeHTTP(writer, request)

		if writer.Code != 200 {
			t.Errorf("Response code is %v", writer.Code)
		}
		var post Post
		json.Unmarshal(writer.Body.Bytes(), &post)
		if post.Id != 1 {
			t.Errorf("Cannot retrieve JSON post")
		}
	}

	func TestHandlePut(t *testing.T) {
		json := strings.NewReader(`{"content":"Updated post","author":"Sau Sheong"}`)
		request, _ := http.NewRequest("PUT", "/post/1", json)
		mux.ServeHTTP(writer, request)

		if writer.Code != 200 {
			t.Errorf("Response code is %v", writer.Code)
		}
	}


snippet Testing_Web_Applications_test_ginkgo_data
	package main

	import (
		"database/sql"
		_ "github.com/lib/pq"
	)

	type Post struct {
		Db      sql.DB
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	// Get a single post
	func (post *Post) retrieve(id int) (err error) {
		err = post.Db.QueryRow("select id, content, author from posts where id = $1", id).Scan(&post.Id, &post.Content, &post.Author)
		return
	}

	// Create a new post
	func (post *Post) create() (err error) {
		statement := "insert into posts (content, author) values ($1, $2) returning id"
		stmt, err := post.Db.Prepare(statement)
		if err != nil {
			return
		}
		defer stmt.Close()
		err = stmt.QueryRow(post.Content, post.Author).Scan(&post.Id)
		return
	}

	// Update a post
	func (post *Post) update() (err error) {
		_, err = post.Db.Exec("update posts set content = $2, author = $3 where id = $1", post.Id, post.Content, post.Author)
		return
	}

	// Delete a post
	func (post *Post) delete() (err error) {
		_, err = post.Db.Exec("delete from posts where id = $1", post.Id)
		return
	}


snippet Testing_Web_Applications_test_ginkgo_doubles
	package main

	type FakePost struct {
		Id      int
		Content string
		Author  string
	}

	func (post *FakePost) retrieve(id int) (err error) {
		post.Id = id
		return
	}

	func (post *FakePost) create() (err error) {
		return
	}

	func (post *FakePost) update() (err error) {
		return
	}

	func (post *FakePost) delete() (err error) {
		return
	}


snippet Testing_Web_Applications_test_ginkgo_ginkgo_suite_test
	package main_test

	import (
		. "github.com/onsi/ginkgo"
		. "github.com/onsi/gomega"

		"testing"
	)

	func TestGinkgo(t *testing.T) {
		RegisterFailHandler(Fail)
		RunSpecs(t, "Post CRUD Suite")
	}


snippet Testing_Web_Applications_test_ginkgo_server
	package main

	import (
		"database/sql"
		"encoding/json"
		_ "github.com/lib/pq"
		"net/http"
		"path"
		"strconv"
	)

	func main() {
		// connect to the Db
		var err error
		db, err := sql.Open("postgres", "user=gwp dbname=gwp password=gwp sslmode=disable")
		if err != nil {
			panic(err)
		}

		server := http.Server{
			Addr: "127.0.0.1:8080",
		}
		http.HandleFunc("/post/", HandleRequest(&Post{Db: *db}))
		server.ListenAndServe()
	}

	type Text interface {
		retrieve(id int) (err error)
		create() (err error)
		update() (err error)
		delete() (err error)
	}

	// main handler function
	func HandleRequest(t Text) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			var err error
			switch r.Method {
			case "GET":
				err = handleGet(w, r, t)
			case "POST":
				err = handlePost(w, r, t)
			case "PUT":
				err = handlePut(w, r, t)
			case "DELETE":
				err = handleDelete(w, r, t)
			}
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
		}
	}

	// Retrieve a post
	// GET /post/1
	func handleGet(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.retrieve(id)
		if err != nil {
			return
		}
		output, err := json.MarshalIndent(post, "", "\t\t")
		if err != nil {
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Write(output)
		return
	}

	// Create a post
	// POST /post/
	func handlePost(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, post)
		err = post.create()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Update a post
	// PUT /post/1
	func handlePut(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.retrieve(id)
		if err != nil {
			return
		}
		len := r.ContentLength
		body := make([]byte, len)
		r.Body.Read(body)
		json.Unmarshal(body, post)
		err = post.update()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}

	// Delete a post
	// DELETE /post/1
	func handleDelete(w http.ResponseWriter, r *http.Request, post Text) (err error) {
		id, err := strconv.Atoi(path.Base(r.URL.Path))
		if err != nil {
			return
		}
		err = post.retrieve(id)
		if err != nil {
			return
		}
		err = post.delete()
		if err != nil {
			return
		}
		w.WriteHeader(200)
		return
	}


snippet Testing_Web_Applications_test_ginkgo_test_ginkgo_test
	package main_test

	import (
		"encoding/json"
		. "github.com/onsi/ginkgo"
		. "github.com/onsi/gomega"
		. "gwp/Chapter_8_Testing_Web_Applications/test_ginkgo"
		"net/http"
		"net/http/httptest"
	)

	var _ = Describe("Get a post", func() {
		var mux *http.ServeMux
		var post *FakePost
		var writer *httptest.ResponseRecorder

		BeforeEach(func() {
			post = &FakePost{}
			mux = http.NewServeMux()
			mux.HandleFunc("/post/", HandleRequest(post))
			writer = httptest.NewRecorder()
		})

		Context("using an id", func() {
			It("should get a post", func() {
				request, _ := http.NewRequest("GET", "/post/1", nil)
				mux.ServeHTTP(writer, request)

				Expect(writer.Code).To(Equal(200))

				var post Post
				json.Unmarshal(writer.Body.Bytes(), &post)

				Expect(post.Id).To(Equal(1))
			})
		})

		Context("using a non-integer id", func() {
			It("should get a HTTP 500 response", func() {
				request, _ := http.NewRequest("GET", "/post/hello", nil)
				mux.ServeHTTP(writer, request)

				Expect(writer.Code).To(Equal(500))
			})
		})

	})


snippet Testing_Web_Applications_unit_testing_bench_test
	package main

	import (
	  "testing"
	)

	func BenchmarkDecode(b *testing.B) {
	  for i := 0; i < b.N; i++ {
		decode("post.json") 
	  }
	}

	func BenchmarkUnmarshal(b *testing.B) {
	  for i := 0; i < b.N; i++ {
		unmarshal("post.json")
	  }
	}

snippet Testing_Web_Applications_unit_testing_main
	package main

	import (
		"encoding/json"
		"fmt"
		"os"
	  "io/ioutil"
	)

	type Post struct {
		Id       int       `json:"id"`
		Content  string    `json:"content"`
		Author   Author    `json:"author"`
		Comments []Comment `json:"comments"`
	}

	type Author struct {
		Id   int    `json:"id"`
		Name string `json:"name"`
	}

	type Comment struct {
		Id      int    `json:"id"`
		Content string `json:"content"`
		Author  string `json:"author"`
	}

	// decode JSON from file to struct
	func decode(filename string) (post Post, err error) {
		jsonFile, err := os.Open(filename)
		if err != nil {
			fmt.Println("Error opening JSON file:", err)
			return
		}
		defer jsonFile.Close()

		decoder := json.NewDecoder(jsonFile)
		err = decoder.Decode(&post)
		if err != nil {
			fmt.Println("Error decoding JSON:", err)
			return
		}
		return
	}

	func unmarshal(filename string) (post Post, err error) {
		jsonFile, err := os.Open(filename)
		if err != nil {
			fmt.Println("Error opening JSON file:", err)
			return
		}
		defer jsonFile.Close()

		jsonData, err := ioutil.ReadAll(jsonFile)
		if err != nil {
			fmt.Println("Error reading JSON data:", err)
			return
		}
		json.Unmarshal(jsonData, &post)  
	  return
	}

	// Iterative Fibonacci
	func fibonacciIterative(n int) int {
		current, prev := 0, 1
		for i := 0; i < n; i++ {
			current, prev = current + prev, current
		}
		return current
	}

	// Recursive Fibonacci
	func fibonacciRecursive(n int) int {
		if n < 2 {
			return n
		} 
		return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2)
	}

	func main() {
		post, err := decode("post.json")
		if err != nil {
			fmt.Println("Error:", err)
		}
		fmt.Println("Post is", post)
	}


snippet Testing_Web_Applications_unit_testing_main_test
	package main

	import (
		"testing"
	  "time"
	)

	// Test the decode function
	func TestDecode(t *testing.T) {
		post, err := decode("post.json")
		if err != nil {
			t.Error(err)
		}
		if post.Id != 1 {
			t.Error("Post ID is not the same as post.json", post.Id)
		}
	  if post.Content != "Hello World!" {
		t.Error("Post content is not the same as post.json", post.Id)
	  }
	}

	func TestUnmarshal(t *testing.T) {
		post, err := unmarshal("post.json")
		if err != nil {
			t.Error(err)
		}
		if post.Id != 1 {
			t.Error("Post ID is not the same as post.json", post.Id)
		}
	  if post.Content != "Hello World!" {
		t.Error("Post content is not the same as post.json", post.Id)
	  }
	}


	// Test the encode function
	func TestEncode(t *testing.T) {
		t.Skip("Skipping encoding for now")
	}

	// Long running test case
	func TestLongRunningTest(t *testing.T) {
	  if testing.Short() {
		t.Skip("Skipping long running test in short mode")
	  }
	  time.Sleep(10 * time.Second)
	}



snippet Testing_Web_Applications_unit_testing_parallel_test
	package main

	// import (
	//   "testing"
	//   "time"
	// )
	//
	// func TestParallel_1(t *testing.T) {
	//   t.Parallel()
	//   time.Sleep(1 * time.Second)
	// }
	//
	// func TestParallel_2(t *testing.T) {
	//   t.Parallel()
	//   time.Sleep(2 * time.Second)
	// }
	//
	// func TestParallel_3(t *testing.T) {
	//   t.Parallel()
	//   time.Sleep(3 * time.Second)
	// }


snippet Leveraging_Go_Concurrency_channel_message_channel
	package main

	import (
		"fmt"
		"time"
	)

	func thrower(c chan int) {
		for i := 0; i < 5; i++ {
			c <- i
			fmt.Println("Threw  >>", i)
		}
	}

	func catcher(c chan int) {
		for i := 0; i < 5; i++ {
			num := <-c
			fmt.Println("Caught <<", num)
		}
	}

	func main() {
		c := make(chan int, 3)
		go thrower(c)
		go catcher(c)
		time.Sleep(100 * time.Millisecond)
	}


snippet Leveraging_Go_Concurrency_channel_select_channel
	package main

	import (
		"fmt"
	)

	func callerA(c chan string) {
		c <- "Hello World!"
		close(c)
	}

	func callerB(c chan string) {
		c <- "Hola Mundo!"
		close(c)
	}

	func main() {
		a, b := make(chan string), make(chan string)
		go callerA(a)
		go callerB(b)
		var msg string
		openA, openB := true, true
		for openA || openB {
			select {
			case msg, openA = <-a:
				if openA {
					fmt.Printf("%s from A\n", msg)
				}			
			case msg, openB = <-b:
				if openB {
					fmt.Printf("%s from B\n", msg)
				}			
			}
		}
	}

	// func main() {
	// 	a, b := make(chan string), make(chan string)
	// 	go callerA(a)
	// 	go callerB(b)
	// 	msg1, msg2 := "A", "B"
	// 	for {
	// 		time.Sleep(1 * time.Microsecond)
	//
	// 		select {
	// 		case msg1 = <-a:
	// 			fmt.Printf("%s from A\n", msg1)
	// 		case msg2 = <-b:
	// 			fmt.Printf("%s from B\n", msg2)
	// 		// default:
	// 		// 	fmt.Println("Default")
	// 		}
	// 		if msg1 == "" && msg2 == "" {
	// 			break
	// 		}
	//
	// 	}
	// }


snippet Leveraging_Go_Concurrency_channel_shared_channel
	package main

	import (
		"fmt"
		// "math/rand"
		"time"
		"runtime"
	)

	var DB Store

	type Store struct {
		hash map[string]string
		in chan [2]string
		out chan [2]string
	}

	func StoreInit() {
		DB = Store{
			hash: make(map[string]string),
			in: make(chan [2]string),
		}
		go func() {
			for {
				a := <-DB.in
				DB.hash[a[0]] = a[1]
			}
		}()
	}

	func (store *Store) Get(key string) (value string, err error) {
		value = store.hash[key]
		return
	}

	func (store *Store) Add(key string, value string) (err error) {
		a := [2]string{key, value}
		store.in <- a
		// store.hash[key] = value
		return
	}

	func (store *Store) Set(key string, value string) (err error) {

		return
	}

	func (store *Store) Del(key string) (err error) {

		return
	}

	func (store *Store) Pop(key string) (value string, err error) {

		return
	}


	func main() {
		runtime.GOMAXPROCS(4)
		StoreInit()
		for i := 0; i < 10; i++ {
			go DB.Add("a", "A")
			go DB.Add("a", "B")
			go DB.Add("a", "C")

			time.Sleep(1 * time.Microsecond)

			s, _ := DB.Get("a")
			fmt.Printf("%s ", s)

		}
	}


snippet Leveraging_Go_Concurrency_channel_wait_channel
	package main

	import "fmt"
	import "time"

	func printNumbers(w chan bool) {
		for i := 0; i < 10; i++ {
			time.Sleep(1 * time.Microsecond)
			fmt.Printf("%d ", i)
		}
		w <- true
	}

	func printLetters(w chan bool) {
		for i := 'A'; i < 'A'+10; i++ {
			time.Sleep(1 * time.Microsecond)
			fmt.Printf("%c ", i)
		}
		w <- true
	}

	func main() {
		w1, w2 := make(chan bool), make(chan bool)
		go printNumbers(w1)
		go printLetters(w2)
		<-w1
		<-w2
	}


snippet Leveraging_Go_Concurrency_goroutine_goroutine
	package main

	// import "fmt"
	import "time"

	func printNumbers1() {
		for i := 0; i < 10; i++ {
			// fmt.Printf("%d ", i)
		}
	}

	func printLetters1() {
		for i := 'A'; i < 'A'+10; i++ {
			// fmt.Printf("%c ", i)
		}
	}

	func printNumbers2() {
		for i := 0; i < 10; i++ {
			time.Sleep(1 * time.Microsecond)
			// fmt.Printf("%d ", i)
		}
	}

	func printLetters2() {
		for i := 'A'; i < 'A'+10; i++ {
			time.Sleep(1 * time.Microsecond)
			// fmt.Printf("%c ", i)
		}
	}

	func print1() {
		printNumbers1()
		printLetters1()
	}

	func goPrint1() {
		go printNumbers1()
		go printLetters1()	
	}

	func print2() {
		printNumbers2()
		printLetters2()
	}

	func goPrint2() {
		go printNumbers2()
		go printLetters2()
	}

	func main() {
	}


snippet Leveraging_Go_Concurrency_goroutine_goroutine_test
	package main

	import "testing"
	// import "time"

	// Test cases

	// normal run
	// func TestPrint1(t *testing.T) {
	// 	print1()
	// }
	//
	// // run with goroutines
	// func TestGoPrint1(t *testing.T) {
	// 	goPrint1()
	// 	time.Sleep(1 * time.Millisecond)
	// }
	//
	// // run with goroutines and some work
	// func TestGoPrint2(t *testing.T) {
	// 	goPrint2()
	// 	time.Sleep(1 * time.Millisecond)
	// }
	//
	// // Benchmark cases
	//
	// normal run
	func BenchmarkPrint1(b *testing.B) {
		for i := 0; i < b.N; i++ {
			print1()
		}
	}

	// run with goroutines
	func BenchmarkGoPrint1(b *testing.B) {
		for i := 0; i < b.N; i++ {
			goPrint1()
		}
	}

	// run with some work
	func BenchmarkPrint2(b *testing.B) {
		for i := 0; i < b.N; i++ {
			print2()
		}
	}

	// run with goroutines and some work
	func BenchmarkGoPrint2(b *testing.B) {
		for i := 0; i < b.N; i++ {
			goPrint2()
		}
	}


snippet Leveraging_Go_Concurrency_mosaic_concurrent_main
	package main

	import (
		"bytes"
		"encoding/base64"
		"fmt"
		"html/template"
		"image"
		"image/draw"
		"image/jpeg"
		"net/http"
		"os"
		"strconv"
		"sync"
		"time"
	)

	func main() {
		fmt.Println("Starting mosaic server ...")
		mux := http.NewServeMux()
		files := http.FileServer(http.Dir("public"))
		mux.Handle("/static/", http.StripPrefix("/static/", files))

		mux.HandleFunc("/", upload)
		mux.HandleFunc("/mosaic", mosaic)

		server := &http.Server{
			Addr:    "127.0.0.1:8080",
			Handler: mux,
		}
		TILESDB = tilesDB()

		fmt.Println("Mosaic server started.")
		server.ListenAndServe()

	}

	func upload(w http.ResponseWriter, r *http.Request) {
		t, _ := template.ParseFiles("upload.html")
		t.Execute(w, nil)
	}

	// cut out the image and return individual channels with image.Image
	// no encoding of JPEG
	func cut(original image.Image, db *DB, tileSize, x1, y1, x2, y2 int) <-chan image.Image {
		c := make(chan image.Image)
		sp := image.Point{0, 0}
		go func() {
			newimage := image.NewNRGBA(image.Rect(x1, y1, x2, y2))
			for y := y1; y < y2; y = y + tileSize {
				for x := x1; x < x2; x = x + tileSize {
					r, g, b, _ := original.At(x, y).RGBA()
					color := [3]float64{float64(r), float64(g), float64(b)}
					nearest := db.nearest(color)
					file, err := os.Open(nearest)
					if err == nil {
						img, _, err := image.Decode(file)
						if err == nil {
							t := resize(img, tileSize)
							tile := t.SubImage(t.Bounds())
							tileBounds := image.Rect(x, y, x+tileSize, y+tileSize)
							draw.Draw(newimage, tileBounds, tile, sp, draw.Src)
						} else {
							fmt.Println("error in decoding nearest", err, nearest)
						}
					} else {
						fmt.Println("error opening file when creating mosaic:", nearest)
					}
					file.Close()
				}
			}
			c <- newimage.SubImage(newimage.Rect)
		}()

		return c
	}

	// combine the images and return the encoding string
	func combine(r image.Rectangle, c1, c2, c3, c4 <-chan image.Image) <-chan string {
		c := make(chan string)
		// start a goroutine
		go func() {
			var wg sync.WaitGroup
			newimage := image.NewNRGBA(r)
			copy := func(dst draw.Image, r image.Rectangle, src image.Image, sp image.Point) {
				draw.Draw(dst, r, src, sp, draw.Src)
				wg.Done()
			}
			wg.Add(4)
			var s1, s2, s3, s4 image.Image
			var ok1, ok2, ok3, ok4 bool
			for {
				select {
				case s1, ok1 = <-c1:
					go copy(newimage, s1.Bounds(), s1, image.Point{r.Min.X, r.Min.Y})
				case s2, ok2 = <-c2:
					go copy(newimage, s2.Bounds(), s2, image.Point{r.Max.X / 2, r.Min.Y})
				case s3, ok3 = <-c3:
					go copy(newimage, s3.Bounds(), s3, image.Point{r.Min.X, r.Max.Y / 2})
				case s4, ok4 = <-c4:
					go copy(newimage, s4.Bounds(), s4, image.Point{r.Max.X / 2, r.Max.Y / 2})
				}
				if ok1 && ok2 && ok3 && ok4 {
					break
				}
			}
			// wait till all copy goroutines are complete
			wg.Wait()
			buf2 := new(bytes.Buffer)
			jpeg.Encode(buf2, newimage, nil)
			c <- base64.StdEncoding.EncodeToString(buf2.Bytes())
		}()
		return c
	}

	//  Handler function for fan-out and fan-in
	func mosaic(w http.ResponseWriter, r *http.Request) {
		t0 := time.Now()
		// get the content from the POSTed form
		r.ParseMultipartForm(10485760) // max body in memory is 10MB
		file, _, _ := r.FormFile("image")
		defer file.Close()
		tileSize, _ := strconv.Atoi(r.FormValue("tile_size"))
		//
		//   // decode and get original image
		original, _, _ := image.Decode(file)
		bounds := original.Bounds()
		db := cloneTilesDB()
		// fan-out
		c1 := cut(original, &db, tileSize, bounds.Min.X, bounds.Min.Y, bounds.Max.X/2, bounds.Max.Y/2)
		c2 := cut(original, &db, tileSize, bounds.Max.X/2, bounds.Min.Y, bounds.Max.X, bounds.Max.Y/2)
		c3 := cut(original, &db, tileSize, bounds.Min.X, bounds.Max.Y/2, bounds.Max.X/2, bounds.Max.Y)
		c4 := cut(original, &db, tileSize, bounds.Max.X/2, bounds.Max.Y/2, bounds.Max.X, bounds.Max.Y)
		// fan-in
		c := combine(bounds, c1, c2, c3, c4)
		buf1 := new(bytes.Buffer)
		jpeg.Encode(buf1, original, nil)
		originalStr := base64.StdEncoding.EncodeToString(buf1.Bytes())

		t1 := time.Now()
		images := map[string]string{
			"original": originalStr,
			"mosaic":   <-c,
			"duration": fmt.Sprintf("%v ", t1.Sub(t0)),
		}

		t, _ := template.ParseFiles("results.html")
		t.Execute(w, images)
	}


snippet Leveraging_Go_Concurrency_mosaic_concurrent_mosaic
	package main

	import (
		"fmt"
		"image"
		"image/color"
		"io/ioutil"
		"math"
		"os"
		"path/filepath"
		"sync"
	)

	type DB struct {
		mutex *sync.Mutex
		store map[string][3]float64
	}

	func (db *DB) nearest(target [3]float64) string {
		var filename string
		db.mutex.Lock()
		smallest := 1000000.0
		for k, v := range db.store {
			dist := distance(target, v)
			if dist < smallest {
				filename, smallest = k, dist
			}
		}
		delete(db.store, filename)
		db.mutex.Unlock()
		return filename
	}

	// resize an image by its ratio e.g. ratio 2 means reduce the size by 1/2, 10 means reduce the size by 1/10
	func resize(in image.Image, newWidth int) image.NRGBA {
		bounds := in.Bounds()
		width := bounds.Dx()
		ratio := width / newWidth
		out := image.NewNRGBA(image.Rect(bounds.Min.X/ratio, bounds.Min.X/ratio, bounds.Max.X/ratio, bounds.Max.Y/ratio))
		for y, j := bounds.Min.Y, bounds.Min.Y; y < bounds.Max.Y; y, j = y+ratio, j+1 {
			for x, i := bounds.Min.X, bounds.Min.X; x < bounds.Max.X; x, i = x+ratio, i+1 {
				r, g, b, a := in.At(x, y).RGBA()
				out.SetNRGBA(i, j, color.NRGBA{uint8(r >> 8), uint8(g >> 8), uint8(b >> 8), uint8(a >> 8)})
			}
		}
		return *out
	}

	// find the average color of the picture
	func averageColor(img image.Image) [3]float64 {
		bounds := img.Bounds()
		r, g, b := 0.0, 0.0, 0.0
		for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
			for x := bounds.Min.X; x < bounds.Max.X; x++ {
				r1, g1, b1, _ := img.At(x, y).RGBA()
				r, g, b = r+float64(r1), g+float64(g1), b+float64(b1)
			}
		}
		totalPixels := float64(bounds.Max.X * bounds.Max.Y)
		return [3]float64{r / totalPixels, g / totalPixels, b / totalPixels}
	}

	var TILESDB map[string][3]float64

	func cloneTilesDB() DB {
		db := make(map[string][3]float64)
		for k, v := range TILESDB {
			db[k] = v
		}
		tiles := DB{
			store: db,
			mutex: &sync.Mutex{},
		}
		return tiles
	}

	// populate a tiles database in memory
	func tilesDB() map[string][3]float64 {
		fmt.Println("Start populating tiles db ...")
		db := make(map[string][3]float64)
		files, _ := ioutil.ReadDir("tiles")
		for _, f := range files {
			name := filepath.Join("tiles", f.Name())
			file, err := os.Open(name)
			if err == nil {
				img, _, err := image.Decode(file)
				if err == nil {
					db[name] = averageColor(img)
				} else {
					fmt.Println("error in populating tiles db:", err, name)
				}
			} else {
				fmt.Println("cannot open file", name, "when populating tiles db:", err)
			}
			file.Close()
		}
		fmt.Println("Finished populating tiles db.")
		return db
	}

	// find the Eucleadian distance between 2 points
	func distance(p1 [3]float64, p2 [3]float64) float64 {
		return math.Sqrt(sq(p2[0]-p1[0]) + sq(p2[1]-p1[1]) + sq(p2[2]-p1[2]))
	}

	// find the square
	func sq(n float64) float64 {
		return n * n
	}


snippet Leveraging_Go_Concurrency_mosaic_original_main
	package main

	import (
		"bytes"
		"encoding/base64"
		"fmt"
		"html/template"
		"image"
		"image/draw"
		"image/jpeg"
		"net/http"
		"os"
		"strconv"
		"time"
		// "runtime"
	)

	func main() {
		// runtime.GOMAXPROCS(runtime.NumCPU())
		mux := http.NewServeMux()
		files := http.FileServer(http.Dir("public"))
		mux.Handle("/static/", http.StripPrefix("/static/", files))
		mux.HandleFunc("/", upload)
		mux.HandleFunc("/mosaic", mosaic)
		server := &http.Server{
			Addr:    "127.0.0.1:8080",
			Handler: mux,
		}
		// building up the source tile database
		TILESDB = tilesDB()
		fmt.Println("Mosaic server started.")
		server.ListenAndServe()
	}

	func upload(w http.ResponseWriter, r *http.Request) {
		t, _ := template.ParseFiles("upload.html")
		t.Execute(w, nil)
	}

	func mosaic(w http.ResponseWriter, r *http.Request) {
		t0 := time.Now()
		// get the content from the POSTed form
		r.ParseMultipartForm(10485760) // max body in memory is 10MB
		file, _, _ := r.FormFile("image")
		defer file.Close()
		tileSize, _ := strconv.Atoi(r.FormValue("tile_size"))
		// decode and get original image
		original, _, _ := image.Decode(file)
		bounds := original.Bounds()
		// create a new image for the mosaic
		newimage := image.NewNRGBA(image.Rect(bounds.Min.X, bounds.Min.X, bounds.Max.X, bounds.Max.Y))
		// build up the tiles database
		db := cloneTilesDB()
		// source point for each tile, which starts with 0, 0 of each tile
		sp := image.Point{0, 0}
		for y := bounds.Min.Y; y < bounds.Max.Y; y = y + tileSize {
			for x := bounds.Min.X; x < bounds.Max.X; x = x + tileSize {
				// use the top left most pixel as the average color
				r, g, b, _ := original.At(x, y).RGBA()
				color := [3]float64{float64(r), float64(g), float64(b)}
				// get the closest tile from the tiles DB
				nearest := nearest(color, &db)
				file, err := os.Open(nearest)
				if err == nil {
					img, _, err := image.Decode(file)
					if err == nil {
						// resize the tile to the correct size
						t := resize(img, tileSize)
						tile := t.SubImage(t.Bounds())
						tileBounds := image.Rect(x, y, x+tileSize, y+tileSize)
						// draw the tile into the mosaic
						draw.Draw(newimage, tileBounds, tile, sp, draw.Src)
					} else {
						fmt.Println("error:", err, nearest)
					}
				} else {
					fmt.Println("error:", nearest)
				}
				file.Close()
			}
		}

		buf1 := new(bytes.Buffer)
		jpeg.Encode(buf1, original, nil)
		originalStr := base64.StdEncoding.EncodeToString(buf1.Bytes())

		buf2 := new(bytes.Buffer)
		jpeg.Encode(buf2, newimage, nil)
		mosaic := base64.StdEncoding.EncodeToString(buf2.Bytes())

		t1 := time.Now()
		images := map[string]string{
			"original": originalStr,
			"mosaic":   mosaic,
			"duration": fmt.Sprintf("%v ", t1.Sub(t0)),
		}
		t, _ := template.ParseFiles("results.html")
		t.Execute(w, images)

	}


snippet Leveraging_Go_Concurrency_mosaic_original_mosaic
	package main

	import (
		"fmt"
		"image"
		"image/color"
		"io/ioutil"
		"math"
		"os"
	)

	// resize an image by its ratio e.g. ratio 2 means reduce the size by 1/2, 10 means reduce the size by 1/10
	func resize(in image.Image, newWidth int) image.NRGBA {
		bounds := in.Bounds()
		width := bounds.Max.X - bounds.Min.X
		ratio := width / newWidth
		out := image.NewNRGBA(image.Rect(bounds.Min.X/ratio, bounds.Min.X/ratio, bounds.Max.X/ratio, bounds.Max.Y/ratio))
		for y, j := bounds.Min.Y, bounds.Min.Y; y < bounds.Max.Y; y, j = y+ratio, j+1 {
			for x, i := bounds.Min.X, bounds.Min.X; x < bounds.Max.X; x, i = x+ratio, i+1 {
				r, g, b, a := in.At(x, y).RGBA()
				out.SetNRGBA(i, j, color.NRGBA{uint8(r), uint8(g), uint8(b), uint8(a)})
			}
		}
		return *out
	}

	// find the average color of the picture
	func averageColor(img image.Image) [3]float64 {
		bounds := img.Bounds()
		r, g, b := 0.0, 0.0, 0.0
		for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
			for x := bounds.Min.X; x < bounds.Max.X; x++ {
				r1, g1, b1, _ := img.At(x, y).RGBA()
				r, g, b = r+float64(r1), g+float64(g1), b+float64(b1)
			}
		}
		totalPixels := float64(bounds.Max.X * bounds.Max.Y)
		return [3]float64{r / totalPixels, g / totalPixels, b / totalPixels}
	}

	var TILESDB map[string][3]float64

	func cloneTilesDB() map[string][3]float64 {
		db := make(map[string][3]float64)
		for k, v := range TILESDB {
			db[k] = v
		}
		return db
	}

	// populate a tiles database in memory
	func tilesDB() map[string][3]float64 {
		fmt.Println("Start populating tiles db ...")
		db := make(map[string][3]float64)
		files, _ := ioutil.ReadDir("tiles")
		for _, f := range files {
			name := "tiles/" + f.Name()
			file, err := os.Open(name)
			if err == nil {
				img, _, err := image.Decode(file)
				if err == nil {
					db[name] = averageColor(img)
				} else {
					fmt.Println("error in populating tiles db:", err, name)
				}
			} else {
				fmt.Println("cannot open file", name, "when populating tiles db:", err)
			}
			file.Close()
		}
		fmt.Println("Finished populating tiles db.")
		return db
	}

	// find the nearest matching image
	func nearest(target [3]float64, db *map[string][3]float64) string {
		var filename string
		smallest := 1000000.0
		for k, v := range *db {
			dist := distance(target, v)
			if dist < smallest {
				filename, smallest = k, dist
			}
		}
		delete(*db, filename)
		return filename
	}

	// find the Eucleadian distance between 2 points
	func distance(p1 [3]float64, p2 [3]float64) float64 {
		return math.Sqrt(sq(p2[0]-p1[0]) + sq(p2[1]-p1[1]) + sq(p2[2]-p1[2]))
	}

	// find the square
	func sq(n float64) float64 {
		return n * n
	}


snippet Leveraging_Go_Concurrency_waitgroup_goroutine
	package main

	import "fmt"
	import "time"
	import "sync"

	func printNumbers2(wg *sync.WaitGroup) {
		for i := 0; i < 10; i++ {
			time.Sleep(1 * time.Microsecond)
			fmt.Printf("%d ", i)
		}
		wg.Done()
	}

	func printLetters2(wg *sync.WaitGroup) {
		for i := 'A'; i < 'A'+10; i++ {
			time.Sleep(1 * time.Microsecond)
			fmt.Printf("%c ", i)
		}
		wg.Done()
	}

	func main() {
		var wg sync.WaitGroup
		wg.Add(2)
		go printNumbers2(&wg)
		go printLetters2(&wg)
		wg.Wait()
	}


